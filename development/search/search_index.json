{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Hexital - Incremental Technical Analysis Library","text":"<p> \u00a0\u29c9 \u00a0\u29c9 \u00a0\u29c9 \u00a0\u29c9 \u00a0\u29c9 \u00a0\u29c9 </p> <p>Documentation: https://merlinr.github.io/Hexital/\u00a0\u29c9</p> <p>Source Code: https://github.com/MerlinR/Hexital\u00a0\u29c9</p> <p>Hexital is a Modern, fast Python library designed for technical analysis in financial markets, offering a range of indicators commonly used in trading strategies. What sets Hexital apart is its innovative design around quick incremental calculations, users can enjoy swift and efficient computation of indicators, making it ideal for applications requiring real-time analysis or iterative data processing.</p> <p>The key features are:</p> <ul> <li>Fast: High performance, faster then many other technical analysis libraries. *</li> <li>Easy: Designed for simplicity, with support for a variety of input data types.</li> <li>Versatile: Offers built-in tools for indicators, Candle patterns, Candlestick types and analysis tools.</li> <li>Intuitive: Consistent usage across indicators and tools, making it straightforward to use.</li> <li>Lightweight: Operates independently of third-party libraries for maximum simplicity.</li> </ul>  * estimation based on tests on an internally with other TA libraries  <p>The library differs from many other technical analysis libraries by employing an incremental computation method. Rather than reevaluating all data points, it selectively computes only the new or missing indicator values. This optimized approach ensures that generating new indicator values requires constant time complexity O(1), a stark contrast to the linear time complexity (O(n)) or worse exhibited by other libraries.</p> <p>BETA NOTE:  Hexital is in Beta, all Major features are implemented and not expected to have drastic changes. However some changes will still cause some Non-backward compatible. Ensure to read Changelog</p>"},{"location":"#installation","title":"Installation","text":""},{"location":"#stable","title":"Stable","text":"<p>A Pip and pypi package of the latest stable version available on Pypi\u00a0\u29c9</p> <pre><code>$ pip install hexital\n</code></pre>"},{"location":"#latest","title":"Latest","text":"<p>In case you want to install the latest development version from the repo.</p> <pre><code>$ pip install git+https://github.com/merlinr/hexital.git@development\n</code></pre>"},{"location":"#getting-started-examples","title":"Getting Started - Examples","text":"<p>Below are simple use of generating EMA indicator and Hexital object from a set of Candles, more guides available Here</p>"},{"location":"#ema-indicator","title":"EMA Indicator","text":"<p>An example of using Hexital to create an EMA indicator from a list of <code>dict</code> Candles.</p> <pre><code>from hexital import EMA, Candle\n\nmy_candles = [\n    {\"open\": 17213, \"high\": 2395, \"low\": 7813, \"close\": 3615, \"volume\": 19661},\n    {\"open\": 1301, \"high\": 3007, \"low\": 11626, \"close\": 19048, \"volume\": 28909},\n    {\"open\": 12615, \"high\": 923, \"low\": 7318, \"close\": 1351, \"volume\": 33765},\n    {\"open\": 1643, \"high\": 16229, \"low\": 17721, \"close\": 212, \"volume\": 3281},\n    {\"open\": 424, \"high\": 10614, \"low\": 17133, \"close\": 7308, \"volume\": 41793},\n    {\"open\": 4323, \"high\": 5858, \"low\": 8785, \"close\": 8418, \"volume\": 34913},\n    {\"open\": 13838, \"high\": 13533, \"low\": 4830, \"close\": 17765, \"volume\": 586},\n    {\"open\": 14373, \"high\": 18026, \"low\": 7844, \"close\": 18798, \"volume\": 25993},\n    {\"open\": 12382, \"high\": 19875, \"low\": 2853, \"close\": 1431, \"volume\": 10055},\n    {\"open\": 19202, \"high\": 6584, \"low\": 6349, \"close\": 8299, \"volume\": 13199},\n]\n# Convert Basic candles\ncandles = Candle.from_dicts(my_candles)\n\nmy_ema = EMA(candles=candles, period=3)\nmy_ema.calculate()\n\nprint(\"Latest EMA reading:\", my_ema.reading())  # 8408.7552\n</code></pre>"},{"location":"#appending-new-candle","title":"Appending new Candle","text":"<pre><code># Append new Candle\nmy_ema.append(Candle.from_dict({'open': 19723, 'high': 4837, 'low': 11631, 'close': 6231, 'volume': 38993}))\nprint(\"EMA reading:\", my_ema.reading())  # 7319.8776\n</code></pre> <p>NOTE: The latest EMA value is automatically calculated on append.</p>"},{"location":"#analysis-ema-for-rising-trend","title":"Analysis EMA for rising trend","text":"<p>Hexital has several built in analysis functions to handle simple candle movements calculations.</p> <pre><code>from hexital.analysis import rising\n\nprint(\"EMA Rising:\" rising(my_ema, \"EMA_3\", length=8)) # False\n</code></pre>"},{"location":"#hexital-grouping","title":"Hexital - Grouping","text":"<p>Hexital is designed for managing multiple indicators, having one set of candle's used by multiple indicator's they will automatically calculate new readings with new Candles. An  example using <code>WMA</code> and <code>EMA</code> in one <code>hexital</code> object, and calculating both indicators.</p> <pre><code>from hexital import EMA, WMA, Candle, Hexital\n\nmy_candles = [\n    {\"open\": 17213, \"high\": 2395, \"low\": 7813, \"close\": 3615, \"volume\": 19661},\n    {\"open\": 1301, \"high\": 3007, \"low\": 11626, \"close\": 19048, \"volume\": 28909},\n    {\"open\": 12615, \"high\": 923, \"low\": 7318, \"close\": 1351, \"volume\": 33765},\n    {\"open\": 1643, \"high\": 16229, \"low\": 17721, \"close\": 212, \"volume\": 3281},\n    {\"open\": 424, \"high\": 10614, \"low\": 17133, \"close\": 7308, \"volume\": 41793},\n    {\"open\": 4323, \"high\": 5858, \"low\": 8785, \"close\": 8418, \"volume\": 34913},\n    {\"open\": 13838, \"high\": 13533, \"low\": 4830, \"close\": 17765, \"volume\": 586},\n    {\"open\": 14373, \"high\": 18026, \"low\": 7844, \"close\": 18798, \"volume\": 25993},\n    {\"open\": 12382, \"high\": 19875, \"low\": 2853, \"close\": 1431, \"volume\": 10055},\n    {\"open\": 19202, \"high\": 6584, \"low\": 6349, \"close\": 8299, \"volume\": 13199},\n]\ncandles = Candle.from_dicts(my_candles)\n\nstrategy = Hexital(\"Demo Strat\", candles, [\n    WMA(name=\"WMA\", period=8),\n    EMA(period=3),\n])\nstrategy.calculate()\n\nprint(\"EMA reading:\", strategy.reading(\"EMA_3\")) # 8408.7552\nprint(\"WMA reading:\", strategy.reading(\"WMA\")) # 9316.4722\n</code></pre> <p>NOTE: WMA is called WMA as we set, EMA is generated name from core name <code>EMA</code> and the <code>period</code>.</p>"},{"location":"#appending-new-candle_1","title":"Appending new Candle","text":"<p>We can append a <code>Candle</code> to Hexital which is then used for all Indicator's, the EMA and WMA value's are again automatically calculated on append.</p> <pre><code># Append new Candle\nstrategy.append(\n    Candle.from_dict({\"open\": 19723, \"high\": 4837, \"low\": 11631, \"close\": 6231, \"volume\": 38993})\n)\n# New readings from both indicators using new Candle\nprint(\"EMA reading:\", strategy.reading(\"EMA_3\"))  # 7319.8776\nprint(\"WMA reading:\", strategy.reading(\"WMA\"))  # 8934.9722\n</code></pre>"},{"location":"#analysis-for-ema-and-wma-crossing","title":"Analysis for EMA and WMA Crossing","text":"<p>The several built in analysis functions can handle check across multiple indicator.</p> <pre><code>from hexital.analysis import cross\n\nprint(\"EMA Crossed WMA:\" cross(my_ema, \"EMA_3\", \"WMA\")) # False\n</code></pre> <p>NOTE: Can replace <code>cross</code> with <code>crossover</code> or <code>crossunder</code> for specific direction.</p>"},{"location":"#indicators","title":"Indicator's","text":"<p>A Further in depth list of Indicators.</p> <ul> <li>Average Directional Index (ADX)</li> <li>Aroon (AROON)</li> <li>Average True Range (ATR)</li> <li>Bollinger Bands (BBANDS)</li> <li>Counter (Counter)</li> <li>Chande Momentum Oscillator - (CMO)</li> <li>Donchian Channels (Donchian)</li> <li>Exponential Moving Average (EMA)</li> <li>Highest Lowest (HL)</li> <li>High Low Average (HLA)</li> <li>High Low Close (HLC)</li> <li>High Low Close Average (HLCA)</li> <li>Hull Moving Average (HMA)</li> <li>Jurik Moving Average Average (JMA)</li> <li>Keltner Channel (KC)</li> <li>Moving Average Convergence/Divergence (MACD)</li> <li>Money Flow Index (MFI)</li> <li>Midpoint Over Period (MOP)</li> <li>On Balance Volume (OBV)</li> <li>Pivot Points (PivotPoints)</li> <li>Relative Moving Average (RMA)</li> <li>Rate of Change (ROC)</li> <li>Relative strength Index (RSI)</li> <li>Relative Vigor Index (RVI)</li> <li>Simple Moving Average(SMA)</li> <li>Standard Deviation (STDEV)</li> <li>Standard Deviation Threshold (STDEVT)</li> <li>Stochastic Oscillator (STOCH)</li> <li>SuperTrend (Supertrend)</li> <li>True Range (TR)</li> <li>True Strength Index (TSI)</li> <li>Volume Weighted Average Price (VWAP)</li> <li>Volume Weighed Moving Averge (VWMA)</li> <li>Weighed Moving Average (WMA)</li> </ul>"},{"location":"#candlestick-patterns","title":"Candlestick Patterns","text":"<p>Simple useful Candle pattern recognition, such as Doji, hammer, etc</p> <ul> <li>Doji</li> <li>Dojistar</li> <li>Hammer</li> <li>Inverted Hammer</li> </ul>"},{"location":"#candlestick-types","title":"Candlestick Types","text":"<p>Hexital can also automatically convert Candlesticks into specific types, such as:</p> <ul> <li>Heikin-Ashi</li> </ul>"},{"location":"#candlestick-movements","title":"Candlestick Movements","text":"<p>Simple useful Candle Analysis methods such as those in Pine Scripting\u00a0\u29c9</p> <ul> <li>Positive/Negative Candle</li> <li>Rising/Falling</li> <li>Mean Based Rising/Falling Indicator</li> <li>Above/Below</li> <li>Highest/Lowest Indicator (Value)</li> <li>HighestBar/LowestBar Indicator (Offset how far back)</li> <li>Indicator Cross</li> <li>Indicator CrossOver/CrossUnder</li> <li>Flipped </li> </ul>"},{"location":"#testing","title":"Testing","text":"<p>Testing is a critical aspect of this library due to the complexity of ensuring the accuracy of generated indicator values. To achieve this, I rely on Pandas-TA\u00a0\u29c9 as the source of truth for indicator values.  Each indicator added to this library has at least one unit test, where the output is compared against the corresponding indicator output from Pandas-TA. Due to slight differences in calculations, particularly within NumPy, not all values are exactly identical. Therefore, if differences exceed a given threshold (usually beyond one decimal place).</p>"},{"location":"#speed-tests","title":"Speed Tests","text":"<p>The following charts illustrate the speed of Pandas-TA and Hexital in both bulk and incremental calculations. These results are obtained from running Pandas-TA and Hexital in bulk  and incremental modes.</p> <p> </p> <p>This chart illustrates the difference of performance for Hexital and Pandas-TA when calculating technical analysis. Demonstrating difference in calculation time for incrementally adding and regulating per candle; and bulk recalculating a specific number of candles. This chart demonstrates that traditional libraries like Pandas-TA, and others relying on Pandas, and NumPy suffer performance overhead during incremental processing due to memory reallocation when appending or concatenating data. This limitation is highlighted in their documentation, recommending processing data in bulk.</p> <p>In contrast, Hexital's pure Python implementation delivers exceptional performance in both bulk and incremental processing, with minimal overhead. It not only outpaces Pandas-TA in incremental operations but also performs faster, particularly on smaller datasets.</p>"},{"location":"#incremental-calculations","title":"Incremental Calculations","text":"<p>Using both libraries for a live incremental application, whereby at n candles we are appending a Candle to the dataset and calculating the new TA. It's clear Hexital is far out performing Pandas_TA, This is due to two major factors, firstly the speed of which python can append a list of data compared to Panda's dataframe; and secondly Hexital is only needs to calculate the latest candle compared to Pandas-TA which is recalculating the entire dataset.</p> <p> </p>  For reference, if using seconds Candle with 10,000 candles that is around 2 Hours 46 minutes."},{"location":"#bulk-calculations","title":"Bulk Calculations","text":"<p>In bulk calculations we see a different situation, Pandas-TA outperforms Hexital. Pandas-TA maintains consistent performance, with processing times starting at 0.08 seconds for 1,000 candles and remaining stable at this level for 10,000 candles. In contrast, Hexital exhibits faster processing times, starting at 0.025 seconds for 2,000 candles but increasing to 0.16 seconds for 10,000 candles. While Hexital is initially faster, there is a noticeable growth in processing time as the dataset size increases. Therefore, for backtesting with a large dataset, Pandas-TA offers superior performance, while Hexital may experience slowdowns.</p> <p> </p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the MIT license.</p>"},{"location":"analysis-catalogue/","title":"Analysis Functions","text":"<p>Candle analysis usage guide found at Analysis guide.</p> Pattern API Description Above above Above Analysis Checks whether the <code>indicator</code> reading is higher than the <code>indicator_cmp</code> reading. By default, it evaluates the latest candle but can also check <code>n</code> candles back. If any candle within the specified range is above, it returns <code>True</code>. Below below Below Analysis Checks whether the <code>indicator</code> reading is lower than the <code>indicator_cmp</code> reading. By default, it evaluates the latest candle but can also check <code>n</code> candles back. If any candle within the specified range is below, it returns <code>True</code>. Value Range value_range Value Range Analysis Calculates the difference between the minimum and maximum values for the given <code>indicator</code> within a specified range of candles. Includes the latest candle by default. If the specified length exceeds the available candles, it will evaluate all candles. Rising rising Rising Analysis Determines whether the <code>indicator</code> consistently rises across a specified range of candles. By default, it checks if the current indicator value is greater than the previous one. Falling falling Falling Analysis Determines whether the <code>indicator</code> consistently falling across a specified range of candles. By default, it checks if the current indicator value is lower than the previous one. Mean Rising mean_rising Mean Rising Analysis Evaluates whether the <code>indicator</code> is, on average, rising across a specified range of candles. By default, it checks if the current indicator value is higher than the average of the previous four readings. Mean Falling mean_falling Mean Falling Analysis Evaluates whether the <code>indicator</code> is, on average, falling across a specified range of candles. By default, it checks if the current indicator value is lower than the average of the previous four readings. Highest Reading highest Highest Reading Analysis Determines the highest value of the specified <code>indicator</code> over a given number of candles. By default, includes the latest candle and evaluates up to the previous four candles. Lowest Reading lowest Lowest Reading Analysis Determines the lowest value of the specified <code>indicator</code> over a given number of candles. By default, includes the latest candle and evaluates up to the previous four candles. Highest Bar Offset highestbar Highest Bar Offset Analysis Determines the offset (distance) to the candle with the highest reading of the specified <code>indicator</code> within a given range. By default, includes the latest candle and evaluates up to the previous four candles. Lowest Bar Offset lowestbar Lowest Bar Offset Analysis Determines the offset (distance) to the candle with the lowest reading of the specified <code>indicator</code> within a given range. By default, includes the latest candle and evaluates up to the previous four candles. Cross cross Cross Analysis Determines whether the <code>indicator</code> reading has crossed the <code>indicator_cmp</code> reading within a specified range of candles. The cross can occur in either direction. Crossover crossover Crossover Analysis Determines whether the <code>indicator</code> reading has crossed over the <code>indicator_cmp</code> reading within a specified range of candles. A crossover occurs when <code>indicator</code> transitions from below to above <code>indicator_cmp</code> within the given range. Crossunder crossunder Crossunder Analysis Determines whether the <code>indicator</code> reading has crossed under the <code>indicator_cmp</code> reading within a specified range of candles. A crossunder occurs when <code>indicator</code> transitions from above to below <code>indicator_cmp</code> within the given range. Flipped Reading flipped Flipped Reading Analysis Determines whether the <code>indicator</code> has \"flipped\" its value, meaning the current reading is different from its previous reading, and within the last <code>length</code> candles, the indicator was above its previous reading."},{"location":"candle-pattern-catalogue/","title":"Candle Pattern's","text":"<p>Candle Pattern's usage guide found at Analysis guide.</p> Pattern API Description Source Doji doji Doji PatternA candle body is Doji when it's shorter than 10% of the average of the n(10) previous candles' high-low range. github.com\u00a0\u29c9 Dojistar dojistar Dojistar PatternA Dojistar is either bearish or bullish, and is detected when we have a larger then average candle followed by a candle candle shorter than 10% of the average of the n(10) of the average and then the candle gaps up or down. A trend is required to find which direction. github.com\u00a0\u29c9 Hammer hammer Hammer PatternA Hammer is detected when the Candle's open and close values are considered shorter than 10% of the average of the n(10) candles. However the low is larger than the average. github.com\u00a0\u29c9 Inverted Hammer inverted_hammer Inverted Hammer PatternAn Inverted Hammer is detected when the Candle's open and close values are considered shorter than 10% of the average of the n(10) candles. However the high is larger than the average. github.com\u00a0\u29c9"},{"location":"candlesticks-catalogue/","title":"Candlestick's - Beta","text":"<p>Candlestick's usage guide found at Candlesticks guide.</p> Candlestick Type API Description Sources Heikin-Ashi  HeikinAshi Heikin-Ashi Heikin Ashi is a charting technique that can be used to predict future price movements. It is similar to traditional candlestick charts. However, unlike a regular candlestick chart, the Heikin Ashi chart tries to filter out some of the market noise by smoothing out strong price swings to better identify trend movements in the market. www.investopedia.com\u00a0\u29c9"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The project adheres to Semantic Versioning\u00a0\u29c9.</p>"},{"location":"changelog/#301","title":"3.0.1","text":"<p>Release Date: 2025-04-08</p> <ul> <li>CandlestickType now re-calculates after prepending to ensure prev transformed are still correct</li> <li>Optimise Indicator '_reading_dup' (I think im dumb)</li> <li>Updated 'resample_candles' to make use of CalcMode</li> </ul>"},{"location":"changelog/#300","title":"3.0.0","text":"<p>Release Date: 2025-04-08</p> <ul> <li> <p>Non-backward compatible changes:</p> <ul> <li>Hexital and Indicator 'append' will now only append to Candles and not sort placement.</li> <li>Renamed Indicator 'as_list' to 'readings'</li> <li>Renamed 'find_candles' to 'find_candle_pairing'</li> <li>Removed 'has_reading' as pointless with method 'exists'</li> <li>Candle with no 'timestamp' will no longer use current UTC time</li> </ul> </li> <li> <p>Candle's no longer require a Timestamp</p> </li> <li>Reworked and optimised 'append' and added 'insert' and 'prepend'</li> <li>Added IndicatorCollection as a way to better reference Indicator's</li> <li>More options when setting indicator 'Source' - str | Indicator | NestedSource</li> <li>Updated Sub/Managed Indicator's to generate name based of parents if none set</li> <li>Added Specific reading typing for Indicators</li> <li>Reworked CandlestickType to be faster and can generate larger set of Candlesticks</li> </ul>"},{"location":"changelog/#203","title":"2.0.3","text":"<p>Release Date: 2025-02-12</p> <ul> <li>Added option when converting Candle to include the readings</li> <li>Updated 'Settings' to work correctly in Indicator, and added it to Hexital</li> <li>Fixed<ul> <li>Fixed Minor bug in _find_calc_index</li> </ul> </li> </ul>"},{"location":"changelog/#202","title":"2.0.2","text":"<p>Release Date: 2025-02-04</p> <ul> <li>Added as_list and as_dict method's to Candle</li> <li>Added clean_copy to Candle to copy core values to new Candle object<ul> <li>Will remove indicators/sub_indicators</li> <li>Default used when appending new Candle</li> </ul> </li> <li>Added 'Readings' to Hexital</li> <li>Optimisation<ul> <li>Removed use of 'deepcopy' for 'clean_copy'</li> </ul> </li> <li>Fixes<ul> <li>Corrected filler candles in timeframe to have 0 aggregation factor</li> <li>Corrected VWAP Naming</li> <li>Prevent DEFAULT timeframe being same as another set timeframe<ul> <li>DEFAULT is renamed to the correct timeframe is set in Hexital</li> </ul> </li> </ul> </li> </ul>"},{"location":"changelog/#201","title":"2.0.1","text":"<p>Release Date: 2025-01-12*</p> <ul> <li>Fixes<ul> <li>Corrected merged candles not combining aggregation factor</li> <li>Fix error when appending a list with one Candle</li> </ul> </li> </ul>"},{"location":"changelog/#200","title":"2.0.0","text":"<p>Release Date: 2024-12-19</p> <ul> <li> <p>Non-backward compatible changes:</p> <ul> <li>Re-named several Hexital arguments<ul> <li>candles_lifespan -&gt; candle_life</li> <li>candlestick_type -&gt; candlestick</li> </ul> </li> <li>Re-named several Indicator arguments<ul> <li>input_value -&gt; source</li> <li>fullname_override -&gt; name</li> <li>candles_lifespan -&gt; candle_life</li> <li>candlestick_type -&gt; candlestick</li> <li>rounding_value -&gt; rounding</li> </ul> </li> <li>Candle's now require a timestamp, a single candle added will use the current UTC time</li> <li>Candle timeframe attribute:<ul> <li>Candle's now have a timeframe attribute, this shows the resolution of the Candle, this is optional for Candle's</li> <li>Merging Candle's now take into account first and last Candles for accurate Open/Close value updates</li> <li>Appending Candles will now be sorted, allowing to say Append missing or back data</li> <li>Improved the speed of Candle timeframe collapsing</li> </ul> </li> </ul> </li> <li> <p>Re-wrote Testing method</p> <ul> <li>Removed unreliable deepdiff rounding</li> <li>Removed soft Correlation Coefficient</li> <li>Custom accuracy none rounding driven custom diff check</li> </ul> </li> <li>Updated Movement methods to accept <code>Indicator | Hexital | List[Candle]</code> and searches the given   object to find the specific'd indicator(s)<ul> <li>Movement methods can now accept Indicator's from different timeframes when used with Hexital object</li> </ul> </li> <li>Added 'candles_average' method to Indicator</li> <li>Added 'exists' to do same as prev_exists for correct handling dict's</li> <li>Updated Candle to now accept either 'timestamp' or 'time' for time's in 'from_dict(s)'</li> <li>Updated 'reading_count' to accept an index to count from</li> <li>Updated Hexital append with optional 'timeframe' to select specific Candle's to append too</li> <li>Updated 'candles' in Hexital method to accept timeframe's or indicators</li> <li>Updated 'prev_exists' to correctly handle Dict's</li> <li> <p>Updated Rounding to accept 'None' to indicate no rounding, default is still 4</p> </li> <li> <p>Added Movements</p> <ul> <li>Added flipped, to detect changes in bool's or solid values</li> </ul> </li> <li>Added Indicators<ul> <li>Chande Momentum Oscillator (CMO)</li> <li>High Low Close Average (HLCA)</li> <li>Money Flow Index (MFI)</li> <li>Midpoint Over Period (MOP)</li> <li>Pivot Points (PivotPoints)</li> <li>Jurik Moving Average Average (JMA)</li> <li>Added Relative Vigor Index (RVI)</li> </ul> </li> <li>Alterations<ul> <li>Added Anchor to VWAP</li> <li>Renamed several Indicators Internal:<ul> <li>HighestLowest -&gt; HL</li> <li>HighLowAverage -&gt; HLA</li> <li>StandardDeviation -&gt; STDEV</li> <li>StandardDeviationThreshold -&gt; STDEVT</li> </ul> </li> </ul> </li> <li>Fixes<ul> <li>Fixed Timeframe rounding to correctly handle days</li> <li>Fixed OBV<ul> <li>No rounding for sub/managed indicators</li> </ul> </li> <li>Fixed STDEV/bbands<ul> <li>Corrected when start calculation</li> </ul> </li> <li>Fixed KC</li> </ul> </li> </ul>"},{"location":"changelog/#112","title":"1.1.2","text":"<p>Release Date: 2024-05-03</p> <ul> <li>Fixed Major incremental calculate flaw with sub indicators<ul> <li>Causing sub indicators to almost always re-calc entire set rather than latest (incrementally)</li> </ul> </li> <li>Optimised Analysis and Movement functions for less calls and less loops</li> <li>Removed Deepcopies on Candles unless being added to Extra timeframes to speed up appending</li> </ul>"},{"location":"changelog/#111","title":"1.1.1","text":"<p>Release Date: 2024-05-01</p> <ul> <li>Changed Movement rising/falling default length from 4 to 1</li> <li>Added better exceptions to Hexital verifying dict indicators</li> <li>Mass Indicator clean up to fix, unused/unended input_value's and unused sub indicators</li> <li>Fixed minor donchian error</li> <li>Fixed Highest and Lowest movement methods from returning bool False instead of None</li> <li>Added Indicators<ul> <li>Added HighestLowest (HL)</li> <li>Added Standard Deviation Threshold (STDEVTHRES)</li> </ul> </li> </ul>"},{"location":"changelog/#110","title":"1.1.0","text":"<p>Release Date: 2024-04-21</p> <ul> <li>Removed Movement/Patterns from Hexital/Indicator</li> <li>Removed get_indicator from Hexital as indicator already exists</li> <li>Renamed candles_all to get_candles</li> <li>Updated prev_exists to accept optional Indicator to be more useful</li> <li>Altered Indicator name reading, to avoid issue's such as \"TR\" in \"ATR\"</li> <li>Changed several methods to properties in Candle (positive, realbody, etc)</li> <li>Updated Candle to be more flexible with values</li> <li>Corrected correlation_coefficient for unit testing</li> <li>Added Indicators<ul> <li>Counter</li> <li>Aroon (aroon)</li> <li>Donchian Channels (donchian)</li> <li>Hull Moving Average (HMA)</li> <li>True Strength Index (TSI)</li> <li>Standard Deviation (STDEV)</li> <li>Bollinger Bands (BBANDS)</li> </ul> </li> <li>Added Patterns<ul> <li>Inverted Hammer</li> <li>Dojistar</li> </ul> </li> </ul>"},{"location":"changelog/#101","title":"1.0.1","text":"<p>Release Date: 2024-04-08</p> <ul> <li>Fixed #12 Inaccurate verify_indicators method in Hexital</li> </ul>"},{"location":"changelog/#100","title":"1.0.0","text":"<p>Release Date: 2024-02-11</p> <ul> <li>Moving Into BETA</li> <li>Added CandleManager<ul> <li>CandleManger replaces List[Candle] to manage Candles and controls CandlestickTypes, timeframes and lifespan</li> </ul> </li> <li>Added CandlestickType<ul> <li>CandlestickType modular parent to convert candlesticks to alt types,</li> <li>E.G Auto convert candles to heikin-ashi</li> <li>Can be added as str 'candlestick_type=\"ha\"' for heikin-ashi</li> </ul> </li> <li>Converted Candle to Class from Dataclass</li> <li>Added Many Candle analysis methods to Candle:<ul> <li>Positive, Negative, realbody, shadow_upper, shadow_lower, high_low</li> </ul> </li> <li>Added Tag and 'clean_values' to Candle to support conversion of Candlesticks</li> <li>Added Pattern_map, Movement_map, Indicator_map and Candlestick_map for easier control and possible modular altering</li> <li>Added Heikin-Ashi candlestick conversion</li> <li>Added better config inheritance from Hexital to Indicators</li> <li>Added calculate_index to hexital</li> <li>Added ability to call the movement and pattern methods from Hexital and Indicator for easier usage<ul> <li>above, below, cross, crossover, doji, hammer, etc..</li> </ul> </li> <li>Added sanitise_name to convert '.' to ',' to support name nesting</li> <li>Added more Exceptions to improve error's</li> <li>Added Candle ability to accept json str timestamp, therefore allowing direct conversion from Pandas -&gt; Hexital</li> <li>Fixed Hammer index pattern working correctly</li> <li>Changed Sub/managed indicators to auto populate candles field</li> <li>Changed 'as_list' property a method that can now take a nested indicator name</li> <li>Removed read property</li> <li>Renamed utils/candlesticks to utils/candles</li> </ul>"},{"location":"changelog/#040","title":"0.4.0","text":"<p>Release Date: 2024-01-22</p> <ul> <li>Cleaned up code and some potential Bugs ruff/pyright</li> <li>Added movement Above/Below and updated others to use it</li> <li>Updated collapse candle 'fill' to show essentially doji candle rather than copy prev</li> <li>Added Patterns:<ul> <li>Hammer Candle</li> </ul> </li> <li>Added a TimeFrame Enum with common timeframes for easier usage</li> <li>Renamed Pattern to Amorph and updated to only require either 'indicator' or 'analysis'</li> <li>Renamed candles_timerange to candles_lifespan, to be clearer of purpose and avoid confusion with candles_timeframe</li> <li>Updated Hexital/Amorph to accept patterns, movements and custom methods</li> <li>Major Fix: Re-wrote collapse_candles_timeframe to correctly handle candles,gaps and appending</li> <li>Fixed Doji pattern</li> <li>Fixed Supertrend Indicator</li> <li>Fixed Timeframe bug with candles reference in indicator that use sub indicators</li> <li>Fixed possible error in VWAP with no volumes traded</li> <li>Fixed bug with nested Indicator returning None for valid 0 Value</li> <li>Fixed purge not correctly purge sub and managed indicators</li> </ul>"},{"location":"changelog/#031","title":"0.3.1","text":"<p>Release Date: 2023-10-09</p> <ul> <li>Added candles_timerange to auto remove older than N candles</li> <li>Added 'Settings' propety, to output Indicator in a dict format, that can be fed into back into Hexital</li> <li>Updated Hexital to better take Pattern's as a dict input</li> <li>Updated Hexital dict input to accept custom method Patterns</li> <li>Fixed bug in Movement on to few candles</li> <li>Fixed bug where no timeframe indicator wasnt creating new copy of candles</li> <li>Fixed bug where collapsed timeframe candles will use first calculated indicator value<ul> <li>Meaning 1 minute candle that only had first 10 seconds, will never re-calculate for rest of the minute</li> </ul> </li> </ul>"},{"location":"changelog/#030","title":"0.3.0","text":"<p>Release Date: 2023-09-27</p> <ul> <li>Added Patterns:<ul> <li>Doji Candle</li> </ul> </li> <li>Added append method to Indicator just like Hexital</li> <li>Fixed bug where Hexital would alter indicator list</li> <li>Fixed bug in _find_calc_index with no candles</li> <li>Added Pattern Indicator, skeleton to run Any Patterns as a Indicator<ul> <li>E.G On all Candles automatically</li> </ul> </li> <li>Added support to generate Indicators on multiple timeframes at once<ul> <li>Allowing one set of candles to be used to generate higher timeframe indicators</li> <li>E.G 1m candles can be used to generate 10m indicators simultaneously with 1m indicators</li> </ul> </li> </ul>"},{"location":"changelog/#020","title":"0.2.0","text":"<p>Release Date: 2023-09-05</p> <ul> <li>Feature: Added timestamp (datetime) to Candle dataclass</li> <li>Feature: Can convert Candle from list and dict</li> <li>Feature: Can set timestamp(datetime) in lists/dict Candle conversion</li> <li>Feature: Added _validate_fields method to Indicators</li> <li>Added custom exceptions</li> <li>More thorough unit testing</li> <li>Updated Indicators accuracy to Truth source</li> <li>Added private index property to Indicator allowing simpler method calls<ul> <li>self.reading_by_index(index, self.input_value) -&gt; self.reading(self.input_value)</li> <li>Multiple Method's renamed/argument re-ordered</li> </ul> </li> <li>Added Indicators:<ul> <li>ADX</li> <li>HLA</li> <li>KC</li> <li>OBV</li> <li>RMA</li> <li>ROC</li> <li>STOCH</li> <li>SuperTrend</li> <li>VWAP</li> <li>VMA</li> <li>WMA</li> </ul> </li> </ul>"},{"location":"changelog/#011","title":"0.1.1","text":"<p>Release Date: 2023-08-28</p> <ul> <li>Nada</li> </ul>"},{"location":"changelog/#010","title":"0.1.0","text":"<p>Release Date: 2023-08-27</p> <ul> <li>Alpha release <code>hexital</code></li> </ul>"},{"location":"features/","title":"Features","text":"<p>Hexital is a powerful library for technical analysis, offering tools to calculate indicators and identify candlestick patterns from candle data. It also provides a range of utility functions to support custom analysis.</p> <p>This page outlines Hexital's key features, offers a brief introduction to using them, and includes links to detailed guides for deeper exploration.</p>"},{"location":"features/#indicators","title":"Indicators","text":"<p>The core feature of Hexital is its technical analysis indicators, offering an ever-growing list designed to cater to a variety of trading strategies. All indicators are incrementally calculated and derived from the Indicator class. They process data from a list of Candles; when a new candle is added, the indicator automatically updates with the latest calculated reading.</p> <p>Each indicator is highly configurable, featuring options tailored to its specific purpose as well as general settings to enhance usability. This flexibility allows traders to fine-tune indicators for their unique requirements. Additionally, Hexital\u2019s efficient incremental processing ensures minimal performance overhead, even when handling large datasets.</p> <p>For a comprehensive overview of available indicators, configuration options, and examples, check out the in-depth guide.</p> <p>A full list is available</p>"},{"location":"features/#indicator-chaining","title":"Indicator Chaining","text":"<p>Hexital allows you to chain indicators together seamlessly. In a chain, the output of one indicator can serve as the input for another, enabling automated, indefinite chaining of calculations.</p> <p>This feature provides significant flexibility for creating custom indicators. For example, you can use an EMA to smooth the output of another indicator or incorporate indicators within other indicators to enhance their calculations.</p> <p>A practical example is the calculation of the Stochastic Oscillator (STOCH). The <code>k</code> value of STOCH is used as the input for an SMA to compute the <code>d</code> value. Internally, this is implemented as the STOCH indicator chaining the SMA indicator, using its own <code>k</code> value as the input source.</p>"},{"location":"features/#custom-indicators","title":"Custom Indicator's","text":"<p>All indicators in Hexital are implemented as dataclass objects, following a consistent and straightforward pattern. Most methods are inherited from the base Indicator class, making it easy for users to create custom indicators. These custom indicators can be used individually or integrated into Hexital as part of a trading strategy.</p> <p>Below is an example of a custom indicator, which utilizes Indicator chaining. This custom indicator, HighLowAverageSmoothed, calculates the average of the high and low values for each candle, then smooths the result using an EMA.</p> <p>Defining the Custom Indicator:</p> <pre><code>from dataclasses import dataclass, field\n\nfrom hexital.core.indicator import Indicator, Managed\nfrom hexital.indicators.ema import EMA\n\n\n@dataclass(kw_only=True)\nclass HighLowAverageSmoothed(Indicator):\n    _name: str = field(init=False, default=\"HLASmooth\")\n\n    def _generate_name(self) -&gt; str:\n        return f\"{self._name}\"\n\n    def _initialise(self):\n        self.add_managed_indicator(\"EMA\", EMA(name=\"HLSmoothed\", source=\"HLAS_raw\", period=6))\n        self.add_managed_indicator(\"HLAS_raw\", Managed(name=\"HLAS_raw\"))\n\n    def _calculate_reading(self, index: int) -&gt; float | dict | None:\n        self.managed_indicators[\"HLAS_raw\"].set_reading(\n            (self.candles[index].high + self.candles[index].low) / 2\n        )\n        self.managed_indicators[\"EMA\"].calculate_index(index)\n        return self.reading(\"HLSmoothed\")\n</code></pre> <p>Using Custom Indicator:</p> <pre><code>from custom import HighLowAverageSmoothed\nfrom hexital import Candle, Hexital\n\nmy_candles = [\n    {\"open\": 17213, \"high\": 2395, \"low\": 7813, \"close\": 3615, \"volume\": 19661},\n    {\"open\": 1301, \"high\": 3007, \"low\": 11626, \"close\": 19048, \"volume\": 28909},\n    {\"open\": 12615, \"high\": 923, \"low\": 7318, \"close\": 1351, \"volume\": 33765},\n    {\"open\": 1643, \"high\": 16229, \"low\": 17721, \"close\": 212, \"volume\": 3281},\n    {\"open\": 424, \"high\": 10614, \"low\": 17133, \"close\": 7308, \"volume\": 41793},\n    {\"open\": 4323, \"high\": 5858, \"low\": 8785, \"close\": 8418, \"volume\": 34913},\n    {\"open\": 13838, \"high\": 13533, \"low\": 4830, \"close\": 17765, \"volume\": 586},\n    {\"open\": 14373, \"high\": 18026, \"low\": 7844, \"close\": 18798, \"volume\": 25993},\n    {\"open\": 12382, \"high\": 19875, \"low\": 2853, \"close\": 1431, \"volume\": 10055},\n    {\"open\": 19202, \"high\": 6584, \"low\": 6349, \"close\": 8299, \"volume\": 13199},\n]\ncandles = Candle.from_dicts(my_candles)\n\nstrategy = Hexital(\"Demo Strat\", candles, [HighLowAverageSmoothed()])\nstrategy.calculate()\nprint(strategy.reading(\"HLASmooth\"))\n</code></pre> <p>Usage</p> <p>Currently there is no Plugin ability for Indicator's to be auto picked up be <code>Hexital</code>, but can still be used.</p>"},{"location":"features/#timeframes","title":"Timeframes","text":"<p>A unique feature of Hexital is its ability to effortlessly compress candles into different timeframes. This means you can work using 1-second candles which will be generating 5-minute candles and their corresponding indicator readings, which update dynamically as new candles are added.</p> <p>Example:</p> <pre><code>from hexital import EMA, Candle\n\n# T5 being 5 minutes\nmy_ema = EMA(candles=candles, timeframe=\"T5\")\nmy_ema.calculate()\n\n# 1-second Candle stream\nasync with connect(data_stream) as websocket:\n    async for message in websocket:\n        candle_1s = await websocket.recv()\n        my_ema.append(Candle.from_dict(candle_1s))\n</code></pre> <p>The <code>timeframe</code> attribute exists in all Indicators and Hexital, using either TimeFrame, <code>strings</code>, <code>int</code> or <code>timedelta</code>.</p> <p>Compression</p> <p>It should go without saying, it cannot take 5 Minute candle's and downgrade them into second Candles.</p>"},{"location":"features/#hexital","title":"Hexital","text":"<p>he Hexital class is a foundational component of the library, designed to simplify and enhance the process of managing multiple indicators within a single, unified interface. It serves as a central hub, offering a streamlined way to configure, calculate, and analyse multiple indicators simultaneously, making it an essential tool for developing robust and scalable trading strategies.</p> <p>One of Hexital\u2019s key strengths is its ability to pass global configuration options to all the indicators it manages. This ensures consistency and reduces redundancy when working with large numbers of indicators or custom configurations. Additionally, the <code>Hexital</code> class allows for seamless integration of multiple timeframes, candlestick types, and chained indicators, making it highly versatile for a variety of trading use cases.</p> <p>Beyond configuration, Hexital provides direct access to all indicator readings, enabling you to query the latest values, historical data, and trends with minimal effort. Whether you are working with simple moving averages or complex custom indicators, the Hexital class unifies their management and processing, ensuring your strategy remains organized and efficient.</p> <p>It also supports the incremental calculation. Each appended candle triggers the calculation of the latest Candle across all associated indicators, ensuring your strategy remains up-to-date with the latest market data. This feature is particularly useful for live trading scenarios, where timely calculations are critical.</p> <p>Example:</p> <pre><code>from hexital import EMA, Supertrend, Candle, Hexital\n\nstrategy = Hexital(\"Demo Strat\", [], [\n        EMA(name=\"EMA_short\",),\n        Supertrend(name=\"supertrend\"),\n    ]\n)\n\n# Will run calculate on EMA and supertrend\nstrategy.calculate()\n\n# Appends a new Candle, triggering all indicators to calculate new readings\nstrategy.append(Candle(\n        open=12331.69,\n        high=12542.540,\n        low=12202.410,\n        close=12536.019,\n        volume=500,\n    )\n)\n</code></pre> <p>For a comprehensive overview of Hexital, configuration options, and examples, check out the in-depth guide.</p>"},{"location":"features/#multi-timeframes","title":"Multi-Timeframes","text":"<p>As explained in Timeframes, Hexital allows you to compress candles into larger timeframes. This functionality extends to multiple indicators across different timeframes, all while requiring only a single set of candle data.</p> <p>For example, if you are working using 1-second candles, you can generate:</p> <ul> <li>A 1-minute EMA</li> <li>A 5-minute SMA</li> <li>A 5-minute Supertrend</li> <li>A 1-hour EMA</li> </ul> <p>This is achieved by appending the 1-second candles into a Hexital object, which handles the timeframe conversions automatically.</p> <p>Example:</p> <pre><code>from hexital import EMA, SMA, Supertrend, Candle, Hexital\nfrom datetime import timedelta\n\nstrategy = Hexital(\"Demo Strat\", [], [\n        EMA(name=\"EMA_short\", period=14, timeframe=\"T1\"),\n        SMA(name=\"EMA_mid\", period=20, timeframe=300),\n        Supertrend(timeframe=\"T5\"),\n        EMA(name=\"EMA_long\", timeframe=timedelta(hours=1)),\n    ]\n)\n\n# 1-second Candle stream\nasync with connect(data_stream) as websocket:\n    async for message in websocket:\n        candle_1s = await websocket.recv()\n        my_ema.append(Candle.from_dict(candle_1s))\n</code></pre>"},{"location":"features/#candle","title":"Candle","text":"<p>The Candle class is a core object that the library expects as input. Candles can be created easily from <code>dicts</code> or <code>lists</code>.</p> <p>Using a custom object for this OHLCV provides several advantages:</p> <ul> <li>Calculated reading's are stored within the Candle itself, and not the indicator that generated it.</li> <li>The Candle object includes many useful methods, such as <code>positive</code>, <code>negative</code>, <code>realbody</code> etc</li> <li>Supports merging Candle's, which is used when collapsing Candle Timeframes.</li> <li>The Candle class provides factory methods for easily generating Candle objects</li> <li>Cache's itself for support of altering it's type</li> </ul> <p>However, developers can choose to use the Candle object simply as an OHLCV (Open, High, Low, Close, Volume) object if they prefer.</p> <pre><code>from hexital import Candle\n\nprint(Candle(\n        open=12331.69,\n        high=12542.540,\n        low=12202.410,\n        close=12536.019,\n        volume=500,\n    )\n)\n</code></pre> <p>For a comprehensive overview of Candle's, configuration options, and examples, check out the  guide.</p>"},{"location":"features/#analysis","title":"Analysis","text":"<p>When developing trading strategies, quick and efficient access to indicator readings is essential. Hexital is designed to simplify this process by providing intuitive tools to retrieve and analyse the latest, previous, or a set of historical readings for any configured indicator. These tools streamline the workflow of building strategies and allow developers to focus on decision-making logic rather than low-level data handling.</p> <p>The library ensures seamless integration of analysis functions into its architecture, allowing users to retrieve indicator readings and trends effortlessly. Whether you need to track a single indicator\u2019s movement or analyse crossovers and other patterns between multiple indicators, Hexital provides the tools to handle these scenarios effectively.</p> <p>Using:</p> <pre><code>strategy = Hexital(\"Demo Strat\", [], [\n        EMA(name=\"EMA_short\", period=14, timeframe=\"T1\"),\n        SMA(name=\"EMA_mid\", period=20, timeframe=300),\n        Supertrend(timeframe=\"T5\"),\n        EMA(name=\"EMA_long\", timeframe=timedelta(hours=1)),\n    ]\n)\n</code></pre> <p>Reading latest:</p> <pre><code>strategy.reading(\"EMA_long\")\n</code></pre> <p>Reading Prevouse:</p> <pre><code>strategy.prev_reading(\"EMA_mid\")\n</code></pre> <p>All Readings:</p> <pre><code>strategy.readings(\"Supertrend_7\")\n</code></pre>"},{"location":"features/#movement-functions","title":"Movement functions","text":"<p>In addition, Hexital offers a powerful suite of movement functions designed to detect and analyse trends and patterns in indicator readings. These functions integrate seamlessly with Indicator and Hexital objects, making them indispensable tools for strategy development. Whether you're evaluating trends, identifying critical market movements, these functions provide an efficient and straightforward way to extract actionable insights.</p> <p>Movement functions are designed to detect specific behaviors or changes in indicator readings over time. They simplify the implementation of complex trading logic, enabling strategies to react dynamically to market conditions. These functions also fully support multi-timeframe analysis, ensuring that indicators operating on different candlestick timeframes can be analysed together without any additional configuration.</p> <p>Using:</p> <pre><code>strategy = Hexital(\"Demo Strat\", [], [\n        EMA(name=\"EMA_short\", period=14, timeframe=\"T1\"),\n        SMA(name=\"EMA_mid\", period=20, timeframe=300),\n        Supertrend(timeframe=\"T5\"),\n        EMA(name=\"EMA_long\", timeframe=timedelta(hours=1)),\n    ]\n)\n</code></pre> <p>Long EMA is rising:</p> <pre><code>from hexital.analysis.movement import rising\nrising(strategy, \"EMA_long\", length=8)\n</code></pre> <p>Highest EMA_mid has been in last 100 Candles:</p> <pre><code>from hexital.analysis.movement import highest\ncrossover(highest, \"EMA_mid\", length=100)\n</code></pre> <p>Short EMA crossed Long EMA:</p> <pre><code>from hexital.analysis.movement import crossover\ncrossover(strategy, \"EMA_short\", \"Supertrend_7\", length=8)\n</code></pre> <p>Analysis over Timeframes</p> <p>Note that analysis such as crossover will work correctly when using them across multiple TimeFrames.</p> <p>A full list is available</p>"},{"location":"features/#patterns","title":"Patterns","text":"<p>Hexital goes beyond Indicators by offering robust pattern detection functions to identify common candlestick patterns, such as Doji, Dojistar, Hammer, and more. These functions are easy to use, versatile, and allow configuration like specifying a lookback period to analyse recent candles.</p> <p>Hexital\u2019s pattern detection is a powerful tool for spotting trends and reversals, and it pairs effectively with Indicators and movement functions. These pattern detection functions are designed to be simple and easy to use, as shown below:</p> <p>Using:</p> <pre><code>from hexital import EMA, Candle\n\n# T5 being 5 minutes\nmy_ema = EMA(candles=candles, timeframe=\"T5\")\nmy_ema.calculate()\n</code></pre> <p>Doji:</p> <pre><code>from hexital.analysis.patterns import doji\n\nprint(doji(my_ema.candles))\n</code></pre> <p>Doji occurred last 10 Candles:</p> <pre><code>from hexital.analysis.patterns import doji\n\nprint(doji(my_ema.candles, lookback=10))\n</code></pre> <p>Pattern Functions</p> <p>Note all pattern functions use a <code>List[Candle]</code> and can accept an optional <code>lookback</code> parameter to check for the pattern in the last N candles.</p> <p>A full list is available</p>"},{"location":"features/#automatically-calculate-patterns","title":"Automatically calculate patterns","text":"<p>In addition to pattern detection functions, Hexital features a unique amorph Indicator class. The Amorph indicator does not perform any calculations on its own. Instead, it is given a function (such as a pattern detection function) that runs for each appended candle. The output of that function becomes the reading of the indicator. This feature provides a special use case where users can treat functions as if they were indicators, and have them run automatically with minimal setup.</p> <p>Example:</p> <pre><code>from hexital.analysis.patterns import doji\nfrom hexital.indicators.amorph import Amorph\n\n# Use the 'doji' pattern detection function as an indicator\ntest = Amorph(analysis=patterns.doji, candles=candles)\ntest.calculate()\n</code></pre> <p>For a comprehensive overview of amorph, configuration options, and examples, check out the in-depth guide.</p>"},{"location":"features/#candlestick-types-beta","title":"Candlestick Types - BETA","text":"<p>The library also provides a way to convert traditional OHLCV Candles into different types of Candlesticks. This allows your inputted Candles to be automatically converted into chart types like Heikin-Ashi, prior to any Indicator calculations. As a result, all Indicator readings will be based on the newly converted Candlestick type. This approach works seamlessly with other configuration options like Timeframes.</p> <p>Example:</p> <pre><code>from hexital import EMA, Candle\nfrom hexital.candlesticks.heikinashi import HeikinAshi\n\n# EMA is calculated on the Heikin-Ashi converted Candles\nmy_ema = EMA(candles=candles, candlestick=HeikinAshi)\nmy_ema.calculate()\n</code></pre> <p>A full list is available</p>"},{"location":"features/#serialisation","title":"Serialisation","text":"<p>The design of Hexital allows for very easy serialisation, this is due to the way the readings are managed. Rather than indicator reading's being stored within the Indicator or Hexital, they are stored within the Candles themselves.</p> <p>This means you can simply store the Candles list elsewhere, such as DataBase, CSV or some cache. Which will keep all the readings and calculation data required by the Indicator or Hexital stored alongside the given Candles.</p>"},{"location":"features/#serialisation_1","title":"Serialisation","text":"<p>Below is a basic example of saving the Candle's alongside it's readings and calculation data. Whereby we simply save it into a CSV file.</p> <pre><code>TODO\n</code></pre>"},{"location":"features/#deserialisation","title":"Deserialisation","text":"<p>Deserialise is a simply process of reusing the given data to regenerate the Candle's.</p> <pre><code>TODO\n</code></pre>"},{"location":"indicator-catalogue/","title":"Indicator's","text":"<p>Indicator usage guide found at Quick Start Or  In depth.</p> Indicator API Description Sources Average Directional Index - ADX  ADX Average Directional Index - ADX ADX is a trend strength in a series of prices of a financial instrument. en.wikipedia.org\u00a0\u29c9 Aroon - AROON  AROON Aroon - AROON The Aroon indicator, indicates if a price is trending or is in a trading range. It can also reveal the beginning of a new trend, its strength and can help anticipate changes from trading ranges to trends. www.fidelity.com\u00a0\u29c9 Average True Range - ATR  ATR Average True Range - ATR Average True Range is used to measure volatility, especially volatility caused by gaps or limit moves. www.tradingview.com\u00a0\u29c9 Bollinger Bands - BBANDS  BBANDS Bollinger Bands - BBANDS Bollinger Bands are a type of statistical chart characterizing the prices and volatility over time of a financial instrument or commodity, using a formulaic method. www.britannica.com\u00a0\u29c9 Chande Momentum Oscillator - CMO  CMO Chande Momentum Oscillator - CMO The CMO indicator is created by calculating the difference between the sum of all recent higher closes and the sum of all recent lower closes and then dividing the result by the sum of all price movement over a given time period. The result is multiplied by 100 to give the -100 to +100 range. www.fidelity.com\u00a0\u29c9 Counter  Counter Counter Simple Indictor which will count the current streak of a given value, specifically designed for bool values, but useable on any other re-occurring values. E.G Count the streak for current input value == count_value Donchian Channels - Donchian  Donchian Donchian Channels - Donchian Donchian Channels are a technical indicator that seeks to identify bullish and bearish extremes that favor reversals, higher and lower breakouts, breakdowns, and other emerging trends. upstox.com\u00a0\u29c9en.wikipedia.org\u00a0\u29c9 Exponential Moving Average - EMA  EMA Exponential Moving Average - EMA The Exponential Moving Average is more responsive moving average compared to the Simple Moving Average (SMA).  The weights are determined by alpha which is proportional to it's length. www.investopedia.com\u00a0\u29c9 Highest Lowest - HL  HL Highest Lowest - HL Simple utility indicator to record and display the highest and lowest values N periods back. High Low Average - HLA  HLA High Low Average - HLA High Low Close Average - HLCA  HLCA High Low Close Average - HLCA Hull Moving Average - HMA  HMA Hull Moving Average - HMA It is a combination of weighted moving averages designed to be more responsive to current price fluctuations while still smoothing prices. school.stockcharts.com\u00a0\u29c9 Jurik Moving Average Average - JMA  JMA Jurik Moving Average Average - JMA The JMA is an adaptive moving average that aims to reduce lag and improve responsiveness to price changes compared to traditional moving averages. By incorporating volatility and phase shift components, the JMA seeks to provide traders with a more accurate and timely representation of market trends. c.mql5.com\u00a0\u29c9 Keltner Channel - KC  KC Keltner Channel - KC Keltner channel is a technical analysis indicator showing a central moving average line plus channel lines at a distance above and below. A popular volatility indicator similar to Bollinger Bands and Donchian Channels. www.investopedia.com\u00a0\u29c9 Moving Average Convergence Divergence - MACD  MACD Moving Average Convergence Divergence - MACD The MACD is a popular indicator to that is used to identify a security's trend. While APO and MACD are the same calculation, MACD also returns two more series called Signal and Histogram. The Signal is an EMA of MACD and the Histogram is the difference of MACD and Signal. www.investopedia.com\u00a0\u29c9 Money Flow Index - MFI  MFI Money Flow Index - MFI The money flow index (MFI) is an oscillator that ranges from 0 to 100. It is used to show the money flow over several days. www.tradingview.com\u00a0\u29c9 Midpoint Over Period - MOP  MOP Midpoint Over Period - MOP A technical analysis tool that evaluates the average price movement by calculating the midpoint between the highest and lowest points over a specified period. This indicator aims to provide a smoother representation of price action, avoiding the choppiness of extreme highs and lows. trendspider.com\u00a0\u29c9 On-Balance Volume - OBC  OBV On-Balance Volume - OBC On-balance volume (OBV) is a technical analysis indicator intended to relate price and volume in the stock market. OBV is based on a cumulative total volume. en.wikipedia.org\u00a0\u29c9 Pivot Points - PP  PivotPoints Pivot Points - PP Pivot point is a price level that is used by traders as a possible indicator of market movement. A pivot point is calculated as an average of significant prices (high, low, close) from the performance of a market in the prior trading period. If the market in the following period trades above the pivot point it is 1usually evaluated as a bullish sentiment, whereas trading below the pivot point is seen as bearish. en.wikipedia.org\u00a0\u29c9 wildeR's Moving Average - RMA  RMA wildeR's Moving Average - RMA Wilder's Moving Average places more emphasis on recent price movements than other moving averages. This makes it a more responsive tool for short-term traders who need to adapt quickly to changing market conditions. tlc.thinkorswim.com\u00a0\u29c9www.incrediblecharts.com\u00a0\u29c9 Rate Of Change - ROC  ROC Rate Of Change - ROC The Price Rate of Change (ROC) indicator in trading refers to the percentage change between the current price and the price of a set number of periods ago. It is used to identify the momentum of price movement and help traders make informed decisions regarding buying or selling assets. This indicator is calculated by dividing the difference between the current price and the price of a set number of periods ago by the previous price and multiplying by 100. en.wikipedia.org\u00a0\u29c9 Relative Strength Index - RSI  RSI Relative Strength Index - RSI The Relative Strength Index is popular momentum oscillator used to measure the velocity as well as the magnitude of directional price movements. www.tradingview.com\u00a0\u29c9 Relative Vigor Index - RVI  RVI Relative Vigor Index - RVI The Relative Vigor Index, or RVI, is a popular member of the \u201cOscillator\u201d family of technical indicators. although the creator of the Relative Vigor Index is unknown, its design is very similar to Stochastics except that the closing price is compared with the Open rather than the Low price for the period. www.thinkmarkets.com\u00a0\u29c9 Simple Moving Average - SMA  SMA Simple Moving Average - SMA The Simple Moving Average is the classic moving average that is the equally weighted average over n periods. www.investopedia.com\u00a0\u29c9 Rolling Standard Deviation - STDEV  STDEV Rolling Standard Deviation - STDEV You use a rolling stdev when you expect the standard deviation to change over time. As long as the standard deviation is changing slowly enough, we should be able to see the change in the standard deviation over time if we use the right size window. jonisalonen.com\u00a0\u29c9 Standard Deviation Threshold - STDEVT  STDEVT Standard Deviation Threshold - STDEVT Standard Deviation while calculating threshold returning boolean signal if change to input is higher than threshold Stochastic - STOCH  STOCH Stochastic - STOCH The Stochastic Oscillator (STOCH) was developed by George Lane in the 1950's. He believed this indicator was a good way to measure momentum because changes in momentum precede changes in price.  It is a range-bound oscillator with two lines moving between 0 and 100. The first line (%K) displays the current close in relation to the period's high/low range. The second line (%D) is a Simple Moving Average of the %K line. The most common choices are a 14 period %K and a 3 period SMA for %D.  %K = SMA(100 * (Current Close - Lowest Low) / (Highest High - Lowest Low), smoothK) %D = SMA(%K, periodD) www.tradingview.com\u00a0\u29c9 Supertrend  Supertrend Supertrend It is used to identify market trends and potential entry and exit points in trading. The indicator is based on two dynamic values, period and multiplier, and incorporates the concept of Average True Range (ATR) to measure market volatility. The SuperTrend Indicator generates buy and sell signals by plotting a line on the price chart. True Range - TR  TR True Range - TR An method to expand a classical range (high minus low) to include possible gap scenarios. www.macroption.com\u00a0\u29c9 True Strength Index - TSI  TSI True Strength Index - TSITSI attempts to show both trend direction and overbought/oversold conditions, using moving averages of the underlying momentum of a financial instrument. school.stockcharts.com\u00a0\u29c9 Volume-Weighted Average Price - VWAP  VWAP Volume-Weighted Average Price - VWAP The volume-weighted average price is a technical analysis indicator used on intraday charts that resets at the start of every new trading session. www.investopedia.com\u00a0\u29c9 Volume Weighted Moving Average - VWMA  VWMA Volume Weighted Moving Average - VWMA VWMA is the ratio of the value of a security or financial asset traded to the total volume of transactions during a trading session. It is a measure of the average trading price for the period. www.investopedia.com\u00a0\u29c9 Weighted Moving Average - WMA  WMA Weighted Moving Average - WMA A Weighted Moving Average puts more weight on recent data and less on past data. This is done by multiplying each bar's price by a weighting factor. Because of its unique calculation, WMA will follow prices more closely than a corresponding Simple Moving Average. www.investopedia.com\u00a0\u29c9"},{"location":"about/alternatives/","title":"Alternatives","text":""},{"location":"about/alternatives/#talipp","title":"Talipp","text":"<p>Talipp (a.k.a. tali++) is a popular Python library implementing financial indicators for technical analysis. This is the only popular library which focuses incremental computation.</p> <p>Pros</p> <ul> <li>Incremental computation</li> <li>Fast computation</li> <li>Extremely easy to setup</li> <li>Good Documentation</li> </ul> <p>Cons</p> <ul> <li>Input to Indicator's is list of single values, having to alter what you append into an indicator.</li> <li>Relatively limited</li> <li>No useful analysis or candle pattern methods</li> </ul> <p>Talipp is an fantastic technical analysis library and the only other one i know of that's incremental, it's fast and very easy to setup and use. Talipp was the inspiration for Hexital. It's a great library and well maintained, however the input type, the interaction with the output, the lack of ability managing multiple indicators; left a lot to be desired.</p> <p>Source: Talipp\u00a0\u29c9</p>"},{"location":"about/alternatives/#pandas-ta-pandas","title":"Pandas-TA (pandas)","text":"<p>Pandas-TA is arguably the most popular and well rounded Python library for calculating technical analysis, it can use TA-lib (A very fast C technical analysis library) if installed. It uses Pandas/Numpy which means it can work well with many other tools, it's very quick at calculating large sets of indicators. It's very well maintained with loads of dev involvement in the Issue's. It has an vast and ever growing amount of Indicators, it can also calculate Candle Patterns and supports strategies for bulk Indicator calculations.</p> <p>Pros</p> <ul> <li>Very Fast</li> <li>Vast amount of Indicator's and Candle patterns</li> <li>Can use TA-lib for faster performance and more indicators</li> <li>Well Maintained</li> <li>Pandas-TA Strategies for bulk Indicator calculations</li> </ul> <p>Cons</p> <ul> <li>Bulk Calculations</li> <li>Very slow incremental calculations due to append to Pandas and bulk calc</li> </ul> <p>Pandas-TA is by far the most popular and most rounded Python technical analysis library. It's also one of the fastest with optional multiprocessing. If you want to be using Pandas this is the library to use. If you are focusing on backtesting this is the fastest library. Pandas-TA only flaw is that it can only do bulk calculations, that combined with Numpy/Pandas very slow appending to existing dataframes; makes Pandas-TA extremely slow when running incrementally. This problem gets exponentially worse as we get more candles.</p> <p>Source: Pandas-TA\u00a0\u29c9</p>"},{"location":"about/alternatives/#ta-technical-analysis-pandas","title":"TA - Technical Analysis (pandas)","text":"<p>Another very popular Pandas Python technical analysis library, well maintained with a good amount of indicators. It's one of the older libraries that sticks to the Unix philosophy of 'Do one thing and do it well'. Calculate Indicators.</p> <p>Pros</p> <ul> <li>Large amount of Indicator's</li> <li>Lightweight/simple - What you see is what you get</li> <li>Lots of control over indicator output - Manually setup indicator features you want to output</li> </ul> <p>Cons</p> <ul> <li>Raw results, no handling of NaN's</li> <li>Finicky to setup, the fine tuning of each value from each indicator is messy</li> <li>Bulk Calculations</li> <li>Very slow incremental calculations due to append to Pandas and bulk calc</li> </ul> <p>I have personally not used TA in depth, However it's well regarded and has a large user base. You also get a lot of fine tuning on what features and results you want from each indicator, however this also means far more setup for each indicator. Source: TA\u00a0\u29c9</p>"},{"location":"about/alternatives/#not-maintained","title":"Not maintained","text":""},{"location":"about/alternatives/#tulip-indicators-numpy","title":"Tulip Indicators (Numpy)","text":"<p>Tulip Indicators is maintained, however the python binding's is not.</p> <p>Source: Tulip Indicators\u00a0\u29c9</p>"},{"location":"about/alternatives/#finta-pandas","title":"Finta (Pandas)","text":"<p>This repository has been archived by the owner on Sep 2, 2022.</p> <p>Source: Finta\u00a0\u29c9</p>"},{"location":"about/alternatives/#pyti-pandas","title":"Pyti (pandas)","text":"<p>Last Updated May 8, 2018.</p> <p>Source: Pyti\u00a0\u29c9</p>"},{"location":"about/design/","title":"Design And Future Plans","text":""},{"location":"about/design/#design","title":"Design","text":"<p>Hexital is designed with usability and ease of use in mind, making it simple to add new candles and automatically generate indicators while identifying patterns or trends. Inspired by Pandas-TA\u00a0\u29c9, Hexital allows you to create an object configured with indicators across multiple timeframes. By appending a new candle, all updated indicator values are ready for immediate use in your trading strategy.</p> <p>A unique aspect of Hexital is that results are stored directly within the candles, rather than within indicator objects. This design ensures that even if you clear your Hexital instance or indicators, the candles retain their indicator readings. This makes it easy to export and save candles to a database for reuse elsewhere.</p> <p>Additionally, this approach supports caching candles. If the application is restarted, the cached candles, combined with the Hexital configuration, can seamlessly restore both the candles and their indicator values, enabling incremental calculations to resume immediately.</p>"},{"location":"about/design/#future-plans","title":"Future Plans","text":"<p>Hexital is currently in <code>Beta</code>. The focus during this phase is to avoid altering core frameworks and instead prioritise making the library more robust and user-friendly. The current implementation of indicators and patterns is straightforward, allowing for easy expansion. However, the addition of new indicators will slow down temporarily to concentrate on enhancing robustness, ease of use, standardization, and error handling.</p>"},{"location":"about/design/#plans","title":"Plans","text":"<p>An outline of planned goals for Hexital, in no particular order:</p> <ul> <li>Robust code<ul> <li>Better Error handling</li> <li>Clearer methods to expected outputs</li> <li>Full docstrings</li> </ul> </li> <li>More Quality of life features</li> <li>100% Test coverage</li> <li>More Indicators</li> <li>More Movement methods</li> <li>More Patterns</li> <li>Indicator Pluggability, allow easy way to easily extend Hexital Indictors with own created indicators<ul> <li>Allowing easier custom Indicators to be added</li> </ul> </li> <li>Multiprocessing, of indicators stored within hexital Class.<ul> <li>Likely wont see increase in performance</li> </ul> </li> </ul>"},{"location":"about/design/#inspiration","title":"Inspiration","text":"<p>Hexital was inspired by Pandas-TA\u00a0\u29c9 and TALIpp\u00a0\u29c9, another Incremental Technical Analysis Library. However, I found Tallip usage with separate input lists rather cumbersome compared to working with an entire candle. Additionally, in TALIpp, outputs are separate entities, requiring extensive management. In contrast, Pandas-TA was easy to work with, and offered a way to use one set of input data and have multiple Indicator's for a Candle and results existing within one Candle; however was slower for incremental data due to Panda's.</p> <p>Hexital took the inspiration from Tallip incremental calculation, and Pandas-TA ease of use and grouped Indicators and easy to read results. It was further extended from Pandas-TA by offering methods to detect candlestick patterns; however goes further offering analysis tools and the ability to compress data into different timeframes.</p>"},{"location":"guides/analysis-indepth/","title":"Guide: Analysis","text":"<p>TODO</p>"},{"location":"guides/candles/","title":"Candle's","text":""},{"location":"guides/candlesticks/","title":"Guide: Candlestick repainting","text":"<p>TODO</p>"},{"location":"guides/custom-indicator/","title":"Guide: Creating an Indicator","text":"<p>TODO</p>"},{"location":"guides/custom-indicator/#inherited","title":"Inherited","text":""},{"location":"guides/custom-indicator/#amorph","title":"Amorph","text":""},{"location":"guides/hexital-indepth/","title":"Guide: Hexital","text":"<p>TODO</p>"},{"location":"guides/indicators-indepth/","title":"Guide: Indicators","text":"<p>TODO</p>"},{"location":"guides/indicators-indepth/#chaining","title":"Chaining","text":""},{"location":"guides/quick-start/","title":"Quick Start","text":""},{"location":"guides/quick-start/#introduction","title":"Introduction","text":"<p>This page is a quick start guide on generating your first technical indicator using Hexital, as well as using it to generate a set of technical indicators with some useful common situations and features.</p>"},{"location":"guides/quick-start/#creating-candles","title":"Creating Candles","text":"<p>Hexital use's it's own Candle object used for generating technical indicator readings, these are a core part of Hexital and can therefore be created in several different ways.</p> Automatically when appendingDirectlyFrom ListFrom DictFrom CSVFrom Pandas <p>To simplify the process of converting your data into Candle objects used by Hexital the Indicator objects can accept a variety of formats and convert them for you. The format's it can accept are <code>Lists</code>, <code>Dicts</code> which are also explained here.</p> <pre><code>from hexital import EMA, Candle\n\nmy_ema = EMA(candles=[])\n# EMA Indicator accepting a list format which will be converted to a Candle object prior to calculation.\nmy_ema.append([datetime(2023, 12, 1, 14, 30), 1.2345, 1.2500, 1.2300, 1.2450, 10000])\n\n# EMA Indicator accepting a dict format which will be converted to a Candle object prior to calculation.\nmy_ema.append(\n    Candle.from_dict(\n        {\n            \"open\": 1.2345,\n            \"high\": 1.2500,\n            \"low\": 1.2300,\n            \"close\": 1.2450,\n            \"volume\": 10000,\n            \"timestamp\": datetime(2023, 12, 1, 14, 30),\n        }\n    )\n)\n</code></pre> <p>You can create a Candle instance by providing its required attributes: <code>open</code>, <code>high</code>, <code>low</code>, <code>close</code>, and <code>volume</code>.</p> <pre><code>from datetime import datetime\nfrom hexital import Candle\n\n# Create a Candle with explicit values\ncandle = Candle(\n    open=1.2345,\n    high=1.2500,\n    low=1.2300,\n    close=1.2450,\n    volume=10000,\n    timestamp=datetime(2023, 12, 1, 14, 30),\n    timeframe=\"1h\"\n)\n\nprint(candle)\n# Output: Candle(open=1.2345, high=1.25, low=1.23, close=1.245, volume=10000)\n</code></pre> <p>You can use the from_list class method to create a Candle from a list containing the following attributes in order:</p> <p><code>[timestamp (optional), open, high, low, close, volume, timeframe (optional)]</code></p> <pre><code>from datetime import datetime\nfrom hexital import Candle\ncandle_data = [datetime(2023, 12, 1, 14, 30), 1.2345, 1.2500, 1.2300, 1.2450, 10000, \"1h\"]\n\n# Create a Candle using from_list\ncandle = Candle.from_list(candle_data)\n\nprint(candle)\n# Output: Candle(open=1.2345, high=1.25, low=1.23, close=1.245, volume=10000)\n</code></pre> <p>from_lists</p> <p>Another method called from_lists which accept's a list of list's to convert, returning a List[Candle].</p> <p>You can create a Candle instance from a dictionary by using the from_dict class method. This is especially useful when working with JSON data or API responses.</p> <pre><code>from datetime import datetime\nfrom hexital import Candle\n\ncandle_dict = {\n    \"open\": 1.2345,\n    \"high\": 1.2500,\n    \"low\": 1.2300,\n    \"close\": 1.2450,\n    \"volume\": 10000,\n    \"timestamp\": datetime(2023, 12, 1, 14, 30),\n    \"timeframe\": \"1h\",\n}\ncandle = Candle.from_dict(candle_dict)\nprint(candle)\n# Output: Candle(open=1.2345, high=1.25, low=1.23, close=1.245, volume=10000)\n</code></pre> <p>!!! info \"from_dicts\"     Another method called from_dicts which accept's a list of dict's to convert, returning a List[Candle].</p> <p>TODO\u00a0\u29c9</p> <p>Panda dataframes can be converted using dataframes <code>to_dict</code>\u00a0\u29c9 method and feeding the result into the Candle from_dicts class method.</p> <pre><code>from hexital import EMA, Candle\nimport pandas as pd\n\ndf = pd.read_csv(\"path/to/symbol.csv\", sep=\",\")\ncandles = Candle.from_dicts(df.to_dict(\"records\"))\n\nmy_ema = EMA(candles=candles)\nmy_ema.calculate()\n\nprint(\"EMA reading:\", my_ema.reading())\n</code></pre>"},{"location":"guides/quick-start/#ema-indicator","title":"EMA Indicator","text":"<p>The purpose of Hexital is to incrementally create technical indicator readings, therefore it's made to be relatively simple. Below is example's of using Hexital to create an EMA indicator from a list of <code>dict</code> Candles. As well as some common and useful configurations.</p> <pre><code>from hexital import EMA, Candle\nfrom datetime import timedelta\n\nmy_candles = [\n    {\"open\": 17213, \"high\": 2395, \"low\": 7813, \"close\": 3615, \"volume\": 19661},\n    {\"open\": 1301, \"high\": 3007, \"low\": 11626, \"close\": 19048, \"volume\": 28909},\n    {\"open\": 12615, \"high\": 923, \"low\": 7318, \"close\": 1351, \"volume\": 33765},\n    {\"open\": 1643, \"high\": 16229, \"low\": 17721, \"close\": 212, \"volume\": 3281},\n    {\"open\": 424, \"high\": 10614, \"low\": 17133, \"close\": 7308, \"volume\": 41793},\n    {\"open\": 4323, \"high\": 5858, \"low\": 8785, \"close\": 8418, \"volume\": 34913},\n    {\"open\": 13838, \"high\": 13533, \"low\": 4830, \"close\": 17765, \"volume\": 586},\n    {\"open\": 14373, \"high\": 18026, \"low\": 7844, \"close\": 18798, \"volume\": 25993},\n    {\"open\": 12382, \"high\": 19875, \"low\": 2853, \"close\": 1431, \"volume\": 10055},\n    {\"open\": 19202, \"high\": 6584, \"low\": 6349, \"close\": 8299, \"volume\": 13199},\n]\n# Convert Basic candles\ncandles = Candle.from_dicts(my_candles)\n\nmy_ema = EMA(name=\"EMA_Short\", candles=candles, period=3, candle_life=timedelta(hours=2))\nmy_ema.calculate()\n\nprint(\"Latest EMA reading:\", my_ema.reading())  # 8408.7552\n</code></pre>"},{"location":"guides/quick-start/#ema-period","title":"EMA period","text":"<p>In the given example the length/period of the EMA indicator is 3. This is of course configurable. <pre><code>my_ema = EMA(name=\"EMA_Short\", candles=candles, period=3, candle_life=timedelta(hours=2))\n</code></pre></p>"},{"location":"guides/quick-start/#appending-new-candle","title":"Appending new Candle","text":"<p>Hexital is designed to be constantly receiving and updating it's Candle list and TA readings, therefore they can easily append new candles in a variety of formats; As explained in the Candle section. <pre><code># Append new Candle\nmy_ema.append(Candle.from_dict({'open': 19723, 'high': 4837, 'low': 11631, 'close': 6231, 'volume': 38993}))\nprint(\"EMA reading:\", my_ema.reading())  # 7319.8776\n</code></pre></p> <p>Auto calculation</p> <p>We dont need to call calculation method as it's done automatically on append.</p>"},{"location":"guides/quick-start/#indicator-candle_life","title":"Indicator candle_life","text":"<p>All indicators have the configuration option <code>candle_life</code>, this is optional configuration which is useful for very large everygrowing set of Candle's. This attribute will automatically cull the list of Candle's it stores based on it's age, in this case once a Candle is 2 hours old it will be removed.</p> <pre><code>my_ema = EMA(name=\"EMA_Short\", candles=candles, period=3, candle_life=timedelta(hours=2))\n</code></pre> <p>Candle life</p> <p>Extremely useful for managing memory constraints, but note you will also lose the TA readings alongside the Candle's.</p>"},{"location":"guides/quick-start/#ema-indicator-name","title":"EMA Indicator name","text":"<p>We manually selected the Indicator name, this is optional, however recommended when dealing with many indicators, the default naming is generated based on the TA name and the period set. E.G <code>EMA_3</code> would otherwise be generated. <pre><code>my_ema = EMA(name=\"EMA_Short\", candles=candles, period=3, candle_life=timedelta(hours=2))\n</code></pre></p>"},{"location":"guides/quick-start/#analysis-ema-for-rising-trend","title":"Analysis EMA for rising trend","text":"<p>You can also directly use one of Hexital's built in analysis functions to handle simple movements calculations, for example to check if the EMA value we are generating is rising or falling.</p> <pre><code>from hexital.analysis import rising\n\nprint(\"EMA Rising:\" rising(my_ema, \"EMA_3\", length=8)) # False\n</code></pre>"},{"location":"guides/quick-start/#hexital-indicator-grouping","title":"Hexital - Indicator Grouping","text":"<p>A single indicator is useful but no trading strategy is built using a single one, to avoid haivng to create and manage and appending to several indicators. Therefore Hexital library has the Hexital object, which is designed for managing multiple indicators easily, by having one set of candle's which is used for multiple indicator's they will all automatically be given new Candle and re-calculated; as if managing one Indicator.</p> <p>This example is using Hexital to manage WMA and EMA in one Hexital object, updating and calculating both indicators from appending a single Candle.</p> <pre><code>from hexital import EMA, WMA, Candle, Hexital\n\nmy_candles = [\n    {\"open\": 17213, \"high\": 2395, \"low\": 7813, \"close\": 3615, \"volume\": 19661},\n    {\"open\": 1301, \"high\": 3007, \"low\": 11626, \"close\": 19048, \"volume\": 28909},\n    {\"open\": 12615, \"high\": 923, \"low\": 7318, \"close\": 1351, \"volume\": 33765},\n    {\"open\": 1643, \"high\": 16229, \"low\": 17721, \"close\": 212, \"volume\": 3281},\n    {\"open\": 424, \"high\": 10614, \"low\": 17133, \"close\": 7308, \"volume\": 41793},\n    {\"open\": 4323, \"high\": 5858, \"low\": 8785, \"close\": 8418, \"volume\": 34913},\n    {\"open\": 13838, \"high\": 13533, \"low\": 4830, \"close\": 17765, \"volume\": 586},\n    {\"open\": 14373, \"high\": 18026, \"low\": 7844, \"close\": 18798, \"volume\": 25993},\n    {\"open\": 12382, \"high\": 19875, \"low\": 2853, \"close\": 1431, \"volume\": 10055},\n    {\"open\": 19202, \"high\": 6584, \"low\": 6349, \"close\": 8299, \"volume\": 13199},\n]\ncandles = Candle.from_dicts(my_candles)\n\nstrategy = Hexital(\"Demo Strat\", candles,\n    candle_life=timedelta(hours=2)\n    [\n        WMA(name=\"WMA\", period=8),\n        EMA(period=3, candle_life=timedelta(hours=1)),\n    ]\n)\nstrategy.calculate()\n\nprint(\"EMA reading:\", strategy.reading(\"EMA_3\")) # 8408.7552\nprint(\"WMA reading:\", strategy.reading(\"WMA\")) # 9316.4722\n</code></pre> <p>All the configuration that is available to the <code>EMA</code> indicator is still available while being used within the Hexital object.</p> <p>EMA naming</p> <p>EMA was not given a specific name, the name is therefore generated based of the Indicator name(EMA) and Period(3). Which us why in <code>strategy</code> it's called as <code>EMA_3</code>. This changes if the period changes.</p>"},{"location":"guides/quick-start/#appending-new-candle_1","title":"Appending new Candle","text":"<p>We can append a <code>Candle</code> to Hexital which is then used for all Indicator's, the EMA and WMA value's are again automatically calculated on append.</p> <pre><code># Append new Candle\nstrategy.append(\n    Candle.from_dict({\"open\": 19723, \"high\": 4837, \"low\": 11631, \"close\": 6231, \"volume\": 38993})\n)\n# New readings from both indicators using new Candle\nprint(\"EMA reading:\", strategy.reading(\"EMA_3\"))  # 7319.8776\nprint(\"WMA reading:\", strategy.reading(\"WMA\"))  # 8934.9722\n</code></pre> <p>Auto calculation</p> <p>We dont need to call calculation method as it's done automatically on append.</p>"},{"location":"guides/quick-start/#hexitals-own-configuration-candle_life","title":"Hexital's own configuration (candle_life)","text":"<p>Notice that the Hexital object has it's own <code>candle_life</code> attribute. The purpose of this is a global way to set configurations within the Hexital Indicators. Therefore all indicators that exist within this strategy object will inherit a <code>candle_life</code> value of 2 hours. However the EMA TA has it's own <code>candle_life</code> attribute which will take precedence over the Hexital's.</p> <p>The purpose is you can set a global configuration for all indicators without having to add it to each TA manually.</p> <pre><code>strategy = Hexital(\"Demo Strat\", candles,\n    candle_life=timedelta(hours=2)\n    [\n        WMA(name=\"WMA\", period=8),\n        EMA(period=3, candle_life=timedelta(hours=1)),\n    ]\n)\n</code></pre>"},{"location":"guides/quick-start/#analysis-for-ema-and-wma-crossing","title":"Analysis for EMA and WMA Crossing","text":"<p>You can also pass the Hexital object into one of Hexital's built in analysis functions, for example to check if the EMA value we are generating has crossed over the WMA.</p> <pre><code>from hexital.analysis import cross\n\nprint(\"EMA Crossed WMA:\" cross(strategy, \"EMA_3\", \"WMA\")) # False\n</code></pre> <p>EMA Name</p> <p>The EMA_3 name is the generated name, if you decide to alter to period of this EMA to say 6; the name would change to match resulting in these call's failing. This is why it's best practice to manually choose a name when creating a indicator.</p> <p>Analysis methods</p> <p>We can replace <code>cross</code> with <code>crossover</code> or <code>crossunder</code> for specific direction.</p>"},{"location":"reference/","title":"Reference","text":"<p>Here's the reference or code API, the classes, functions, parameters, attributes, and all the FastAPI parts you can use in your applications.</p> <p>If you want to learn Hexital you are much better off reading the Quick Start Guide.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li> hexital<ul> <li> analysis<ul> <li> movement</li> <li> patterns</li> <li> utils</li> </ul> </li> <li> candlesticks<ul> <li> heikinashi</li> </ul> </li> <li> core<ul> <li> candle</li> <li> candle_manager</li> <li> candlestick_type</li> <li> hexital</li> <li> indicator</li> <li> indicator_collection</li> </ul> </li> <li> exceptions</li> <li> indicators<ul> <li> adx</li> <li> amorph</li> <li> aroon</li> <li> atr</li> <li> bbands</li> <li> cmo</li> <li> counter</li> <li> donchian</li> <li> ema</li> <li> highest_lowest</li> <li> hla</li> <li> hlca</li> <li> hma</li> <li> jma</li> <li> kc</li> <li> macd</li> <li> mfi</li> <li> midpoint</li> <li> obv</li> <li> pivot_points</li> <li> rma</li> <li> roc</li> <li> rsi</li> <li> rvi</li> <li> sma</li> <li> stdev</li> <li> stdevthres</li> <li> stoch</li> <li> supertrend</li> <li> tr</li> <li> tsi</li> <li> vwap</li> <li> vwma</li> <li> wma</li> </ul> </li> <li> utils<ul> <li> candles</li> <li> candlesticks</li> <li> common</li> <li> indexing</li> <li> timeframe</li> <li> weakreflist</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/hexital/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> hexital","text":""},{"location":"reference/hexital/#hexital","title":"hexital","text":"<p>Modules:</p> Name Description <code>analysis</code> <code>candlesticks</code> <code>core</code> <code>indicators</code> <code>utils</code> <p>Classes:</p> Name Description <code>ADX</code> <p>Average Directional Index - ADX</p> <code>AROON</code> <p>Aroon - AROON</p> <code>ATR</code> <p>Average True Range - ATR</p> <code>Amorph</code> <p>Amorph</p> <code>BBANDS</code> <p>Bollinger Bands - BBANDS</p> <code>CMO</code> <p>Chande Momentum Oscillator - CMO</p> <code>Counter</code> <p>Counter</p> <code>Donchian</code> <p>Donchian Channels - Donchian</p> <code>EMA</code> <p>Exponential Moving Average - EMA</p> <code>HL</code> <p>Highest Lowest - HL</p> <code>HLA</code> <p>High Low Average - HLA</p> <code>HLCA</code> <p>High Low Close Average - HLCA</p> <code>HMA</code> <p>Hull Moving Average - HMA</p> <code>JMA</code> <p>Jurik Moving Average Average - JMA</p> <code>KC</code> <p>Keltner Channel - KC</p> <code>MACD</code> <p>Moving Average Convergence Divergence - MACD</p> <code>MFI</code> <p>Money Flow Index - MFI</p> <code>MOP</code> <p>Midpoint Over Period - MOP</p> <code>OBV</code> <p>On-Balance Volume - OBC</p> <code>PivotPoints</code> <p>Pivot Points - PP</p> <code>RMA</code> <p>wildeR's Moving Average - RMA</p> <code>ROC</code> <p>Rate Of Change - ROC</p> <code>RSI</code> <p>Relative Strength Index - RSI</p> <code>RVI</code> <p>Relative Vigor Index - RVI</p> <code>SMA</code> <p>Simple Moving Average - SMA</p> <code>STDEV</code> <p>Rolling Standard Deviation - STDEV</p> <code>STDEVT</code> <p>Standard Deviation Threshold - STDEVT</p> <code>STOCH</code> <p>Stochastic - STOCH</p> <code>Supertrend</code> <p>Supertrend</p> <code>TR</code> <p>True Range - TR</p> <code>TSI</code> <p>True Strength Index - TSI</p> <code>VWAP</code> <p>Volume-Weighted Average Price - VWAP</p> <code>VWMA</code> <p>Volume Weighted Moving Average - VWMA</p> <code>WMA</code> <p>Weighted Moving Average - WMA</p>"},{"location":"reference/hexital/#hexital.ADX","title":"ADX  <code>dataclass</code>","text":"<pre><code>ADX(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    period: int = 14,\n    period_signal: Optional[int] = None,\n    multiplier: float = 100.0\n)\n</code></pre> <p>               Bases: <code>Indicator[dict]</code></p> <p>Average Directional Index - ADX</p> <p>ADX is a trend strength in a series of prices of a financial instrument.</p> Sources <p>https://en.wikipedia.org/wiki/Average_directional_movement_index</p> <p>Output type: <code>Dict[\"ADX\": float, \"DM_Plus\": float, \"DM_Neg\": float]</code></p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>How many Periods to use. Defaults to 14</p> <code>14</code> <code>period_signal</code> <code>Optional[int]</code> <p>Average Directional Index period. Defaults same as period</p> <code>None</code> <code>multiplier</code> <code>Optional[float]</code> <p>ADX smoothing multiplier. Defaults to 100.0</p> <code>100.0</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/#hexital.ADX.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/#hexital.ADX.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/#hexital.ADX.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/#hexital.ADX.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/#hexital.ADX.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.ADX.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.ADX.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.ADX.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/#hexital.ADX.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.ADX.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.ADX.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/#hexital.ADX.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.ADX.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.ADX.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/#hexital.ADX.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.AROON","title":"AROON  <code>dataclass</code>","text":"<pre><code>AROON(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    period: int = 14\n)\n</code></pre> <p>               Bases: <code>Indicator[dict]</code></p> <p>Aroon - AROON</p> <p>The Aroon indicator, indicates if a price is trending or is in a trading range. It can also reveal the beginning of a new trend, its strength and can help anticipate changes from trading ranges to trends.</p> Sources <p>https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/aroon-indicator</p> <p>Output type: <code>Dict[\"AROONU\": float, \"AROOND\": float, \"AROONOSC\": float]</code></p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>How many Periods to use. Defaults to 14</p> <code>14</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/#hexital.AROON.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/#hexital.AROON.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/#hexital.AROON.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/#hexital.AROON.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/#hexital.AROON.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.AROON.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.AROON.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.AROON.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/#hexital.AROON.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.AROON.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.AROON.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/#hexital.AROON.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.AROON.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.AROON.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/#hexital.AROON.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.ATR","title":"ATR  <code>dataclass</code>","text":"<pre><code>ATR(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    period: int = 14\n)\n</code></pre> <p>               Bases: <code>Indicator[float | None]</code></p> <p>Average True Range - ATR</p> <p>Average True Range is used to measure volatility, especially volatility caused by gaps or limit moves.</p> Sources <p>https://www.tradingview.com/wiki/Average_True_Range_(ATR)</p> <p>Output type: <code>float</code></p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>How many Periods to use. Defaults to 14</p> <code>14</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/#hexital.ATR.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/#hexital.ATR.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/#hexital.ATR.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/#hexital.ATR.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/#hexital.ATR.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.ATR.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.ATR.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.ATR.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/#hexital.ATR.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.ATR.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.ATR.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/#hexital.ATR.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.ATR.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.ATR.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/#hexital.ATR.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.Amorph","title":"Amorph","text":"<pre><code>Amorph(analysis: Callable, args: Optional[dict] = None, **kwargs)\n</code></pre> <p>               Bases: <code>Indicator</code></p> <p>Amorph</p> <p>Flexible Skeleton Indicator that will use a method to generate readings on every Candle like indicators.</p> <p>The given Method is expected to have 'candles' and 'index' as named arguments, EG:</p> <p>Input type Example: Doji</p> <p>Output type: Based on analysis method</p> <p>Parameters:</p> Name Type Description Default <code>analysis</code> <code>Callable</code> <p>Period to index back in</p> required <code>args</code> <code>Optional[dict]</code> <p>All of the Arguments as keyword arguments as a dict of keyword arguments for called analysis</p> <code>None</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Returns a dict format of how this indicator can be generated</p> Source code in <code>hexital/indicators/amorph.py</code> <pre><code>def __init__(self, analysis: Callable, args: Optional[dict] = None, **kwargs):\n    self._analysis_method = analysis\n    self.analysis_name = analysis.__name__\n    self._analysis_kwargs, kwargs = self._separate_indicator_attributes(kwargs)\n\n    if isinstance(args, dict):\n        self._analysis_kwargs.update(args)\n\n    super().__init__(**kwargs)\n</code></pre>"},{"location":"reference/hexital/#hexital.Amorph.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/#hexital.Amorph.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Returns a dict format of how this indicator can be generated</p>"},{"location":"reference/hexital/#hexital.Amorph.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/#hexital.Amorph.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/#hexital.Amorph.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.Amorph.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.Amorph.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.Amorph.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/#hexital.Amorph.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.Amorph.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.Amorph.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/#hexital.Amorph.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.Amorph.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.Amorph.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/#hexital.Amorph.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.BBANDS","title":"BBANDS  <code>dataclass</code>","text":"<pre><code>BBANDS(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    period: int = 5,\n    source: Source = \"close\"\n)\n</code></pre> <p>               Bases: <code>Indicator[dict]</code></p> <p>Bollinger Bands - BBANDS</p> <p>Bollinger Bands are a type of statistical chart characterizing the prices and volatility over time of a financial instrument or commodity, using a formulaic method.</p> Sources <p>https://www.britannica.com/money/bollinger-bands-indicator</p> <p>Output type: <code>Dict[\"BBL\": float, \"BBM\": float, \"BBU\": float]</code></p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>How many Periods to use. Defaults to 5</p> <code>5</code> <code>source</code> <code>str</code> <p>Which input field to calculate the Indicator. Defaults to \"close\"</p> <code>'close'</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/#hexital.BBANDS.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/#hexital.BBANDS.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/#hexital.BBANDS.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/#hexital.BBANDS.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/#hexital.BBANDS.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.BBANDS.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.BBANDS.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.BBANDS.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/#hexital.BBANDS.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.BBANDS.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.BBANDS.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/#hexital.BBANDS.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.BBANDS.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.BBANDS.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/#hexital.BBANDS.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.CMO","title":"CMO  <code>dataclass</code>","text":"<pre><code>CMO(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    period: int = 14,\n    source: Source = \"close\"\n)\n</code></pre> <p>               Bases: <code>Indicator[float | None]</code></p> <p>Chande Momentum Oscillator - CMO</p> <p>The CMO indicator is created by calculating the difference between the sum of all recent higher closes and the sum of all recent lower closes and then dividing the result by the sum of all price movement over a given time period. The result is multiplied by 100 to give the -100 to +100 range.</p> Sources <p>https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/cmo</p> <p>Output type: <code>float</code></p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>How many Periods to use. Defaults to 14</p> <code>14</code> <code>source</code> <code>str</code> <p>Which input field to calculate the Indicator. Defaults to \"close\"</p> <code>'close'</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/#hexital.CMO.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/#hexital.CMO.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/#hexital.CMO.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/#hexital.CMO.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/#hexital.CMO.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.CMO.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.CMO.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.CMO.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/#hexital.CMO.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.CMO.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.CMO.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/#hexital.CMO.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.CMO.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.CMO.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/#hexital.CMO.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.Counter","title":"Counter  <code>dataclass</code>","text":"<pre><code>Counter(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    source: Source,\n    count_value: Any = True\n)\n</code></pre> <p>               Bases: <code>Indicator[int]</code></p> <p>Counter</p> <p>Simple Indictor which will count the current streak of a given value, specifically designed for bool values, but useable on any other re-occurring values. E.G Count the streak for current input value == count_value</p> <p>Output type: <code>float</code></p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Which input field to calculate the Indicator.</p> required <code>count_value</code> <code>bool | int</code> <p>Which value to be counting, E.G <code>bool</code>, <code>1</code>, etc</p> <code>True</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/#hexital.Counter.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/#hexital.Counter.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/#hexital.Counter.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/#hexital.Counter.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/#hexital.Counter.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.Counter.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.Counter.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.Counter.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/#hexital.Counter.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.Counter.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.Counter.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/#hexital.Counter.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.Counter.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.Counter.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/#hexital.Counter.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.Donchian","title":"Donchian  <code>dataclass</code>","text":"<pre><code>Donchian(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    period: int = 20\n)\n</code></pre> <p>               Bases: <code>Indicator[dict]</code></p> <p>Donchian Channels - Donchian</p> <p>Donchian Channels are a technical indicator that seeks to identify bullish and bearish extremes that favor reversals, higher and lower breakouts, breakdowns, and other emerging trends.</p> Sources <p>https://upstox.com/learning-center/share-market/a-comprehensive-guide-to-donchian-channels-formula-calculation-and-strategic-uses/ https://en.wikipedia.org/wiki/Donchian_channel</p> <p>Output type: <code>Dict[\"DCL\": float, \"DCM\": float, \"DCU\": float]</code></p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>How many Periods to use. Defaults to 20</p> <code>20</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/#hexital.Donchian.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/#hexital.Donchian.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/#hexital.Donchian.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/#hexital.Donchian.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/#hexital.Donchian.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.Donchian.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.Donchian.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.Donchian.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/#hexital.Donchian.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.Donchian.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.Donchian.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/#hexital.Donchian.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.Donchian.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.Donchian.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/#hexital.Donchian.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.EMA","title":"EMA  <code>dataclass</code>","text":"<pre><code>EMA(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    period: int = 10,\n    source: Source = \"close\",\n    smoothing: float = 2.0\n)\n</code></pre> <p>               Bases: <code>Indicator[float | None]</code></p> <p>Exponential Moving Average - EMA</p> <p>The Exponential Moving Average is more responsive moving average compared to the Simple Moving Average (SMA).  The weights are determined by alpha which is proportional to it's length.</p> Sources <p>https://www.investopedia.com/ask/answers/122314/what-exponential-moving-average-ema-formula-and-how-ema-calculated.asp</p> <p>Output type: <code>float</code></p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>How many Periods to use. Defaults to 10</p> <code>10</code> <code>source</code> <code>str</code> <p>Which input field to calculate the Indicator. Defaults to \"close\"</p> <code>'close'</code> <code>smoothing</code> <code>float</code> <p>Smoothing multiplier for EMA. Defaults to 2.0</p> <code>2.0</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/#hexital.EMA.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/#hexital.EMA.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/#hexital.EMA.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/#hexital.EMA.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/#hexital.EMA.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.EMA.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.EMA.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.EMA.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/#hexital.EMA.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.EMA.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.EMA.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/#hexital.EMA.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.EMA.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.EMA.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/#hexital.EMA.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.HL","title":"HL  <code>dataclass</code>","text":"<pre><code>HL(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    period: int = 100\n)\n</code></pre> <p>               Bases: <code>Indicator[dict]</code></p> <p>Highest Lowest - HL</p> <p>Simple utility indicator to record and display the highest and lowest values N periods back.</p> <p>Output type: <code>Dict[\"low\": float, \"high\": float]</code></p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>How many Periods to use. Defaults to 100</p> <code>100</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/#hexital.HL.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/#hexital.HL.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/#hexital.HL.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/#hexital.HL.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/#hexital.HL.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.HL.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.HL.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.HL.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/#hexital.HL.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.HL.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.HL.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/#hexital.HL.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.HL.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.HL.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/#hexital.HL.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.HLA","title":"HLA  <code>dataclass</code>","text":"<pre><code>HLA(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4\n)\n</code></pre> <p>               Bases: <code>Indicator[float]</code></p> <p>High Low Average - HLA</p> <p>Output type: <code>float</code></p> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/#hexital.HLA.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/#hexital.HLA.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/#hexital.HLA.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/#hexital.HLA.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/#hexital.HLA.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.HLA.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.HLA.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.HLA.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/#hexital.HLA.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.HLA.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.HLA.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/#hexital.HLA.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.HLA.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.HLA.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/#hexital.HLA.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.HLCA","title":"HLCA  <code>dataclass</code>","text":"<pre><code>HLCA(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4\n)\n</code></pre> <p>               Bases: <code>Indicator[float]</code></p> <p>High Low Close Average - HLCA</p> <p>Output type: <code>float</code></p> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/#hexital.HLCA.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/#hexital.HLCA.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/#hexital.HLCA.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/#hexital.HLCA.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/#hexital.HLCA.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.HLCA.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.HLCA.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.HLCA.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/#hexital.HLCA.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.HLCA.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.HLCA.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/#hexital.HLCA.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.HLCA.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.HLCA.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/#hexital.HLCA.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.HMA","title":"HMA  <code>dataclass</code>","text":"<pre><code>HMA(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    period: int = 10,\n    source: Source = \"close\"\n)\n</code></pre> <p>               Bases: <code>Indicator[float | None]</code></p> <p>Hull Moving Average - HMA</p> <p>It is a combination of weighted moving averages designed to be more responsive to current price fluctuations while still smoothing prices.</p> Sources <p>https://school.stockcharts.com/doku.php?id=technical_indicators:hull_moving_average</p> <p>Output type: <code>float</code></p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>How many Periods to use. Defaults to 10</p> <code>10</code> <code>source</code> <code>str</code> <p>Which input field to calculate the Indicator. Defaults to \"close\"</p> <code>'close'</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/#hexital.HMA.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/#hexital.HMA.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/#hexital.HMA.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/#hexital.HMA.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/#hexital.HMA.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.HMA.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.HMA.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.HMA.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/#hexital.HMA.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.HMA.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.HMA.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/#hexital.HMA.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.HMA.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.HMA.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/#hexital.HMA.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.JMA","title":"JMA  <code>dataclass</code>","text":"<pre><code>JMA(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    period: int = 7,\n    source: Source = \"close\",\n    phase: float = 0.0\n)\n</code></pre> <p>               Bases: <code>Indicator[float | None]</code></p> <p>Jurik Moving Average Average - JMA</p> <p>The JMA is an adaptive moving average that aims to reduce lag and improve responsiveness to price changes compared to traditional moving averages. By incorporating volatility and phase shift components, the JMA seeks to provide traders with a more accurate and timely representation of market trends.</p> Sources <p>https://c.mql5.com/forextsd/forum/164/jurik_1.pdf</p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>How many Periods to use. Defaults to 7</p> <code>7</code> <code>source</code> <code>str</code> <p>Which input field to calculate the Indicator. Defaults to \"close\"</p> <code>'close'</code> <code>phase</code> <code>float</code> <p>How heavy/light the average is [-100, 100]. Defaults to 0.0</p> <code>0.0</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/#hexital.JMA.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/#hexital.JMA.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/#hexital.JMA.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/#hexital.JMA.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/#hexital.JMA.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.JMA.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.JMA.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.JMA.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/#hexital.JMA.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.JMA.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.JMA.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/#hexital.JMA.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.JMA.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.JMA.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/#hexital.JMA.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.KC","title":"KC  <code>dataclass</code>","text":"<pre><code>KC(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    period: int = 20,\n    source: Source = \"close\",\n    multiplier: float = 2.0\n)\n</code></pre> <p>               Bases: <code>Indicator[dict]</code></p> <p>Keltner Channel - KC</p> <p>Keltner channel is a technical analysis indicator showing a central moving average line plus channel lines at a distance above and below. A popular volatility indicator similar to Bollinger Bands and Donchian Channels.</p> Sources <p>https://www.investopedia.com/terms/k/keltnerchannel.asp</p> <p>Output type: <code>Dict[\"lower\": float, \"band\": float, \"upper\": float]</code></p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>How many Periods to use. Defaults to 20</p> <code>20</code> <code>source</code> <code>str</code> <p>Which input field to calculate the Indicator. Defaults to \"close\"</p> <code>'close'</code> <code>multiplier</code> <code>float</code> <p>A positive float to multiply the bands. Defaults to 2.0</p> <code>2.0</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/#hexital.KC.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/#hexital.KC.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/#hexital.KC.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/#hexital.KC.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/#hexital.KC.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.KC.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.KC.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.KC.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/#hexital.KC.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.KC.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.KC.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/#hexital.KC.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.KC.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.KC.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/#hexital.KC.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.MACD","title":"MACD  <code>dataclass</code>","text":"<pre><code>MACD(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    source: Source = \"close\",\n    fast_period: int = 12,\n    slow_period: int = 26,\n    signal_period: int = 9\n)\n</code></pre> <p>               Bases: <code>Indicator[dict]</code></p> <p>Moving Average Convergence Divergence - MACD</p> <p>The MACD is a popular indicator to that is used to identify a security's trend. While APO and MACD are the same calculation, MACD also returns two more series called Signal and Histogram. The Signal is an EMA of MACD and the Histogram is the difference of MACD and Signal.</p> Sources <p>https://www.investopedia.com/ask/answers/122314/what-exponential-moving-average-ema-formula-and-how-ema-calculated.asp</p> <p>Output type: <code>Dict[\"MACD\": float, \"signal\": float, \"histogram\": float]</code></p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Which input field to calculate the Indicator. Defaults to \"close\"</p> <code>'close'</code> <code>fast_period</code> <code>int</code> <p>How many Periods to use for fast EMA. Defaults to 12</p> <code>12</code> <code>slow_period</code> <code>int</code> <p>How many Periods to use for slow EMA. Defaults to 26</p> <code>26</code> <code>signal_period</code> <code>int</code> <p>How many Periods to use for MACD signal. Defaults to 9</p> <code>9</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/#hexital.MACD.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/#hexital.MACD.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/#hexital.MACD.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/#hexital.MACD.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/#hexital.MACD.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.MACD.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.MACD.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.MACD.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/#hexital.MACD.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.MACD.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.MACD.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/#hexital.MACD.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.MACD.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.MACD.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/#hexital.MACD.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.MFI","title":"MFI  <code>dataclass</code>","text":"<pre><code>MFI(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    period: int = 14,\n    source: Source = \"close\"\n)\n</code></pre> <p>               Bases: <code>Indicator[float | None]</code></p> <p>Money Flow Index - MFI</p> <p>The money flow index (MFI) is an oscillator that ranges from 0 to 100. It is used to show the money flow over several days.</p> Sources <p>https://www.tradingview.com/wiki/Money_Flow_(MFI)</p> <p>Output type: <code>float</code></p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>How many Periods to use. Defaults to 14</p> <code>14</code> <code>source</code> <code>str</code> <p>Which input field to calculate the Indicator. Defaults to \"close\"</p> <code>'close'</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/#hexital.MFI.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/#hexital.MFI.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/#hexital.MFI.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/#hexital.MFI.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/#hexital.MFI.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.MFI.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.MFI.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.MFI.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/#hexital.MFI.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.MFI.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.MFI.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/#hexital.MFI.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.MFI.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.MFI.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/#hexital.MFI.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.MOP","title":"MOP  <code>dataclass</code>","text":"<pre><code>MOP(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    period: int = 2,\n    source: Source = \"close\"\n)\n</code></pre> <p>               Bases: <code>Indicator[float | None]</code></p> <p>Midpoint Over Period - MOP</p> <p>A technical analysis tool that evaluates the average price movement by calculating the midpoint between the highest and lowest points over a specified period. This indicator aims to provide a smoother representation of price action, avoiding the choppiness of extreme highs and lows.</p> Sources <p>https://trendspider.com/learning-center/understanding-and-applying-the-midpoint-over-period-indicator-in-trading/</p> <p>Output type: <code>float</code></p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>How many Periods to use. Defaults to 2</p> <code>2</code> <code>source</code> <code>str</code> <p>Which input field to calculate the Indicator. Defaults to \"close\"</p> <code>'close'</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/#hexital.MOP.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/#hexital.MOP.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/#hexital.MOP.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/#hexital.MOP.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/#hexital.MOP.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.MOP.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.MOP.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.MOP.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/#hexital.MOP.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.MOP.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.MOP.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/#hexital.MOP.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.MOP.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.MOP.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/#hexital.MOP.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.OBV","title":"OBV  <code>dataclass</code>","text":"<pre><code>OBV(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4\n)\n</code></pre> <p>               Bases: <code>Indicator[float]</code></p> <p>On-Balance Volume - OBC</p> <p>On-balance volume (OBV) is a technical analysis indicator intended to relate price and volume in the stock market. OBV is based on a cumulative total volume.</p> Sources <p>https://en.wikipedia.org/wiki/On-balance_volume</p> <p>Output type: <code>float</code></p> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/#hexital.OBV.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/#hexital.OBV.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/#hexital.OBV.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/#hexital.OBV.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/#hexital.OBV.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.OBV.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.OBV.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.OBV.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/#hexital.OBV.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.OBV.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.OBV.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/#hexital.OBV.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.OBV.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.OBV.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/#hexital.OBV.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.PivotPoints","title":"PivotPoints  <code>dataclass</code>","text":"<pre><code>PivotPoints(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4\n)\n</code></pre> <p>               Bases: <code>Indicator[dict]</code></p> <p>Pivot Points - PP</p> <p>Pivot point is a price level that is used by traders as a possible indicator of market movement. A pivot point is calculated as an average of significant prices (high, low, close) from the performance of a market in the prior trading period. If the market in the following period trades above the pivot point it is 1usually evaluated as a bullish sentiment, whereas trading below the pivot point is seen as bearish.</p> Sources <p>https://en.wikipedia.org/wiki/Pivot_point_(technical_analysis)</p> <p>Output type: <code>Dict[\"S1\": float, \"R1\": float, \"S2\": float, \"R2\": float]</code></p> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/#hexital.PivotPoints.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/#hexital.PivotPoints.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/#hexital.PivotPoints.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/#hexital.PivotPoints.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/#hexital.PivotPoints.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.PivotPoints.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.PivotPoints.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.PivotPoints.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/#hexital.PivotPoints.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.PivotPoints.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.PivotPoints.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/#hexital.PivotPoints.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.PivotPoints.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.PivotPoints.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/#hexital.PivotPoints.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.RMA","title":"RMA  <code>dataclass</code>","text":"<pre><code>RMA(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    period: int = 10,\n    source: Source = \"close\"\n)\n</code></pre> <p>               Bases: <code>Indicator[float | None]</code></p> <p>wildeR's Moving Average - RMA</p> <p>Wilder's Moving Average places more emphasis on recent price movements than other moving averages. This makes it a more responsive tool for short-term traders who need to adapt quickly to changing market conditions.</p> Sources <p>https://tlc.thinkorswim.com/center/reference/Tech-Indicators/studies-library/V-Z/WildersSmoothing https://www.incrediblecharts.com/indicators/wilder_moving_average.php</p> <p>Output type: <code>float</code></p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>How many Periods to use. Defaults to 10</p> <code>10</code> <code>source</code> <code>str</code> <p>Which input field to calculate the Indicator. Defaults to \"close\"</p> <code>'close'</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/#hexital.RMA.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/#hexital.RMA.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/#hexital.RMA.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/#hexital.RMA.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/#hexital.RMA.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.RMA.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.RMA.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.RMA.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/#hexital.RMA.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.RMA.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.RMA.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/#hexital.RMA.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.RMA.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.RMA.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/#hexital.RMA.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.ROC","title":"ROC  <code>dataclass</code>","text":"<pre><code>ROC(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    period: int = 10,\n    source: Source = \"close\"\n)\n</code></pre> <p>               Bases: <code>Indicator[float | None]</code></p> <p>Rate Of Change - ROC</p> <p>The Price Rate of Change (ROC) indicator in trading refers to the percentage change between the current price and the price of a set number of periods ago. It is used to identify the momentum of price movement and help traders make informed decisions regarding buying or selling assets. This indicator is calculated by dividing the difference between the current price and the price of a set number of periods ago by the previous price and multiplying by 100.</p> Sources <p>https://en.wikipedia.org/wiki/Momentum_(technical_analysis)</p> <p>Output type: <code>float</code></p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>How many Periods to use. Defaults to 10</p> <code>10</code> <code>source</code> <code>str</code> <p>Which input field to calculate the Indicator. Defaults to \"close\"</p> <code>'close'</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/#hexital.ROC.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/#hexital.ROC.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/#hexital.ROC.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/#hexital.ROC.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/#hexital.ROC.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.ROC.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.ROC.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.ROC.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/#hexital.ROC.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.ROC.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.ROC.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/#hexital.ROC.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.ROC.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.ROC.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/#hexital.ROC.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.RSI","title":"RSI  <code>dataclass</code>","text":"<pre><code>RSI(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    period: int = 14,\n    source: Source = \"close\"\n)\n</code></pre> <p>               Bases: <code>Indicator[float | None]</code></p> <p>Relative Strength Index - RSI</p> <p>The Relative Strength Index is popular momentum oscillator used to measure the velocity as well as the magnitude of directional price movements.</p> Sources <p>https://www.tradingview.com/support/solutions/43000502338-relative-strength-index-rsi/</p> <p>Output type: <code>float</code></p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>How many Periods to use. Defaults to 14</p> <code>14</code> <code>source</code> <code>str</code> <p>Which input field to calculate the Indicator. Defaults to \"close\"</p> <code>'close'</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/#hexital.RSI.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/#hexital.RSI.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/#hexital.RSI.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/#hexital.RSI.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/#hexital.RSI.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.RSI.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.RSI.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.RSI.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/#hexital.RSI.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.RSI.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.RSI.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/#hexital.RSI.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.RSI.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.RSI.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/#hexital.RSI.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.RVI","title":"RVI  <code>dataclass</code>","text":"<pre><code>RVI(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    period: int = 14,\n    source: Source = \"close\"\n)\n</code></pre> <p>               Bases: <code>Indicator[float | None]</code></p> <p>Relative Vigor Index - RVI</p> <p>The Relative Vigor Index, or RVI, is a popular member of the \u201cOscillator\u201d family of technical indicators. although the creator of the Relative Vigor Index is unknown, its design is very similar to Stochastics except that the closing price is compared with the Open rather than the Low price for the period.</p> Sources <p>https://www.thinkmarkets.com/en/learn-to-trade/indicators-and-patterns/indicators/relative-vigor-index-rvi-indicator/</p> <p>Output type: <code>float</code></p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>How many Periods to use. Defaults to 14</p> <code>14</code> <code>source</code> <code>str</code> <p>Which input field to calculate the Indicator. Defaults to \"close\"</p> <code>'close'</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/#hexital.RVI.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/#hexital.RVI.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/#hexital.RVI.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/#hexital.RVI.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/#hexital.RVI.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.RVI.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.RVI.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.RVI.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/#hexital.RVI.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.RVI.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.RVI.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/#hexital.RVI.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.RVI.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.RVI.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/#hexital.RVI.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.SMA","title":"SMA  <code>dataclass</code>","text":"<pre><code>SMA(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    period: int = 10,\n    source: Source = \"close\"\n)\n</code></pre> <p>               Bases: <code>Indicator[float | None]</code></p> <p>Simple Moving Average - SMA</p> <p>The Simple Moving Average is the classic moving average that is the equally weighted average over n periods.</p> Sources <p>https://www.investopedia.com/terms/s/sma.asp</p> <p>Output type: <code>float</code></p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>How many Periods to use. Defaults to 10</p> <code>10</code> <code>source</code> <code>str</code> <p>Which input field to calculate the Indicator. Defaults to \"close\"</p> <code>'close'</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/#hexital.SMA.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/#hexital.SMA.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/#hexital.SMA.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/#hexital.SMA.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/#hexital.SMA.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.SMA.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.SMA.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.SMA.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/#hexital.SMA.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.SMA.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.SMA.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/#hexital.SMA.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.SMA.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.SMA.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/#hexital.SMA.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.STDEV","title":"STDEV  <code>dataclass</code>","text":"<pre><code>STDEV(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    period: int = 30,\n    source: Source = \"close\"\n)\n</code></pre> <p>               Bases: <code>Indicator[float | None]</code></p> <p>Rolling Standard Deviation - STDEV</p> <p>You use a rolling stdev when you expect the standard deviation to change over time. As long as the standard deviation is changing slowly enough, we should be able to see the change in the standard deviation over time if we use the right size window.</p> Sources <p>https://jonisalonen.com/2014/efficient-and-accurate-rolling-standard-deviation/</p> <p>Output type: <code>float</code></p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>How many Periods to use. Defaults to 30</p> <code>30</code> <code>source</code> <code>str</code> <p>Which input field to calculate the Indicator. Defaults to \"close\"</p> <code>'close'</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/#hexital.STDEV.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/#hexital.STDEV.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/#hexital.STDEV.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/#hexital.STDEV.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/#hexital.STDEV.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.STDEV.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.STDEV.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.STDEV.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/#hexital.STDEV.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.STDEV.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.STDEV.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/#hexital.STDEV.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.STDEV.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.STDEV.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/#hexital.STDEV.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.STDEVT","title":"STDEVT  <code>dataclass</code>","text":"<pre><code>STDEVT(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    period: int = 10,\n    source: Source = \"close\",\n    multiplier: float = 2.0\n)\n</code></pre> <p>               Bases: <code>Indicator[float | None]</code></p> <p>Standard Deviation Threshold - STDEVT</p> <p>Standard Deviation while calculating threshold returning boolean signal if change to input is higher than threshold</p> Sources <p>ChatGPT</p> <p>Output type: <code>float</code></p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>How many Periods to use. Defaults to 10</p> <code>10</code> <code>source</code> <code>str</code> <p>Which input field to calculate the Indicator. Defaults to \"close\"</p> <code>'close'</code> <code>multiplier</code> <code>float</code> <p>A positive float to multiply the Deviation. Defaults to 2.0</p> <code>2.0</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/#hexital.STDEVT.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/#hexital.STDEVT.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/#hexital.STDEVT.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/#hexital.STDEVT.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/#hexital.STDEVT.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.STDEVT.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.STDEVT.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.STDEVT.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/#hexital.STDEVT.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.STDEVT.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.STDEVT.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/#hexital.STDEVT.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.STDEVT.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.STDEVT.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/#hexital.STDEVT.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.STOCH","title":"STOCH  <code>dataclass</code>","text":"<pre><code>STOCH(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    period: int = 14,\n    slow_period: int = 3,\n    smoothing_k: int = 3,\n    source: Source = \"close\"\n)\n</code></pre> <p>               Bases: <code>Indicator[dict]</code></p> <p>Stochastic - STOCH</p> <p>The Stochastic Oscillator (STOCH) was developed by George Lane in the 1950's. He believed this indicator was a good way to measure momentum because changes in momentum precede changes in price.</p> <p>It is a range-bound oscillator with two lines moving between 0 and 100. The first line (%K) displays the current close in relation to the period's high/low range. The second line (%D) is a Simple Moving Average of the %K line. The most common choices are a 14 period %K and a 3 period SMA for %D.</p> <p>%K = SMA(100 * (Current Close - Lowest Low) / (Highest High - Lowest Low), smoothK) %D = SMA(%K, periodD)</p> Sources <p>https://www.tradingview.com/wiki/Stochastic_(STOCH)</p> <p>Output type: <code>Dict[\"stoch\": float, \"k\": float, \"d\": float]</code></p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>How many Periods to use. Defaults to 14</p> <code>14</code> <code>slow_period</code> <code>int</code> <p>How many Periods to use on smoothing d. Defaults to 3</p> <code>3</code> <code>smoothing_k</code> <code>int</code> <p>How many Periods to use on smoothing K. Defaults to 3</p> <code>3</code> <code>source</code> <code>str</code> <p>Which input field to calculate the Indicator. Defaults to \"close\"</p> <code>'close'</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/#hexital.STOCH.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/#hexital.STOCH.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/#hexital.STOCH.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/#hexital.STOCH.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/#hexital.STOCH.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.STOCH.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.STOCH.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.STOCH.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/#hexital.STOCH.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.STOCH.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.STOCH.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/#hexital.STOCH.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.STOCH.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.STOCH.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/#hexital.STOCH.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.Supertrend","title":"Supertrend  <code>dataclass</code>","text":"<pre><code>Supertrend(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    period: int = 7,\n    source: Source = \"close\",\n    multiplier: float = 3.0\n)\n</code></pre> <p>               Bases: <code>Indicator[dict]</code></p> <p>Supertrend</p> <p>It is used to identify market trends and potential entry and exit points in trading. The indicator is based on two dynamic values, period and multiplier, and incorporates the concept of Average True Range (ATR) to measure market volatility. The SuperTrend Indicator generates buy and sell signals by plotting a line on the price chart.</p> <p>Output type: <code>Dict[\"trend\": float, \"direction\": int, \"short\": float]</code></p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>How many Periods to use. Defaults to 7</p> <code>7</code> <code>source</code> <code>str</code> <p>Which input field to calculate the Indicator. Defaults to \"close\"</p> <code>'close'</code> <code>multiplier</code> <code>float</code> <p>A positive float to multiply the ATR. Defaults to 3.0</p> <code>3.0</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/#hexital.Supertrend.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/#hexital.Supertrend.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/#hexital.Supertrend.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/#hexital.Supertrend.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/#hexital.Supertrend.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.Supertrend.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.Supertrend.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.Supertrend.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/#hexital.Supertrend.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.Supertrend.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.Supertrend.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/#hexital.Supertrend.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.Supertrend.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.Supertrend.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/#hexital.Supertrend.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.TR","title":"TR  <code>dataclass</code>","text":"<pre><code>TR(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4\n)\n</code></pre> <p>               Bases: <code>Indicator[float | None]</code></p> <p>True Range - TR</p> <p>An method to expand a classical range (high minus low) to include possible gap scenarios.</p> Sources <p>https://www.macroption.com/true-range/</p> <p>Output type: <code>float</code></p> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/#hexital.TR.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/#hexital.TR.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/#hexital.TR.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/#hexital.TR.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/#hexital.TR.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.TR.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.TR.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.TR.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/#hexital.TR.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.TR.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.TR.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/#hexital.TR.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.TR.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.TR.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/#hexital.TR.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.TSI","title":"TSI  <code>dataclass</code>","text":"<pre><code>TSI(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    period: int = 25,\n    smooth_period: Optional[int] = None,\n    source: Source = \"close\"\n)\n</code></pre> <p>               Bases: <code>Indicator[float | None]</code></p> <p>True Strength Index - TSI TSI attempts to show both trend direction and overbought/oversold conditions, using moving averages of the underlying momentum of a financial instrument.</p> Sources <p>https://school.stockcharts.com/doku.php?id=technical_indicators:true_strength_index</p> <p>Output type: <code>float</code></p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>How many Periods to use. Defaults to 25</p> <code>25</code> <code>smooth_period</code> <code>int</code> <p>How much to smooth with EMA defaults: (period / 2) + (period % 2 &gt; 0). Defaults to halve of period</p> <code>None</code> <code>source</code> <code>str</code> <p>Which input field to calculate the Indicator. Defaults to \"close\"</p> <code>'close'</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/#hexital.TSI.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/#hexital.TSI.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/#hexital.TSI.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/#hexital.TSI.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/#hexital.TSI.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.TSI.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.TSI.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.TSI.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/#hexital.TSI.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.TSI.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.TSI.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/#hexital.TSI.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.TSI.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.TSI.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/#hexital.TSI.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.VWAP","title":"VWAP  <code>dataclass</code>","text":"<pre><code>VWAP(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    anchor: Optional[str | TimeFrame | timedelta | int] = \"D\"\n)\n</code></pre> <p>               Bases: <code>Indicator[float]</code></p> <p>Volume-Weighted Average Price - VWAP</p> <p>The volume-weighted average price is a technical analysis indicator used on intraday charts that resets at the start of every new trading session.</p> Sources <p>https://www.investopedia.com/terms/v/vwap.asp</p> <p>Output type: <code>float</code></p> <p>Parameters:</p> Name Type Description Default <code>anchor</code> <code>Optional[str | TimeFrame | timedelta | int]</code> <p>How to anchor VWAP, Depends on the index values, uses TimeFrame</p> <code>'D'</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/#hexital.VWAP.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/#hexital.VWAP.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/#hexital.VWAP.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/#hexital.VWAP.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/#hexital.VWAP.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.VWAP.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.VWAP.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.VWAP.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/#hexital.VWAP.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.VWAP.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.VWAP.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/#hexital.VWAP.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.VWAP.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.VWAP.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/#hexital.VWAP.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.VWMA","title":"VWMA  <code>dataclass</code>","text":"<pre><code>VWMA(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    period: int = 10\n)\n</code></pre> <p>               Bases: <code>Indicator[float | None]</code></p> <p>Volume Weighted Moving Average - VWMA</p> <p>VWMA is the ratio of the value of a security or financial asset traded to the total volume of transactions during a trading session. It is a measure of the average trading price for the period.</p> Sources <p>https://www.investopedia.com/ask/answers/071414/whats-difference-between-moving-average-and-weighted-moving-average.asp</p> <p>Output type: <code>float</code></p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>How many Periods to use. Defaults to 10</p> <code>10</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/#hexital.VWMA.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/#hexital.VWMA.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/#hexital.VWMA.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/#hexital.VWMA.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/#hexital.VWMA.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.VWMA.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.VWMA.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.VWMA.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/#hexital.VWMA.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.VWMA.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.VWMA.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/#hexital.VWMA.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.VWMA.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.VWMA.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/#hexital.VWMA.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.WMA","title":"WMA  <code>dataclass</code>","text":"<pre><code>WMA(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    period: int = 10,\n    source: Source = \"close\"\n)\n</code></pre> <p>               Bases: <code>Indicator[float | None]</code></p> <p>Weighted Moving Average - WMA</p> <p>A Weighted Moving Average puts more weight on recent data and less on past data. This is done by multiplying each bar's price by a weighting factor. Because of its unique calculation, WMA will follow prices more closely than a corresponding Simple Moving Average.</p> Sources <p>https://www.investopedia.com/ask/answers/071414/whats-difference-between-moving-average-and-weighted-moving-average.asp</p> <p>Output type: <code>float</code></p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>How many Periods to use. Defaults to 10</p> <code>10</code> <code>source</code> <code>str</code> <p>Which input field to calculate the Indicator. Defaults to \"close\"</p> <code>'close'</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/#hexital.WMA.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/#hexital.WMA.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/#hexital.WMA.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/#hexital.WMA.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/#hexital.WMA.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.WMA.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.WMA.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/#hexital.WMA.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/#hexital.WMA.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/#hexital.WMA.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.WMA.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/#hexital.WMA.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.WMA.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/#hexital.WMA.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/#hexital.WMA.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/exceptions/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> exceptions","text":""},{"location":"reference/hexital/exceptions/#hexital.exceptions","title":"exceptions","text":""},{"location":"reference/hexital/analysis/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> analysis","text":""},{"location":"reference/hexital/analysis/#hexital.analysis","title":"analysis","text":"<p>Modules:</p> Name Description <code>movement</code> <code>patterns</code> <code>utils</code>"},{"location":"reference/hexital/analysis/movement/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> movement","text":""},{"location":"reference/hexital/analysis/movement/#hexital.analysis.movement","title":"movement","text":"<p>Functions:</p> Name Description <code>above</code> <p>Above Analysis</p> <code>below</code> <p>Below Analysis</p> <code>cross</code> <p>Cross Analysis</p> <code>crossover</code> <p>Crossover Analysis</p> <code>crossunder</code> <p>Crossunder Analysis</p> <code>falling</code> <p>Falling Analysis</p> <code>flipped</code> <p>Flipped Reading Analysis</p> <code>highest</code> <p>Highest Reading Analysis</p> <code>highestbar</code> <p>Highest Bar Offset Analysis</p> <code>lowest</code> <p>Lowest Reading Analysis</p> <code>lowestbar</code> <p>Lowest Bar Offset Analysis</p> <code>mean_falling</code> <p>Mean Falling Analysis</p> <code>mean_rising</code> <p>Mean Rising Analysis</p> <code>rising</code> <p>Rising Analysis</p> <code>value_range</code> <p>Value Range Analysis</p>"},{"location":"reference/hexital/analysis/movement/#hexital.analysis.movement.above","title":"above","text":"<pre><code>above(\n    candles: Indicator | Hexital | List[Candle],\n    indicator: str,\n    indicator_cmp: str,\n    length: int = 0,\n    index: int = -1,\n) -&gt; bool\n</code></pre> <p>Above Analysis</p> <p>Checks whether the <code>indicator</code> reading is higher than the <code>indicator_cmp</code> reading. By default, it evaluates the latest candle but can also check <code>n</code> candles back. If any candle within the specified range is above, it returns <code>True</code>.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Indicator | Hexital | List[Candle]</code> <p>The data source containing the indicators.</p> required <code>indicator</code> <code>str</code> <p>The primary indicator to evaluate.</p> required <code>indicator_cmp</code> <code>str</code> <p>The secondary indicator to compare against.</p> required <code>length</code> <code>int</code> <p>The number of candles to include in the range. Defaults to 0 (only the current index).</p> <code>0</code> <code>index</code> <code>int</code> <p>The index to start the evaluation. Defaults to -1 (latest candle).</p> <code>-1</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if <code>indicator</code> is above <code>indicator_cmp</code> within the specified range; otherwise <code>False</code>.</p> Source code in <code>hexital/analysis/movement.py</code> <pre><code>def above(\n    candles: Indicator | Hexital | List[Candle],\n    indicator: str,\n    indicator_cmp: str,\n    length: int = 0,\n    index: int = -1,\n) -&gt; bool:\n    \"\"\"Above Analysis\n\n    Checks whether the `indicator` reading is higher than the `indicator_cmp` reading.\n    By default, it evaluates the latest candle but can also check `n` candles back.\n    If any candle within the specified range is above, it returns `True`.\n\n    Args:\n        candles (Indicator | Hexital | List[Candle]): The data source containing the indicators.\n        indicator (str): The primary indicator to evaluate.\n        indicator_cmp (str): The secondary indicator to compare against.\n        length (int, optional):  The number of candles to include in the range. Defaults to 0 (only the current index).\n        index (int, optional): The index to start the evaluation. Defaults to -1 (latest candle).\n\n    Returns:\n        bool: `True` if `indicator` is above `indicator_cmp` within the specified range; otherwise `False`.\n    \"\"\"\n    candles_ = _retrieve_candles(candles, indicator, indicator_cmp)\n\n    if isinstance(candles_, list):\n        idx = absindex(index, len(candles_)) + 1\n        length = idx - (length + 1)\n\n        return _above(\n            candles_[length:idx],\n            indicator,\n            candles_[length:idx],\n            indicator_cmp,\n        )\n    elif isinstance(candles_, tuple):\n        candle_set = _timeframe_pair_candles(candles_)\n        idx = absindex(index, len(candle_set[0])) + 1\n        length = idx - (length + 1)\n\n        return _above(\n            candle_set[0][length:idx],\n            indicator,\n            candle_set[1][length:idx],\n            indicator_cmp,\n        )\n\n    return False\n</code></pre>"},{"location":"reference/hexital/analysis/movement/#hexital.analysis.movement.below","title":"below","text":"<pre><code>below(\n    candles: Indicator | Hexital | List[Candle],\n    indicator: str,\n    indicator_cmp: str,\n    length: int = 0,\n    index: int = -1,\n) -&gt; bool\n</code></pre> <p>Below Analysis</p> <p>Checks whether the <code>indicator</code> reading is lower than the <code>indicator_cmp</code> reading. By default, it evaluates the latest candle but can also check <code>n</code> candles back. If any candle within the specified range is below, it returns <code>True</code>.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Indicator | Hexital | List[Candle]</code> <p>The data source containing the indicators.</p> required <code>indicator</code> <code>str</code> <p>The primary indicator to evaluate.</p> required <code>indicator_cmp</code> <code>str</code> <p>The secondary indicator to compare against.</p> required <code>length</code> <code>int</code> <p>The number of candles to include in the range. Defaults to 0 (only the current index).</p> <code>0</code> <code>index</code> <code>int</code> <p>The index to start the evaluation. Defaults to -1 (latest candle).</p> <code>-1</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if <code>indicator</code> is below <code>indicator_cmp</code> within the specified range; otherwise <code>False</code>.</p> Source code in <code>hexital/analysis/movement.py</code> <pre><code>def below(\n    candles: Indicator | Hexital | List[Candle],\n    indicator: str,\n    indicator_cmp: str,\n    length: int = 0,\n    index: int = -1,\n) -&gt; bool:\n    \"\"\"Below Analysis\n\n    Checks whether the `indicator` reading is lower than the `indicator_cmp` reading.\n    By default, it evaluates the latest candle but can also check `n` candles back.\n    If any candle within the specified range is below, it returns `True`.\n\n    Args:\n        candles (Indicator | Hexital | List[Candle]): The data source containing the indicators.\n        indicator (str): The primary indicator to evaluate.\n        indicator_cmp (str): The secondary indicator to compare against.\n        length (int, optional): The number of candles to include in the range. Defaults to 0 (only the current index).\n        index (int, optional): The index to start the evaluation. Defaults to -1 (latest candle).\n\n    Returns:\n        bool: `True` if `indicator` is below `indicator_cmp` within the specified range; otherwise `False`.\n    \"\"\"\n    candles_ = _retrieve_candles(candles, indicator, indicator_cmp)\n\n    if isinstance(candles_, list):\n        idx = absindex(index, len(candles_)) + 1\n        length = idx - (length + 1)\n\n        return _below(\n            candles_[length:idx],\n            indicator,\n            candles_[length:idx],\n            indicator_cmp,\n        )\n    elif isinstance(candles_, tuple):\n        candle_set = _timeframe_pair_candles(candles_)\n        idx = absindex(index, len(candle_set[0])) + 1\n        length = idx - (length + 1)\n\n        return _below(\n            candle_set[0][length:idx],\n            indicator,\n            candle_set[1][length:idx],\n            indicator_cmp,\n        )\n\n    return False\n</code></pre>"},{"location":"reference/hexital/analysis/movement/#hexital.analysis.movement.cross","title":"cross","text":"<pre><code>cross(\n    candles: Indicator | Hexital | List[Candle],\n    indicator: str,\n    indicator_cmp: str,\n    length: int = 1,\n    index: int = -1,\n) -&gt; bool\n</code></pre> <p>Cross Analysis</p> <p>Determines whether the <code>indicator</code> reading has crossed the <code>indicator_cmp</code> reading within a specified range of candles. The cross can occur in either direction.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Indicator | Hexital | List[Candle]</code> <p>The data source containing the indicators.</p> required <code>indicator</code> <code>str</code> <p>The primary indicator to evaluate.</p> required <code>indicator_cmp</code> <code>str</code> <p>The secondary indicator to compare against.</p> required <code>length</code> <code>int</code> <p>The number of candles to include in the range. Defaults to 1. (compares the latest with the previous).</p> <code>1</code> <code>index</code> <code>int</code> <p>The index to start the evaluation. Defaults to -1 (latest candle).</p> <code>-1</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if <code>indicator</code> has crossed <code>indicator_cmp</code> within the specified range; otherwise <code>False</code>.</p> Source code in <code>hexital/analysis/movement.py</code> <pre><code>def cross(\n    candles: Indicator | Hexital | List[Candle],\n    indicator: str,\n    indicator_cmp: str,\n    length: int = 1,\n    index: int = -1,\n) -&gt; bool:\n    \"\"\"Cross Analysis\n\n    Determines whether the `indicator` reading has crossed the `indicator_cmp` reading\n    within a specified range of candles. The cross can occur in either direction.\n\n    Args:\n        candles (Indicator | Hexital | List[Candle]): The data source containing the indicators.\n        indicator (str): The primary indicator to evaluate.\n        indicator_cmp (str): The secondary indicator to compare against.\n        length (int, optional): The number of candles to include in the range. Defaults to 1.\n            (compares the latest with the previous).\n        index (int, optional): The index to start the evaluation. Defaults to -1 (latest candle).\n\n    Returns:\n        bool: `True` if `indicator` has crossed `indicator_cmp` within the specified range; otherwise `False`.\n    \"\"\"\n    candles_ = _retrieve_candles(candles, indicator, indicator_cmp)\n\n    if isinstance(candles_, list):\n        idx = absindex(index, len(candles_)) + 1\n        length = idx - (length + 1)\n        return _cross(candles_[length:idx], indicator, candles_[length:idx], indicator_cmp)\n\n    elif isinstance(candles_, tuple):\n        candle_set = _timeframe_pair_candles(candles_)\n        idx = absindex(index, len(candle_set[0])) + 1\n        length = idx - (length + 1)\n        return _cross(\n            candle_set[0][length:idx], indicator, candle_set[1][length:idx], indicator_cmp\n        )\n\n    return False\n</code></pre>"},{"location":"reference/hexital/analysis/movement/#hexital.analysis.movement.crossover","title":"crossover","text":"<pre><code>crossover(\n    candles: Indicator | Hexital | List[Candle],\n    indicator: str,\n    indicator_cmp: str,\n    length: int = 1,\n    index: int = -1,\n) -&gt; bool\n</code></pre> <p>Crossover Analysis</p> <p>Determines whether the <code>indicator</code> reading has crossed over the <code>indicator_cmp</code> reading within a specified range of candles. A crossover occurs when <code>indicator</code> transitions from below to above <code>indicator_cmp</code> within the given range.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Indicator | Hexital | List[Candle]</code> <p>The data source containing the indicators.</p> required <code>indicator</code> <code>str</code> <p>The primary indicator to evaluate.</p> required <code>indicator_cmp</code> <code>str</code> <p>The secondary indicator to compare against.</p> required <code>length</code> <code>int</code> <p>The number of candles to include in the range. Defaults to 1. If <code>length</code> exceeds the total number of candles, all available candles are checked.</p> <code>1</code> <code>index</code> <code>int</code> <p>The index to start the evaluation. Defaults to -1 (latest candle).</p> <code>-1</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if <code>indicator</code> has crossed over <code>indicator_cmp</code> within the specified range;</p> <code>bool</code> <p>otherwise <code>False</code>.</p> Source code in <code>hexital/analysis/movement.py</code> <pre><code>def crossover(\n    candles: Indicator | Hexital | List[Candle],\n    indicator: str,\n    indicator_cmp: str,\n    length: int = 1,\n    index: int = -1,\n) -&gt; bool:\n    \"\"\"Crossover Analysis\n\n    Determines whether the `indicator` reading has crossed over the `indicator_cmp` reading\n    within a specified range of candles. A crossover occurs when `indicator` transitions from below\n    to above `indicator_cmp` within the given range.\n\n    Args:\n        candles (Indicator | Hexital | List[Candle]): The data source containing the indicators.\n        indicator (str): The primary indicator to evaluate.\n        indicator_cmp (str): The secondary indicator to compare against.\n        length (int, optional): The number of candles to include in the range. Defaults to 1.\n            If `length` exceeds the total number of candles, all available candles are checked.\n        index (int, optional): The index to start the evaluation. Defaults to -1 (latest candle).\n\n    Returns:\n        bool: `True` if `indicator` has crossed over `indicator_cmp` within the specified range;\n        otherwise `False`.\n    \"\"\"\n    candles_ = _retrieve_candles(candles, indicator, indicator_cmp)\n\n    if isinstance(candles_, list):\n        idx = absindex(index, len(candles_)) + 1\n        length = idx - (length + 1)\n        return _crossover(candles_[length:idx], indicator, candles_[length:idx], indicator_cmp)\n\n    elif isinstance(candles_, tuple):\n        candle_set = _timeframe_pair_candles(candles_)\n        idx = absindex(index, len(candle_set[0])) + 1\n        length = idx - (length + 1)\n\n        return _crossover(\n            candle_set[0][length:idx], indicator, candle_set[1][length:idx], indicator_cmp\n        )\n\n    return False\n</code></pre>"},{"location":"reference/hexital/analysis/movement/#hexital.analysis.movement.crossunder","title":"crossunder","text":"<pre><code>crossunder(\n    candles: Indicator | Hexital | List[Candle],\n    indicator: str,\n    indicator_cmp: str,\n    length: int = 1,\n    index: int = -1,\n) -&gt; bool\n</code></pre> <p>Crossunder Analysis</p> <p>Determines whether the <code>indicator</code> reading has crossed under the <code>indicator_cmp</code> reading within a specified range of candles. A crossunder occurs when <code>indicator</code> transitions from above to below <code>indicator_cmp</code> within the given range.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Indicator | Hexital | List[Candle]</code> <p>The data source containing the indicators.</p> required <code>indicator</code> <code>str</code> <p>The primary indicator to evaluate.</p> required <code>indicator_cmp</code> <code>str</code> <p>The secondary indicator to compare against.</p> required <code>length</code> <code>int</code> <p>The number of candles to include in the range. Defaults to 1. If <code>length</code> exceeds the total number of candles, all available candles are checked.</p> <code>1</code> <code>index</code> <code>int</code> <p>The index to start the evaluation. Defaults to -1 (latest candle).</p> <code>-1</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if <code>indicator</code> has crossed under <code>indicator_cmp</code> within the specified range;</p> <code>bool</code> <p>otherwise <code>False</code>.</p> Source code in <code>hexital/analysis/movement.py</code> <pre><code>def crossunder(\n    candles: Indicator | Hexital | List[Candle],\n    indicator: str,\n    indicator_cmp: str,\n    length: int = 1,\n    index: int = -1,\n) -&gt; bool:\n    \"\"\"Crossunder Analysis\n\n    Determines whether the `indicator` reading has crossed under the `indicator_cmp` reading\n    within a specified range of candles. A crossunder occurs when `indicator` transitions from above\n    to below `indicator_cmp` within the given range.\n\n    Args:\n        candles (Indicator | Hexital | List[Candle]): The data source containing the indicators.\n        indicator (str): The primary indicator to evaluate.\n        indicator_cmp (str): The secondary indicator to compare against.\n        length (int, optional): The number of candles to include in the range. Defaults to 1.\n            If `length` exceeds the total number of candles, all available candles are checked.\n        index (int, optional): The index to start the evaluation. Defaults to -1 (latest candle).\n\n    Returns:\n        bool: `True` if `indicator` has crossed under `indicator_cmp` within the specified range;\n        otherwise `False`.\n    \"\"\"\n    candles_ = _retrieve_candles(candles, indicator, indicator_cmp)\n\n    if isinstance(candles_, list):\n        idx = absindex(index, len(candles_)) + 1\n        length = idx - (length + 1)\n        return _crossunder(candles_[length:idx], indicator, candles_[length:idx], indicator_cmp)\n\n    elif isinstance(candles_, tuple):\n        candle_set = _timeframe_pair_candles(candles_)\n        idx = absindex(index, len(candle_set[0])) + 1\n        length = idx - (length + 1)\n\n        return _crossunder(\n            candle_set[0][length:idx], indicator, candle_set[1][length:idx], indicator_cmp\n        )\n\n    return False\n</code></pre>"},{"location":"reference/hexital/analysis/movement/#hexital.analysis.movement.falling","title":"falling","text":"<pre><code>falling(\n    candles: Indicator | Hexital | List[Candle],\n    indicator: str,\n    length: int = 1,\n    index: int = -1,\n) -&gt; bool\n</code></pre> <p>Falling Analysis</p> <p>Determines whether the <code>indicator</code> consistently falling across a specified range of candles. By default, it checks if the current indicator value is lower than the previous one.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Indicator | Hexital | List[Candle]</code> <p>The data source containing the indicators.</p> required <code>indicator</code> <code>str</code> <p>The name of the indicator to evaluate.</p> required <code>length</code> <code>int</code> <p>The number of candles to include in the range. Defaults to 1. (compares the latest with the previous).</p> <code>1</code> <code>index</code> <code>int</code> <p>The index to start the evaluation. Defaults to -1 (latest candle).</p> <code>-1</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if the <code>indicator</code> is lower than each previous readings in the range; otherwise <code>False</code>.</p> Source code in <code>hexital/analysis/movement.py</code> <pre><code>def falling(\n    candles: Indicator | Hexital | List[Candle], indicator: str, length: int = 1, index: int = -1\n) -&gt; bool:\n    \"\"\"Falling Analysis\n\n    Determines whether the `indicator` consistently falling across a specified range of candles.\n    By default, it checks if the current indicator value is lower than the previous one.\n\n    Args:\n        candles (Indicator | Hexital | List[Candle]): The data source containing the indicators.\n        indicator (str): The name of the indicator to evaluate.\n        length (int, optional): The number of candles to include in the range. Defaults to 1.\n            (compares the latest with the previous).\n        index (int, optional): The index to start the evaluation. Defaults to -1 (latest candle).\n\n    Returns:\n        bool: `True` if the `indicator` is lower than each previous readings in the range; otherwise `False`.\n    \"\"\"\n    candle_set = _retrieve_candles(candles, indicator)\n    if not isinstance(candle_set, list) or not candle_set or length &lt; 1 or len(candle_set) &lt; 2:\n        return False\n\n    idx = absindex(index, len(candle_set))\n\n    latest_reading = reading_by_candle(candle_set[idx], indicator)\n    if latest_reading is None or isinstance(latest_reading, dict):\n        return False\n\n    readings = get_readings_period(candle_set, indicator, length, idx)\n    if not readings:\n        return False\n\n    for reading in readings:\n        if reading &lt;= latest_reading:\n            return False\n    return True\n</code></pre>"},{"location":"reference/hexital/analysis/movement/#hexital.analysis.movement.flipped","title":"flipped","text":"<pre><code>flipped(\n    candles: Indicator | Hexital | List[Candle],\n    indicator: str,\n    length: int = 1,\n    index: int = -1,\n) -&gt; bool\n</code></pre> <p>Flipped Reading Analysis</p> <p>Determines whether the <code>indicator</code> has \"flipped\" its value, meaning the current reading is different from its previous reading, and within the last <code>length</code> candles, the indicator was above its previous reading.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Indicator | Hexital | List[Candle]</code> <p>The data source containing the indicators.</p> required <code>indicator</code> <code>str</code> <p>The indicator to evaluate.</p> required <code>length</code> <code>int</code> <p>The number of candles to check for a flip. Defaults to 1. If <code>length</code> exceeds the total number of candles, all available candles are checked.</p> <code>1</code> <code>index</code> <code>int</code> <p>The index to start the evaluation. Defaults to -1 (latest candle).</p> <code>-1</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if the indicator has flipped (current value differs from previous); otherwise <code>False</code>.</p> Source code in <code>hexital/analysis/movement.py</code> <pre><code>def flipped(\n    candles: Indicator | Hexital | List[Candle], indicator: str, length: int = 1, index: int = -1\n) -&gt; bool:\n    \"\"\"Flipped Reading Analysis\n\n    Determines whether the `indicator` has \"flipped\" its value, meaning the current reading is different\n    from its previous reading, and within the last `length` candles, the indicator was above its previous reading.\n\n    Args:\n        candles (Indicator | Hexital | List[Candle]): The data source containing the indicators.\n        indicator (str): The indicator to evaluate.\n        length (int, optional): The number of candles to check for a flip. Defaults to 1.\n            If `length` exceeds the total number of candles, all available candles are checked.\n        index (int, optional): The index to start the evaluation. Defaults to -1 (latest candle).\n\n    Returns:\n        bool: `True` if the indicator has flipped (current value differs from previous); otherwise `False`.\n    \"\"\"\n    candle_set = _retrieve_candles(candles, indicator)\n    if not isinstance(candle_set, list) or not candle_set:\n        return False\n\n    idx = absindex(index, len(candle_set))\n\n    for idx in range(idx, idx - length, -1):\n        if reading_by_index(candle_set, indicator, idx) != reading_by_index(\n            candle_set, indicator, idx - 1\n        ):\n            return True\n\n    return False\n</code></pre>"},{"location":"reference/hexital/analysis/movement/#hexital.analysis.movement.highest","title":"highest","text":"<pre><code>highest(\n    candles: Indicator | Hexital | List[Candle],\n    indicator: str,\n    length: int = 4,\n    index: int = -1,\n) -&gt; float | None\n</code></pre> <p>Highest Reading Analysis</p> <p>Determines the highest value of the specified <code>indicator</code> over a given number of candles. By default, includes the latest candle and evaluates up to the previous four candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Indicator | Hexital | List[Candle]</code> <p>The data source containing the indicators.</p> required <code>indicator</code> <code>str</code> <p>The name of the indicator to evaluate.</p> required <code>length</code> <code>int</code> <p>The number of candles to include in the range. Defaults to 4.</p> <code>4</code> <code>index</code> <code>int</code> <p>The index to start the evaluation. Defaults to -1 (latest candle).</p> <code>-1</code> <p>Returns:</p> Type Description <code>float | None</code> <p>float | None: The highest reading for the specified <code>indicator</code> within the range,</p> <code>float | None</code> <p>or <code>None</code> if no valid readings are found.</p> Source code in <code>hexital/analysis/movement.py</code> <pre><code>def highest(\n    candles: Indicator | Hexital | List[Candle], indicator: str, length: int = 4, index: int = -1\n) -&gt; float | None:\n    \"\"\"Highest Reading Analysis\n\n    Determines the highest value of the specified `indicator` over a given number of candles.\n    By default, includes the latest candle and evaluates up to the previous four candles.\n\n    Args:\n        candles (Indicator | Hexital | List[Candle]): The data source containing the indicators.\n        indicator (str): The name of the indicator to evaluate.\n        length (int, optional): The number of candles to include in the range. Defaults to 4.\n        index (int, optional): The index to start the evaluation. Defaults to -1 (latest candle).\n\n    Returns:\n        float | None: The highest reading for the specified `indicator` within the range,\n        or `None` if no valid readings are found.\n    \"\"\"\n    candles_ = _retrieve_candles(candles, indicator)\n    if not isinstance(candles_, list):\n        return None\n    return utils.highest(candles_, indicator, length, index)\n</code></pre>"},{"location":"reference/hexital/analysis/movement/#hexital.analysis.movement.highestbar","title":"highestbar","text":"<pre><code>highestbar(\n    candles: Indicator | Hexital | List[Candle],\n    indicator: str,\n    length: int = 4,\n    index: int = -1,\n) -&gt; int | None\n</code></pre> <p>Highest Bar Offset Analysis</p> <p>Determines the offset (distance) to the candle with the highest reading of the specified <code>indicator</code> within a given range. By default, includes the latest candle and evaluates up to the previous four candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Indicator | Hexital | List[Candle]</code> <p>The data source containing the indicators.</p> required <code>indicator</code> <code>str</code> <p>The name of the indicator to evaluate.</p> required <code>length</code> <code>int</code> <p>The number of candles to include in the range. Defaults to 4.</p> <code>4</code> <code>index</code> <code>int</code> <p>The index to start the evaluation. Defaults to -1 (latest candle).</p> <code>-1</code> <p>Returns:</p> Type Description <code>int | None</code> <p>int | None: The offset to the candle with the highest reading, relative to the starting index,</p> <code>int | None</code> <p>or <code>None</code> if no valid readings are found.</p> Source code in <code>hexital/analysis/movement.py</code> <pre><code>def highestbar(\n    candles: Indicator | Hexital | List[Candle], indicator: str, length: int = 4, index: int = -1\n) -&gt; int | None:\n    \"\"\"Highest Bar Offset Analysis\n\n    Determines the offset (distance) to the candle with the highest reading of the specified `indicator`\n    within a given range. By default, includes the latest candle and evaluates up to the previous four candles.\n\n    Args:\n        candles (Indicator | Hexital | List[Candle]): The data source containing the indicators.\n        indicator (str): The name of the indicator to evaluate.\n        length (int, optional): The number of candles to include in the range. Defaults to 4.\n        index (int, optional): The index to start the evaluation. Defaults to -1 (latest candle).\n\n    Returns:\n        int | None: The offset to the candle with the highest reading, relative to the starting index,\n        or `None` if no valid readings are found.\n    \"\"\"\n    candle_set = _retrieve_candles(candles, indicator)\n    if not isinstance(candle_set, list) or not candle_set:\n        return None\n\n    idx = absindex(index, len(candle_set))\n\n    high = None\n    distance = 0\n\n    for idx, index in enumerate(range(idx, idx - length, -1)):\n        current = reading_by_index(candle_set, indicator, index)\n        if not isinstance(current, (float, int)):\n            continue\n\n        if high is None:\n            high = current\n\n        if high &lt; current:\n            high = current\n            distance = idx\n\n    return distance\n</code></pre>"},{"location":"reference/hexital/analysis/movement/#hexital.analysis.movement.lowest","title":"lowest","text":"<pre><code>lowest(\n    candles: Indicator | Hexital | List[Candle],\n    indicator: str,\n    length: int = 4,\n    index: int = -1,\n) -&gt; float | None\n</code></pre> <p>Lowest Reading Analysis</p> <p>Determines the lowest value of the specified <code>indicator</code> over a given number of candles. By default, includes the latest candle and evaluates up to the previous four candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Indicator | Hexital | List[Candle]</code> <p>The data source containing the indicators.</p> required <code>indicator</code> <code>str</code> <p>The name of the indicator to evaluate.</p> required <code>length</code> <code>int</code> <p>The number of candles to include in the range. Defaults to 4.</p> <code>4</code> <code>index</code> <code>int</code> <p>The index to start the evaluation. Defaults to -1 (latest candle).</p> <code>-1</code> <p>Returns:</p> Type Description <code>float | None</code> <p>float | None: The lowest reading for the specified <code>indicator</code> within the range,</p> <code>float | None</code> <p>or <code>None</code> if no valid readings are found.</p> Source code in <code>hexital/analysis/movement.py</code> <pre><code>def lowest(\n    candles: Indicator | Hexital | List[Candle], indicator: str, length: int = 4, index: int = -1\n) -&gt; float | None:\n    \"\"\"Lowest Reading Analysis\n\n    Determines the lowest value of the specified `indicator` over a given number of candles.\n    By default, includes the latest candle and evaluates up to the previous four candles.\n\n    Args:\n        candles (Indicator | Hexital | List[Candle]): The data source containing the indicators.\n        indicator (str): The name of the indicator to evaluate.\n        length (int, optional): The number of candles to include in the range. Defaults to 4.\n        index (int, optional): The index to start the evaluation. Defaults to -1 (latest candle).\n\n    Returns:\n        float | None: The lowest reading for the specified `indicator` within the range,\n        or `None` if no valid readings are found.\n    \"\"\"\n    candles_ = _retrieve_candles(candles, indicator)\n    if not isinstance(candles_, list):\n        return None\n    return utils.lowest(candles_, indicator, length, index)\n</code></pre>"},{"location":"reference/hexital/analysis/movement/#hexital.analysis.movement.lowestbar","title":"lowestbar","text":"<pre><code>lowestbar(\n    candles: Indicator | Hexital | List[Candle],\n    indicator: str,\n    length: int = 4,\n    index: int = -1,\n) -&gt; int | None\n</code></pre> <p>Lowest Bar Offset Analysis</p> <p>Determines the offset (distance) to the candle with the lowest reading of the specified <code>indicator</code> within a given range. By default, includes the latest candle and evaluates up to the previous four candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Indicator | Hexital | List[Candle]</code> <p>The data source containing the indicators.</p> required <code>indicator</code> <code>str</code> <p>The name of the indicator to evaluate.</p> required <code>length</code> <code>int</code> <p>The number of candles to include in the range. Defaults to 4.</p> <code>4</code> <code>index</code> <code>int</code> <p>The index to start the evaluation. Defaults to -1 (latest candle).</p> <code>-1</code> <p>Returns:</p> Type Description <code>int | None</code> <p>int | None: The offset to the candle with the lowest reading, relative to the starting index,</p> <code>int | None</code> <p>or <code>None</code> if no valid readings are found.</p> Source code in <code>hexital/analysis/movement.py</code> <pre><code>def lowestbar(\n    candles: Indicator | Hexital | List[Candle], indicator: str, length: int = 4, index: int = -1\n) -&gt; int | None:\n    \"\"\"Lowest Bar Offset Analysis\n\n    Determines the offset (distance) to the candle with the lowest reading of the specified `indicator`\n    within a given range. By default, includes the latest candle and evaluates up to the previous four candles.\n\n    Args:\n        candles (Indicator | Hexital | List[Candle]): The data source containing the indicators.\n        indicator (str): The name of the indicator to evaluate.\n        length (int, optional): The number of candles to include in the range. Defaults to 4.\n        index (int, optional): The index to start the evaluation. Defaults to -1 (latest candle).\n\n    Returns:\n        int | None: The offset to the candle with the lowest reading, relative to the starting index,\n        or `None` if no valid readings are found.\n    \"\"\"\n    candle_set = _retrieve_candles(candles, indicator)\n    if not isinstance(candle_set, list) or not candle_set:\n        return None\n\n    idx = absindex(index, len(candle_set))\n\n    low = None\n    distance = 0\n\n    for idx, index in enumerate(range(idx, idx - length, -1)):\n        current = reading_by_index(candle_set, indicator, index)\n        if not isinstance(current, (float, int)):\n            continue\n\n        if low is None:\n            low = current\n\n        if low &gt; current:\n            low = current\n            distance = idx\n\n    return distance\n</code></pre>"},{"location":"reference/hexital/analysis/movement/#hexital.analysis.movement.mean_falling","title":"mean_falling","text":"<pre><code>mean_falling(\n    candles: Indicator | Hexital | List[Candle],\n    indicator: str,\n    length: int = 4,\n    index: int = -1,\n) -&gt; bool\n</code></pre> <p>Mean Falling Analysis</p> <p>Evaluates whether the <code>indicator</code> is, on average, falling across a specified range of candles. By default, it checks if the current indicator value is lower than the average of the previous four readings.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Indicator | Hexital | List[Candle]</code> <p>The data source containing the indicators.</p> required <code>indicator</code> <code>str</code> <p>The name of the indicator to evaluate.</p> required <code>length</code> <code>int</code> <p>The number of candles to include in the range. Defaults to 4.</p> <code>4</code> <code>index</code> <code>int</code> <p>The index to start the evaluation. Defaults to -1 (latest candle).</p> <code>-1</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if the <code>indicator</code> is lower than the average of the specified <code>n</code> readings; otherwise <code>False</code>.</p> Source code in <code>hexital/analysis/movement.py</code> <pre><code>def mean_falling(\n    candles: Indicator | Hexital | List[Candle], indicator: str, length: int = 4, index: int = -1\n) -&gt; bool:\n    \"\"\"Mean Falling Analysis\n\n    Evaluates whether the `indicator` is, on average, falling across a specified range of candles.\n    By default, it checks if the current indicator value is lower than the average of the previous four readings.\n\n    Args:\n        candles (Indicator | Hexital | List[Candle]): The data source containing the indicators.\n        indicator (str): The name of the indicator to evaluate.\n        length (int, optional): The number of candles to include in the range. Defaults to 4.\n        index (int, optional): The index to start the evaluation. Defaults to -1 (latest candle).\n\n    Returns:\n        bool: `True` if the `indicator` is lower than the average of the specified `n` readings; otherwise `False`.\n    \"\"\"\n    candle_set = _retrieve_candles(candles, indicator)\n    if not isinstance(candle_set, list) or not candle_set or length &lt; 1 or len(candle_set) &lt; 2:\n        return False\n\n    idx = absindex(index, len(candle_set))\n\n    latest_reading = reading_by_candle(candle_set[idx], indicator)\n    if latest_reading is None or isinstance(latest_reading, dict):\n        return False\n\n    readings = get_readings_period(candle_set, indicator, length, idx)\n    if not readings:\n        return False\n\n    return sum(readings) / len(readings) &gt; latest_reading\n</code></pre>"},{"location":"reference/hexital/analysis/movement/#hexital.analysis.movement.mean_rising","title":"mean_rising","text":"<pre><code>mean_rising(\n    candles: Indicator | Hexital | List[Candle],\n    indicator: str,\n    length: int = 4,\n    index: int = -1,\n) -&gt; bool\n</code></pre> <p>Mean Rising Analysis</p> <p>Evaluates whether the <code>indicator</code> is, on average, rising across a specified range of candles. By default, it checks if the current indicator value is higher than the average of the previous four readings.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Indicator | Hexital | List[Candle]</code> <p>The data source containing the indicators.</p> required <code>indicator</code> <code>str</code> <p>The name of the indicator to evaluate.</p> required <code>length</code> <code>int</code> <p>The number of candles to include in the range. Defaults to 4.</p> <code>4</code> <code>index</code> <code>int</code> <p>The index to start the evaluation. Defaults to -1 (latest candle).</p> <code>-1</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if the <code>indicator</code> is higher than the average of the specified <code>n</code> readings; otherwise <code>False</code>.</p> Source code in <code>hexital/analysis/movement.py</code> <pre><code>def mean_rising(\n    candles: Indicator | Hexital | List[Candle], indicator: str, length: int = 4, index: int = -1\n) -&gt; bool:\n    \"\"\"Mean Rising Analysis\n\n    Evaluates whether the `indicator` is, on average, rising across a specified range of candles.\n    By default, it checks if the current indicator value is higher than the average of the previous four readings.\n\n    Args:\n        candles (Indicator | Hexital | List[Candle]): The data source containing the indicators.\n        indicator (str): The name of the indicator to evaluate.\n        length (int, optional): The number of candles to include in the range. Defaults to 4.\n        index (int, optional): The index to start the evaluation. Defaults to -1 (latest candle).\n\n    Returns:\n        bool: `True` if the `indicator` is higher than the average of the specified `n` readings; otherwise `False`.\n    \"\"\"\n\n    candle_set = _retrieve_candles(candles, indicator)\n    if not isinstance(candle_set, list) or not candle_set or length &lt; 1 or len(candle_set) &lt; 2:\n        return False\n\n    idx = absindex(index, len(candle_set))\n\n    latest_reading = reading_by_candle(candle_set[idx], indicator)\n    if latest_reading is None or isinstance(latest_reading, dict):\n        return False\n\n    readings = get_readings_period(candle_set, indicator, length, idx)\n    if not readings:\n        return False\n\n    return sum(readings) / len(readings) &lt; latest_reading\n</code></pre>"},{"location":"reference/hexital/analysis/movement/#hexital.analysis.movement.rising","title":"rising","text":"<pre><code>rising(\n    candles: Indicator | Hexital | List[Candle],\n    indicator: str,\n    length: int = 1,\n    index: int = -1,\n) -&gt; bool\n</code></pre> <p>Rising Analysis</p> <p>Determines whether the <code>indicator</code> consistently rises across a specified range of candles. By default, it checks if the current indicator value is greater than the previous one.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Indicator | Hexital | List[Candle]</code> <p>The data source containing the indicators.</p> required <code>indicator</code> <code>str</code> <p>The name of the indicator to evaluate.</p> required <code>length</code> <code>int</code> <p>The number of candles to include in the range. Defaults to 1. (compares the latest with the previous).</p> <code>1</code> <code>index</code> <code>int</code> <p>The index to start the evaluation. Defaults to -1 (latest candle).</p> <code>-1</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p><code>True</code> if the <code>indicator</code> is greater than each previous readings in the range; otherwise <code>False</code>.</p> Source code in <code>hexital/analysis/movement.py</code> <pre><code>def rising(\n    candles: Indicator | Hexital | List[Candle], indicator: str, length: int = 1, index: int = -1\n) -&gt; bool:\n    \"\"\"Rising Analysis\n\n    Determines whether the `indicator` consistently rises across a specified range of candles.\n    By default, it checks if the current indicator value is greater than the previous one.\n\n    Args:\n        candles (Indicator | Hexital | List[Candle]): The data source containing the indicators.\n        indicator (str): The name of the indicator to evaluate.\n        length (int, optional): The number of candles to include in the range. Defaults to 1.\n            (compares the latest with the previous).\n        index (int, optional): The index to start the evaluation. Defaults to -1 (latest candle).\n\n    Returns:\n        bool: `True` if the `indicator` is greater than each previous readings in the range; otherwise `False`.\n    \"\"\"\n    candle_set = _retrieve_candles(candles, indicator)\n    if not isinstance(candle_set, list) or not candle_set or length &lt; 1 or len(candle_set) &lt; 2:\n        return False\n\n    idx = absindex(index, len(candle_set))\n\n    latest_reading = reading_by_candle(candle_set[idx], indicator)\n    if latest_reading is None or isinstance(latest_reading, dict):\n        return False\n\n    readings = get_readings_period(candle_set, indicator, length, idx)\n    if not readings:\n        return False\n\n    for reading in readings:\n        if reading &gt;= latest_reading:\n            return False\n    return True\n</code></pre>"},{"location":"reference/hexital/analysis/movement/#hexital.analysis.movement.value_range","title":"value_range","text":"<pre><code>value_range(\n    candles: Indicator | Hexital | List[Candle],\n    indicator: str,\n    length: int = 4,\n    index: int = -1,\n) -&gt; float | None\n</code></pre> <p>Value Range Analysis</p> <p>Calculates the difference between the minimum and maximum values for the given <code>indicator</code> within a specified range of candles. Includes the latest candle by default. If the specified length exceeds the available candles, it will evaluate all candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Indicator | Hexital | List[Candle]</code> <p>The data source containing the indicators.</p> required <code>indicator</code> <code>str</code> <p>The name of the indicator to evaluate.</p> required <code>length</code> <code>int</code> <p>The number of candles to include in the range. Defaults to 4.</p> <code>4</code> <code>index</code> <code>int</code> <p>The index to start the evaluation. Defaults to -1 (latest candle).</p> <code>-1</code> <p>Returns:</p> Type Description <code>float | None</code> <p>float | None: The difference between the minimum and maximum indicator values in the range,</p> <code>float | None</code> <p>or <code>None</code> if there are insufficient readings.</p> Source code in <code>hexital/analysis/movement.py</code> <pre><code>def value_range(\n    candles: Indicator | Hexital | List[Candle], indicator: str, length: int = 4, index: int = -1\n) -&gt; float | None:\n    \"\"\"Value Range Analysis\n\n    Calculates the difference between the minimum and maximum values for the given `indicator`\n    within a specified range of candles. Includes the latest candle by default. If the specified\n    length exceeds the available candles, it will evaluate all candles.\n\n    Args:\n        candles (Indicator | Hexital | List[Candle]): The data source containing the indicators.\n        indicator (str): The name of the indicator to evaluate.\n        length (int, optional): The number of candles to include in the range. Defaults to 4.\n        index (int, optional): The index to start the evaluation. Defaults to -1 (latest candle).\n\n    Returns:\n        float | None: The difference between the minimum and maximum indicator values in the range,\n        or `None` if there are insufficient readings.\n    \"\"\"\n    candle_set = _retrieve_candles(candles, indicator)\n    if not isinstance(candle_set, list) or not candle_set:\n        return None\n\n    readings = get_readings_period(candle_set, indicator, length, index, True)\n\n    if len(readings) &lt; 2:\n        return None\n\n    return abs(min(readings) - max(readings))\n</code></pre>"},{"location":"reference/hexital/analysis/patterns/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> patterns","text":""},{"location":"reference/hexital/analysis/patterns/#hexital.analysis.patterns","title":"patterns","text":"<p>Functions:</p> Name Description <code>doji</code> <p>Doji Pattern</p> <code>dojistar</code> <p>Dojistar Pattern</p> <code>hammer</code> <p>Hammer Pattern</p> <code>inverted_hammer</code> <p>Inverted Hammer Pattern</p>"},{"location":"reference/hexital/analysis/patterns/#hexital.analysis.patterns.doji","title":"doji","text":"<pre><code>doji(\n    candles: List[Candle],\n    lookback: Optional[int] = None,\n    index: Optional[int] = None,\n) -&gt; bool\n</code></pre> <p>Doji Pattern A candle body is Doji when it's shorter than 10% of the average of the n(10) previous candles' high-low range.</p> <p>Source: https://github.com/TA-Lib/ta-lib</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Optional[int]</code> <p>Candles to use to find Doji Candle</p> required <code>lookback</code> <code>Optional[int]</code> <p>Lookback allows detecting an Doji candles N back. Defaults to None.</p> <code>None</code> <code>index</code> <code>Optional[int]</code> <p>Index of Candle to check. Defaults to None/Latest.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if given Candle/Candle range is Doji</p> Source code in <code>hexital/analysis/patterns.py</code> <pre><code>def doji(\n    candles: List[Candle],\n    lookback: Optional[int] = None,\n    index: Optional[int] = None,\n) -&gt; bool:\n    \"\"\"Doji Pattern\n    A candle body is Doji when it's shorter than 10% of the average of the\n    n(10) previous candles' high-low range.\n\n    Source: https://github.com/TA-Lib/ta-lib\n\n    Args:\n        candles (Optional[int]): Candles to use to find Doji Candle\n        lookback (Optional[int]): Lookback allows detecting an Doji candles N back. Defaults to None.\n        index (Optional[int]): Index of Candle to check. Defaults to None/Latest.\n\n    Returns:\n        bool: True if given Candle/Candle range is Doji\n    \"\"\"\n    index_ = absindex(index, len(candles))\n\n    if lookback is None:\n        return _doji(candles, index_)\n\n    return any(_doji(candles, i) for i in range(len(candles) - lookback, len(candles)))\n</code></pre>"},{"location":"reference/hexital/analysis/patterns/#hexital.analysis.patterns.dojistar","title":"dojistar","text":"<pre><code>dojistar(\n    candles: List[Candle],\n    lookback: Optional[int] = None,\n    index: Optional[int] = None,\n) -&gt; bool\n</code></pre> <p>Dojistar Pattern A Dojistar is either bearish or bullish, and is detected when we have a larger then average candle followed by a candle candle shorter than 10% of the average of the n(10) of the average and then the candle gaps up or down. A trend is required to find which direction.</p> <p>Source: https://github.com/TA-Lib/ta-lib Args:     candles (Optional[int]): Candles to use to find Dojistar Candle     lookback (Optional[int]): Lookback allows detecting an Dojistar candles N back. Defaults to None.     index (Optional[int]): Index of Candle to check. Defaults to None/Latest.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if given Candle/Candle range is Doji star</p> Source code in <code>hexital/analysis/patterns.py</code> <pre><code>def dojistar(\n    candles: List[Candle],\n    lookback: Optional[int] = None,\n    index: Optional[int] = None,\n) -&gt; bool:\n    \"\"\"Dojistar Pattern\n    A Dojistar is either bearish or bullish, and is detected when we have a larger then average\n    candle followed by a candle candle shorter than 10% of the average of the\n    n(10) of the average and then the candle gaps up or down.\n    A trend is required to find which direction.\n\n    Source: https://github.com/TA-Lib/ta-lib\n    Args:\n        candles (Optional[int]): Candles to use to find Dojistar Candle\n        lookback (Optional[int]): Lookback allows detecting an Dojistar candles N back. Defaults to None.\n        index (Optional[int]): Index of Candle to check. Defaults to None/Latest.\n\n    Returns:\n        bool: True if given Candle/Candle range is Doji star\n    \"\"\"\n    index_ = absindex(index, len(candles))\n\n    if lookback is None:\n        return _dojistar(candles, index_)\n\n    return any(_dojistar(candles, i) for i in range(len(candles) - lookback, len(candles)))\n</code></pre>"},{"location":"reference/hexital/analysis/patterns/#hexital.analysis.patterns.hammer","title":"hammer","text":"<pre><code>hammer(\n    candles: List[Candle],\n    lookback: Optional[int] = None,\n    index: Optional[int] = None,\n) -&gt; bool | int\n</code></pre> <p>Hammer Pattern A Hammer is detected when the Candle's open and close values are considered shorter than 10% of the average of the n(10) candles. However the low is larger than the average.</p> <p>Source: https://github.com/TA-Lib/ta-lib Args:     candles (Optional[int]): Candles to use to find Hammer Candle     lookback (Optional[int]): Lookback allows detecting an Hammer candles N back. Defaults to None.     index (Optional[int]): Index of Candle to check. Defaults to None/Latest.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool | int</code> <p>True if given Candle/Candle range is Hammer</p> Source code in <code>hexital/analysis/patterns.py</code> <pre><code>def hammer(\n    candles: List[Candle],\n    lookback: Optional[int] = None,\n    index: Optional[int] = None,\n) -&gt; bool | int:\n    \"\"\"Hammer Pattern\n    A Hammer is detected when the Candle's open and close values are considered shorter\n    than 10% of the average of the n(10) candles. However the low is larger than the average.\n\n    Source: https://github.com/TA-Lib/ta-lib\n    Args:\n        candles (Optional[int]): Candles to use to find Hammer Candle\n        lookback (Optional[int]): Lookback allows detecting an Hammer candles N back. Defaults to None.\n        index (Optional[int]): Index of Candle to check. Defaults to None/Latest.\n\n    Returns:\n        bool: True if given Candle/Candle range is Hammer\n    \"\"\"\n    index_ = absindex(index, len(candles))\n\n    if lookback is None:\n        return _hammer(candles, index_)\n\n    return any(_hammer(candles, i) for i in range(len(candles) - lookback, len(candles)))\n</code></pre>"},{"location":"reference/hexital/analysis/patterns/#hexital.analysis.patterns.inverted_hammer","title":"inverted_hammer","text":"<pre><code>inverted_hammer(\n    candles: List[Candle],\n    lookback: Optional[int] = None,\n    index: Optional[int] = None,\n) -&gt; bool | int\n</code></pre> <p>Inverted Hammer Pattern An Inverted Hammer is detected when the Candle's open and close values are considered shorter than 10% of the average of the n(10) candles. However the high is larger than the average.</p> <p>Source: https://github.com/TA-Lib/ta-lib Args:     candles (Optional[int]): Candles to use to find Inverted Hammer Candle     lookback (Optional[int]): Lookback allows detecting an InvertedHammer candles N back. Defaults to None.     index (Optional[int]): Index of Candle to check. Defaults to None/Latest.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool | int</code> <p>True if given Candle/Candle range is Inverted Hammer</p> Source code in <code>hexital/analysis/patterns.py</code> <pre><code>def inverted_hammer(\n    candles: List[Candle],\n    lookback: Optional[int] = None,\n    index: Optional[int] = None,\n) -&gt; bool | int:\n    \"\"\"Inverted Hammer Pattern\n    An Inverted Hammer is detected when the Candle's open and close values are considered shorter\n    than 10% of the average of the n(10) candles. However the high is larger than the average.\n\n    Source: https://github.com/TA-Lib/ta-lib\n    Args:\n        candles (Optional[int]): Candles to use to find Inverted Hammer Candle\n        lookback (Optional[int]): Lookback allows detecting an InvertedHammer candles N back. Defaults to None.\n        index (Optional[int]): Index of Candle to check. Defaults to None/Latest.\n\n    Returns:\n        bool: True if given Candle/Candle range is Inverted Hammer\n    \"\"\"\n    index_ = absindex(index, len(candles))\n\n    if lookback is None:\n        return _inverted_hammer(candles, index_)\n\n    return any(_inverted_hammer(candles, i) for i in range(len(candles) - lookback, len(candles)))\n</code></pre>"},{"location":"reference/hexital/analysis/utils/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> utils","text":""},{"location":"reference/hexital/analysis/utils/#hexital.analysis.utils","title":"utils","text":"<p>Functions:</p> Name Description <code>candle_bodydoji</code> <p>A real body is like doji's body when it's shorter than 10% the average of the 10 previous candles' high-low range</p> <code>candle_bodylong</code> <p>A real body is long when it's longer than the average of the 10 previous candles' real body</p> <code>candle_bodyshort</code> <p>real body is short when it's shorter than the average of the 10 previous candles' real bodies</p> <code>candle_bodyverylong</code> <p>A real body is very long when it's longer than 3 times the average of the 10 previous candles' real body</p> <code>candle_equal</code> <p>when measuring distance between parts of candles or width of gaps</p> <code>candle_far</code> <p>when measuring distance between parts of candles or width of gaps</p> <code>candle_near</code> <p>when measuring distance between parts of candles or width of gaps</p> <code>candle_shadow_long</code> <p>shadow is long when it's longer than the real body</p> <code>candle_shadow_short</code> <p>shadow is short when it's shorter than half the average of the 10 previous candles' sum of shadows</p> <code>candle_shadow_verylong</code> <p>shadow is very long when it's longer than 2 times the real body</p> <code>candle_shadow_veryshort</code> <p>shadow is very short when it's shorter than 10% the average of the 10 previous candles' high-low range</p> <code>high_low_avg</code> <p>Computes the average of the high-low range over a specified number of candles,</p> <code>highest</code> <p>Computes the highest value of the specified <code>name</code> over a given range of candles.</p> <code>lowest</code> <p>Computes the lowest value of the specified <code>indicator</code> over a given range of candles.</p> <code>realbody_avg</code> <p>Computes the average real body of a specified number of candles, including the current candle.</p> <code>realbody_gapdown</code> <p>Computes if a candle has a real body gap-down compared to a previous candle.</p> <code>realbody_gapup</code> <p>Computes if a candle has a real body gap-up compared to a previous candle.</p> <code>shadow_lower_avg</code> <p>Computes the average lower shadow over a specified number of candles, including the current candle.</p> <code>shadow_upper_avg</code> <p>Computes the average upper shadow over a specified number of candles, including the current candle.</p>"},{"location":"reference/hexital/analysis/utils/#hexital.analysis.utils.candle_bodydoji","title":"candle_bodydoji","text":"<pre><code>candle_bodydoji(\n    candles: List[Candle], index: Optional[int] = None, length: int = 10\n) -&gt; float\n</code></pre> <p>A real body is like doji's body when it's shorter than 10% the average of the 10 previous candles' high-low range</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>10% of the average of the 'length' previous candles' high-low range</p> Source code in <code>hexital/analysis/utils.py</code> <pre><code>def candle_bodydoji(candles: List[Candle], index: Optional[int] = None, length: int = 10) -&gt; float:\n    \"\"\"A real body is like doji's body when it's shorter than 10% the average of the 10 previous candles' high-low range\n\n    Returns:\n        float: 10% of the average of the 'length' previous candles' high-low range\n    \"\"\"\n    return _high_low_percentage(candles, index=index, length=length, percentage=0.1)\n</code></pre>"},{"location":"reference/hexital/analysis/utils/#hexital.analysis.utils.candle_bodylong","title":"candle_bodylong","text":"<pre><code>candle_bodylong(\n    candles: List[Candle], index: Optional[int] = None, length: int = 10\n) -&gt; float\n</code></pre> <p>A real body is long when it's longer than the average of the 10 previous candles' real body</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Average of the 'length' previous candles' real body</p> Source code in <code>hexital/analysis/utils.py</code> <pre><code>def candle_bodylong(candles: List[Candle], index: Optional[int] = None, length: int = 10) -&gt; float:\n    \"\"\"A real body is long when it's longer than the average of the 10 previous candles' real body\n\n    Returns:\n        float: Average of the 'length' previous candles' real body\"\"\"\n    return _realbody_percentage(candles, index=index, length=length)\n</code></pre>"},{"location":"reference/hexital/analysis/utils/#hexital.analysis.utils.candle_bodyshort","title":"candle_bodyshort","text":"<pre><code>candle_bodyshort(\n    candles: List[Candle], index: Optional[int] = None, length: int = 10\n) -&gt; float\n</code></pre> <p>real body is short when it's shorter than the average of the 10 previous candles' real bodies</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Average of the 'length' previous candles' real body</p> Source code in <code>hexital/analysis/utils.py</code> <pre><code>def candle_bodyshort(\n    candles: List[Candle], index: Optional[int] = None, length: int = 10\n) -&gt; float:\n    \"\"\"real body is short when it's shorter than the average of the 10 previous candles' real bodies\n\n    Returns:\n        float: Average of the 'length' previous candles' real body\"\"\"\n    return _realbody_percentage(candles, index=index, length=length)\n</code></pre>"},{"location":"reference/hexital/analysis/utils/#hexital.analysis.utils.candle_bodyverylong","title":"candle_bodyverylong","text":"<pre><code>candle_bodyverylong(\n    candles: List[Candle], index: Optional[int] = None, length: int = 10\n) -&gt; float\n</code></pre> <p>A real body is very long when it's longer than 3 times the average of the 10 previous candles' real body</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Average of the 'length' previous candles' real body multiplied by 3</p> Source code in <code>hexital/analysis/utils.py</code> <pre><code>def candle_bodyverylong(\n    candles: List[Candle], index: Optional[int] = None, length: int = 10\n) -&gt; float:\n    \"\"\"A real body is very long when it's longer than 3 times the average of the 10 previous candles' real body\n\n    Returns:\n        float: Average of the 'length' previous candles' real body multiplied by 3\"\"\"\n    return _realbody_percentage(candles, index=index, length=length, percentage=3)\n</code></pre>"},{"location":"reference/hexital/analysis/utils/#hexital.analysis.utils.candle_equal","title":"candle_equal","text":"<pre><code>candle_equal(\n    candles: List[Candle], index: Optional[int] = None, length: int = 5\n) -&gt; float\n</code></pre> <p>when measuring distance between parts of candles or width of gaps equal means \"&lt;= 5% of the average of the 5 previous candles' high-low range</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>5% the average of the 'length' previous candles' high-low range</p> Source code in <code>hexital/analysis/utils.py</code> <pre><code>def candle_equal(candles: List[Candle], index: Optional[int] = None, length: int = 5) -&gt; float:\n    \"\"\"when measuring distance between parts of candles or width of gaps\n    equal means \"&lt;= 5% of the average of the 5 previous candles' high-low range\n\n    Returns:\n        float: 5% the average of the 'length' previous candles' high-low range\"\"\"\n    return _high_low_percentage(candles, index=index, length=length, percentage=0.05)\n</code></pre>"},{"location":"reference/hexital/analysis/utils/#hexital.analysis.utils.candle_far","title":"candle_far","text":"<pre><code>candle_far(\n    candles: List[Candle], index: Optional[int] = None, length: int = 5\n) -&gt; float\n</code></pre> <p>when measuring distance between parts of candles or width of gaps far means \"&gt;= 60% of the average of the 5 previous candles' high-low range</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>60% the average of the 'length' previous candles' high-low range</p> Source code in <code>hexital/analysis/utils.py</code> <pre><code>def candle_far(candles: List[Candle], index: Optional[int] = None, length: int = 5) -&gt; float:\n    \"\"\"when measuring distance between parts of candles or width of gaps\n    far means \"&gt;= 60% of the average of the 5 previous candles' high-low range\n\n    Returns:\n        float: 60% the average of the 'length' previous candles' high-low range\"\"\"\n    return _high_low_percentage(candles, index=index, length=length, percentage=0.6)\n</code></pre>"},{"location":"reference/hexital/analysis/utils/#hexital.analysis.utils.candle_near","title":"candle_near","text":"<pre><code>candle_near(\n    candles: List[Candle], index: Optional[int] = None, length: int = 5\n) -&gt; float\n</code></pre> <p>when measuring distance between parts of candles or width of gaps near means \"&lt;= 20% of the average of the 5 previous candles' high-low range\"</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>20% the average of the 'length' previous candles' high-low range</p> Source code in <code>hexital/analysis/utils.py</code> <pre><code>def candle_near(candles: List[Candle], index: Optional[int] = None, length: int = 5) -&gt; float:\n    \"\"\"when measuring distance between parts of candles or width of gaps\n    near means \"&lt;= 20% of the average of the 5 previous candles' high-low range\"\n\n    Returns:\n        float: 20% the average of the 'length' previous candles' high-low range\"\"\"\n    return _high_low_percentage(candles, index=index, length=length, percentage=0.2)\n</code></pre>"},{"location":"reference/hexital/analysis/utils/#hexital.analysis.utils.candle_shadow_long","title":"candle_shadow_long","text":"<pre><code>candle_shadow_long(candles: List[Candle], index: Optional[int] = None) -&gt; float\n</code></pre> <p>shadow is long when it's longer than the real body</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Candle's realbody</p> Source code in <code>hexital/analysis/utils.py</code> <pre><code>def candle_shadow_long(candles: List[Candle], index: Optional[int] = None) -&gt; float:\n    \"\"\"shadow is long when it's longer than the real body\n\n    Returns:\n        float: Candle's realbody\"\"\"\n    return candles[index if index is not None else -1].realbody\n</code></pre>"},{"location":"reference/hexital/analysis/utils/#hexital.analysis.utils.candle_shadow_short","title":"candle_shadow_short","text":"<pre><code>candle_shadow_short(\n    candles: List[Candle], index: Optional[int] = None, length: int = 10\n) -&gt; float\n</code></pre> <p>shadow is short when it's shorter than half the average of the 10 previous candles' sum of shadows</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Average of the 'length' previous candles' high-low range</p> Source code in <code>hexital/analysis/utils.py</code> <pre><code>def candle_shadow_short(\n    candles: List[Candle], index: Optional[int] = None, length: int = 10\n) -&gt; float:\n    \"\"\"shadow is short when it's shorter than half the average of the 10 previous candles' sum of shadows\n\n    Returns:\n        float: Average of the 'length' previous candles' high-low range\"\"\"\n    return _high_low_percentage(candles, index=index, length=length)\n</code></pre>"},{"location":"reference/hexital/analysis/utils/#hexital.analysis.utils.candle_shadow_verylong","title":"candle_shadow_verylong","text":"<pre><code>candle_shadow_verylong(\n    candles: List[Candle], index: Optional[int] = None\n) -&gt; float\n</code></pre> <p>shadow is very long when it's longer than 2 times the real body</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Candle's realbody multiplied by 2</p> Source code in <code>hexital/analysis/utils.py</code> <pre><code>def candle_shadow_verylong(candles: List[Candle], index: Optional[int] = None) -&gt; float:\n    \"\"\"shadow is very long when it's longer than 2 times the real body\n\n    Returns:\n        float: Candle's realbody multiplied by 2\"\"\"\n    return candles[index if index is not None else -1].realbody * 2\n</code></pre>"},{"location":"reference/hexital/analysis/utils/#hexital.analysis.utils.candle_shadow_veryshort","title":"candle_shadow_veryshort","text":"<pre><code>candle_shadow_veryshort(\n    candles: List[Candle], index: Optional[int] = None, length: int = 10\n) -&gt; float\n</code></pre> <p>shadow is very short when it's shorter than 10% the average of the 10 previous candles' high-low range</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>10% the average of the 'length' previous candles' high-low range</p> Source code in <code>hexital/analysis/utils.py</code> <pre><code>def candle_shadow_veryshort(\n    candles: List[Candle], index: Optional[int] = None, length: int = 10\n) -&gt; float:\n    \"\"\"shadow is very short when it's shorter than 10% the average of the 10 previous candles' high-low range\n\n    Returns:\n        float: 10% the average of the 'length' previous candles' high-low range\"\"\"\n    return _high_low_percentage(candles, index=index, length=length, percentage=0.1)\n</code></pre>"},{"location":"reference/hexital/analysis/utils/#hexital.analysis.utils.high_low_avg","title":"high_low_avg","text":"<pre><code>high_low_avg(\n    candles: List[Candle], length: int, index: Optional[int] = None\n) -&gt; float\n</code></pre> <p>Computes the average of the high-low range over a specified number of candles, including the current candle. The high-low range is the difference between a candle's high and low prices.</p> Source code in <code>hexital/analysis/utils.py</code> <pre><code>def high_low_avg(candles: List[Candle], length: int, index: Optional[int] = None) -&gt; float:\n    \"\"\"\n    Computes the average of the high-low range over a specified number of candles,\n    including the current candle. The high-low range is the difference between a candle's\n    high and low prices.\n    \"\"\"\n    index = absindex(index, len(candles)) + 1\n    start_index = 0 if index - length &lt; 0 else index - length\n\n    return sum(candles[i].high_low for i in range(start_index, index)) / length\n</code></pre>"},{"location":"reference/hexital/analysis/utils/#hexital.analysis.utils.highest","title":"highest","text":"<pre><code>highest(\n    candles: List[Candle], name: str, length: int, index: Optional[int] = None\n) -&gt; float | None\n</code></pre> <p>Computes the highest value of the specified <code>name</code> over a given range of candles. The range includes the latest candle by default and considers up to the specified number of candles.</p> Source code in <code>hexital/analysis/utils.py</code> <pre><code>def highest(\n    candles: List[Candle], name: str, length: int, index: Optional[int] = None\n) -&gt; float | None:\n    \"\"\"\n    Computes the highest value of the specified `name` over a given range of candles.\n    The range includes the latest candle by default and considers up to the specified number of candles.\n    \"\"\"\n    if not candles:\n        return None\n\n    readings = get_readings_period(candles, name, length, absindex(index, len(candles)), True)\n    return max(readings, default=None)\n</code></pre>"},{"location":"reference/hexital/analysis/utils/#hexital.analysis.utils.lowest","title":"lowest","text":"<pre><code>lowest(\n    candles: List[Candle], name: str, length: int, index: Optional[int] = None\n) -&gt; float | None\n</code></pre> <p>Computes the lowest value of the specified <code>indicator</code> over a given range of candles. The range includes the latest candle by default and considers up to the specified number of candles.</p> Source code in <code>hexital/analysis/utils.py</code> <pre><code>def lowest(\n    candles: List[Candle], name: str, length: int, index: Optional[int] = None\n) -&gt; float | None:\n    \"\"\"\n    Computes the lowest value of the specified `indicator` over a given range of candles.\n    The range includes the latest candle by default and considers up to the specified number of candles.\n    \"\"\"\n    if not candles:\n        return None\n\n    readings = get_readings_period(candles, name, length, absindex(index, len(candles)), True)\n    return min(readings, default=None)\n</code></pre>"},{"location":"reference/hexital/analysis/utils/#hexital.analysis.utils.realbody_avg","title":"realbody_avg","text":"<pre><code>realbody_avg(\n    candles: List[Candle], length: int, index: Optional[int] = None\n) -&gt; float\n</code></pre> <p>Computes the average real body of a specified number of candles, including the current candle. The real body is calculated as the absolute difference between a candle's open and close prices.</p> Source code in <code>hexital/analysis/utils.py</code> <pre><code>def realbody_avg(candles: List[Candle], length: int, index: Optional[int] = None) -&gt; float:\n    \"\"\"\n    Computes the average real body of a specified number of candles, including the current candle.\n    The real body is calculated as the absolute difference between a candle's open and close prices.\n    \"\"\"\n    index = absindex(index, len(candles)) + 1\n    start_index = 0 if index - length &lt; 0 else index - length\n\n    return sum(candles[i].realbody for i in range(start_index, index)) / length\n</code></pre>"},{"location":"reference/hexital/analysis/utils/#hexital.analysis.utils.realbody_gapdown","title":"realbody_gapdown","text":"<pre><code>realbody_gapdown(candle: Candle, candle_two: Candle) -&gt; bool\n</code></pre> <p>Computes if a candle has a real body gap-down compared to a previous candle. A gap-down occurs when the maximum value of the current candle's real body (i.e., the higher of its open or close) is less than the minimum value of the previous candle's real body (i.e., the lower of its open or close).</p> Source code in <code>hexital/analysis/utils.py</code> <pre><code>def realbody_gapdown(candle: Candle, candle_two: Candle) -&gt; bool:\n    \"\"\"\n    Computes if a candle has a real body gap-down compared to a previous candle.\n    A gap-down occurs when the maximum value of the current candle's real body\n    (i.e., the higher of its open or close) is less than the minimum value\n    of the previous candle's real body (i.e., the lower of its open or close).\n    \"\"\"\n    return max(candle.open, candle.close) &lt; min(candle_two.open, candle_two.close)\n</code></pre>"},{"location":"reference/hexital/analysis/utils/#hexital.analysis.utils.realbody_gapup","title":"realbody_gapup","text":"<pre><code>realbody_gapup(candle: Candle, candle_two: Candle) -&gt; bool\n</code></pre> <p>Computes if a candle has a real body gap-up compared to a previous candle. A gap-up occurs when the minimum value of the current candle's real body (i.e., the lower of its open or close) is greater than the maximum value of the previous candle's real body (i.e., the higher of its open or close).</p> Source code in <code>hexital/analysis/utils.py</code> <pre><code>def realbody_gapup(candle: Candle, candle_two: Candle) -&gt; bool:\n    \"\"\"\n    Computes if a candle has a real body gap-up compared to a previous candle.\n    A gap-up occurs when the minimum value of the current candle's real body\n    (i.e., the lower of its open or close) is greater than the maximum value\n    of the previous candle's real body (i.e., the higher of its open or close).\n    \"\"\"\n    return min(candle.open, candle.close) &gt; max(candle_two.open, candle_two.close)\n</code></pre>"},{"location":"reference/hexital/analysis/utils/#hexital.analysis.utils.shadow_lower_avg","title":"shadow_lower_avg","text":"<pre><code>shadow_lower_avg(\n    candles: List[Candle], length: int, index: Optional[int] = None\n) -&gt; float\n</code></pre> <p>Computes the average lower shadow over a specified number of candles, including the current candle. The lower shadow is the difference between a candle's high price and either its open or close price.</p> Source code in <code>hexital/analysis/utils.py</code> <pre><code>def shadow_lower_avg(candles: List[Candle], length: int, index: Optional[int] = None) -&gt; float:\n    \"\"\"\n    Computes the average lower shadow over a specified number of candles, including the current candle.\n    The lower shadow is the difference between a candle's high price and either its open or close price.\n    \"\"\"\n    index = absindex(index, len(candles)) + 1\n    start_index = 0 if index - length &lt; 0 else index - length\n\n    return sum(candles[i].shadow_lower for i in range(start_index, index)) / length\n</code></pre>"},{"location":"reference/hexital/analysis/utils/#hexital.analysis.utils.shadow_upper_avg","title":"shadow_upper_avg","text":"<pre><code>shadow_upper_avg(\n    candles: List[Candle], length: int, index: Optional[int] = None\n) -&gt; float\n</code></pre> <p>Computes the average upper shadow over a specified number of candles, including the current candle. The upper shadow is the difference between a candle's high price and either its open or close price.</p> Source code in <code>hexital/analysis/utils.py</code> <pre><code>def shadow_upper_avg(candles: List[Candle], length: int, index: Optional[int] = None) -&gt; float:\n    \"\"\"\n    Computes the average upper shadow over a specified number of candles, including the current candle.\n    The upper shadow is the difference between a candle's high price and either its open or close price.\n    \"\"\"\n    index = absindex(index, len(candles)) + 1\n    start_index = 0 if index - length &lt; 0 else index - length\n\n    return sum(candles[i].shadow_upper for i in range(start_index, index)) / length\n</code></pre>"},{"location":"reference/hexital/candlesticks/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> candlesticks","text":""},{"location":"reference/hexital/candlesticks/#hexital.candlesticks","title":"candlesticks","text":"<p>Modules:</p> Name Description <code>heikinashi</code>"},{"location":"reference/hexital/candlesticks/heikinashi/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> heikinashi","text":""},{"location":"reference/hexital/candlesticks/heikinashi/#hexital.candlesticks.heikinashi","title":"heikinashi","text":"<p>Classes:</p> Name Description <code>HeikinAshi</code> <p>Heikin-Ashi</p>"},{"location":"reference/hexital/candlesticks/heikinashi/#hexital.candlesticks.heikinashi.HeikinAshi","title":"HeikinAshi","text":"<pre><code>HeikinAshi(candles: Optional[List[Candle]] = None)\n</code></pre> <p>               Bases: <code>CandlestickType</code></p> <p>Heikin-Ashi</p> <p>Heikin Ashi is a charting technique that can be used to predict future price movements. It is similar to traditional candlestick charts. However, unlike a regular candlestick chart, the Heikin Ashi chart tries to filter out some of the market noise by smoothing out strong price swings to better identify trend movements in the market.</p> Sources <p>https://www.investopedia.com/trading/heikin-ashi-better-candlestick/</p> <p>Methods:</p> Name Description <code>prev_derived</code> <p>Returns the previous derived Candle</p> <code>set_candle_refs</code> <p>Replace CandlestickType Candles to own by reference</p> <code>transform</code> <p>Transforms the Candle's into their candlestick type, using the given CalcMode.</p> <p>Attributes:</p> Name Type Description <code>index</code> <code>int</code> <p>Current derived_candles index off calculation</p> Source code in <code>hexital/core/candlestick_type.py</code> <pre><code>def __init__(self, candles: Optional[List[Candle]] = None):\n    self.candles = candles if candles else []\n    self.derived_candles = WeakList()\n</code></pre>"},{"location":"reference/hexital/candlesticks/heikinashi/#hexital.candlesticks.heikinashi.HeikinAshi.index","title":"index  <code>property</code>","text":"<pre><code>index: int\n</code></pre> <p>Current derived_candles index off calculation</p>"},{"location":"reference/hexital/candlesticks/heikinashi/#hexital.candlesticks.heikinashi.HeikinAshi.prev_derived","title":"prev_derived","text":"<pre><code>prev_derived(index: Optional[int] = None) -&gt; Candle | None\n</code></pre> <p>Returns the previous derived Candle</p> Source code in <code>hexital/core/candlestick_type.py</code> <pre><code>def prev_derived(self, index: Optional[int] = None) -&gt; Candle | None:\n    \"\"\"Returns the previous derived Candle\"\"\"\n    if not self.derived_candles:\n        return None\n\n    if index is not None:\n        return self.derived_candles[index]\n\n    if self._derived_idx == 0:\n        return None\n\n    return self.derived_candles[self._derived_idx - 1]\n</code></pre>"},{"location":"reference/hexital/candlesticks/heikinashi/#hexital.candlesticks.heikinashi.HeikinAshi.set_candle_refs","title":"set_candle_refs","text":"<pre><code>set_candle_refs(candles: List[Candle])\n</code></pre> <p>Replace CandlestickType Candles to own by reference</p> Source code in <code>hexital/core/candlestick_type.py</code> <pre><code>def set_candle_refs(self, candles: List[Candle]):\n    \"\"\"Replace CandlestickType Candles to own by reference\"\"\"\n    self.candles = candles\n</code></pre>"},{"location":"reference/hexital/candlesticks/heikinashi/#hexital.candlesticks.heikinashi.HeikinAshi.transform","title":"transform","text":"<pre><code>transform(mode: CalcMode = INSERT, index: Optional[int] = None)\n</code></pre> <p>Transforms the Candle's into their candlestick type, using the given CalcMode. INSERT: Fresh transformation, will re-transform all Candles. Slow APPEND: Will transform all Candles at the end that have no derived Candles PREPEND: Will transform all Candles from the start until hitting already Transformed candles</p> Source code in <code>hexital/core/candlestick_type.py</code> <pre><code>def transform(self, mode: CalcMode = CalcMode.INSERT, index: Optional[int] = None):\n    \"\"\"Transforms the Candle's into their candlestick type, using the given CalcMode.\n    INSERT: Fresh transformation, will re-transform all Candles. Slow\n    APPEND: Will transform all Candles at the end that have no derived Candles\n    PREPEND: Will transform all Candles from the start until hitting already Transformed candles\n    \"\"\"\n    if mode == CalcMode.INSERT:\n        start_index = 0\n    elif index is not None:\n        start_index = index\n    else:\n        start_index = self._find_transform_index()\n\n    self._derived_idx = len(self.derived_candles) if mode == CalcMode.APPEND else 0\n\n    if mode == CalcMode.INSERT:\n        self.derived_candles.reset()\n\n    for index in range(start_index, len(self.candles)):\n        candle = self.candles[index]\n\n        candles = self.transform_candle(candle)\n\n        # None Candles never added to derived\n        if not candles:\n            candle.refs[self.acronym] = None\n            continue\n\n        if candles := self._insert_derived_candles(candles):\n            candle.refs[self.acronym] = candles\n        else:\n            break\n</code></pre>"},{"location":"reference/hexital/core/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> core","text":""},{"location":"reference/hexital/core/#hexital.core","title":"core","text":"<p>Modules:</p> Name Description <code>candle</code> <code>candle_manager</code> <code>candlestick_type</code> <code>hexital</code> <code>indicator</code>"},{"location":"reference/hexital/core/candle/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> candle","text":""},{"location":"reference/hexital/core/candle/#hexital.core.candle","title":"candle","text":"<p>Classes:</p> Name Description <code>Candle</code>"},{"location":"reference/hexital/core/candle/#hexital.core.candle.Candle","title":"Candle","text":"<pre><code>Candle(\n    open: float,\n    high: float,\n    low: float,\n    close: float,\n    volume: int,\n    timestamp: Optional[datetime | str] = None,\n    timeframe: Optional[TimeFramesSource] = None,\n    indicators: Optional[Dict[str, Reading]] = None,\n    sub_indicators: Optional[Dict[str, Reading]] = None,\n)\n</code></pre> <p>Methods:</p> Name Description <code>as_dict</code> <p>Generates a dict of values from the OHLCV values, with  the following keys:</p> <code>as_list</code> <p>Generates a list of values from the OHLCV values.</p> <code>from_dict</code> <p>Create a <code>Candle</code> object from a dictionary representation.</p> <code>from_dicts</code> <p>Create's a list of <code>Candle</code> object's from a list of dictionary representation.</p> <code>from_list</code> <p>Create a <code>Candle</code> object from a list representation.</p> <code>from_lists</code> <p>Create a list of <code>Candle</code> object's from a list of list representation.</p> <code>merge</code> <p>Merge another <code>Candle</code> object into the current candle.</p> Source code in <code>hexital/core/candle.py</code> <pre><code>def __init__(\n    self,\n    open: float,\n    high: float,\n    low: float,\n    close: float,\n    volume: int,\n    timestamp: Optional[datetime | str] = None,  # End of Candle\n    timeframe: Optional[TimeFramesSource] = None,\n    indicators: Optional[Dict[str, Reading]] = None,\n    sub_indicators: Optional[Dict[str, Reading]] = None,\n):\n    self.open = open\n    self.high = high\n    self.low = low\n    self.close = close\n    self.volume = volume\n    self.timeframe = convert_timeframe_to_timedelta(timeframe) if timeframe else None\n\n    self.tag = None\n    self.aggregation_factor = 1\n\n    if isinstance(timestamp, datetime):\n        self.timestamp = timestamp\n    elif isinstance(timestamp, str):\n        self.timestamp = datetime.fromisoformat(timestamp)\n    else:\n        self.timestamp = None\n\n    self.refs = {}\n    self.indicators = indicators if indicators else {}\n    self.sub_indicators = sub_indicators if sub_indicators else {}\n</code></pre>"},{"location":"reference/hexital/core/candle/#hexital.core.candle.Candle.as_dict","title":"as_dict","text":"<pre><code>as_dict(readings: bool = False) -&gt; dict\n</code></pre> <p>Generates a dict of values from the OHLCV values, with  the following keys: <code>[timestamp, open, high, low, close, volume]</code></p> <p>Parameters:</p> Name Type Description Default <code>readings</code> <code>bool</code> <p>Include Candle readings</p> <code>False</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A list of the <code>Candle</code> values</p> <code>dict</code> <p>{open, high, low, close, volume, timestamp, timeframe*}</p> <code>dict</code> <p>{open, high, low, close, volume, timestamp, indicators, sub_indicators, timeframe*}</p> Source code in <code>hexital/core/candle.py</code> <pre><code>def as_dict(self, readings: bool = False) -&gt; dict:\n    \"\"\"\n    Generates a dict of values from the OHLCV values, with  the following keys:\n    `[timestamp, open, high, low, close, volume]`\n\n    Args:\n        readings (bool): Include Candle readings\n\n    Returns:\n        dict: A list of the `Candle` values\n        {open, high, low, close, volume, timestamp, timeframe*}\n        {open, high, low, close, volume, timestamp, indicators, sub_indicators, timeframe*}\n    \"\"\"\n    cdl = {\n        \"open\": self.open,\n        \"high\": self.high,\n        \"low\": self.low,\n        \"close\": self.close,\n        \"volume\": self.volume,\n        \"timestamp\": self.timestamp,\n    }\n\n    if self.timeframe:\n        cdl[\"timeframe\"] = self.timeframe\n\n    if readings:\n        cdl[\"indicators\"] = self.indicators\n        cdl[\"sub_indicators\"] = self.sub_indicators\n\n    return cdl\n</code></pre>"},{"location":"reference/hexital/core/candle/#hexital.core.candle.Candle.as_list","title":"as_list","text":"<pre><code>as_list(readings: bool = False) -&gt; list\n</code></pre> <p>Generates a list of values from the OHLCV values. <code>[timestamp, open, high, low, close, volume]</code> in that order. With an optional <code>timedelta</code> value at the end being the <code>timeframe</code></p> <p>Parameters:</p> Name Type Description Default <code>readings</code> <code>bool</code> <p>Include Candle readings</p> <code>False</code> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of the <code>Candle</code> values;</p> <code>list</code> <p>[timestamp, open, high, low, close, volume, timeframe*]</p> <code>list</code> <p>[timestamp, open, high, low, close, volume, indicators, sub_indicators, timeframe*]</p> Source code in <code>hexital/core/candle.py</code> <pre><code>def as_list(self, readings: bool = False) -&gt; list:\n    \"\"\"\n    Generates a list of values from the OHLCV values.\n    `[timestamp, open, high, low, close, volume]` in that order.\n    With an optional `timedelta` value at the end being the `timeframe`\n\n    Args:\n        readings (bool): Include Candle readings\n\n    Returns:\n        list: A list of the `Candle` values;\n        [timestamp, open, high, low, close, volume, timeframe*]\n        [timestamp, open, high, low, close, volume, indicators, sub_indicators, timeframe*]\n    \"\"\"\n    cdl = [self.timestamp, self.open, self.high, self.low, self.close, self.volume]\n\n    if readings:\n        cdl.append(self.indicators)\n        cdl.append(self.sub_indicators)\n\n    cdl += [self.timeframe] if self.timeframe else []\n\n    return cdl\n</code></pre>"},{"location":"reference/hexital/core/candle/#hexital.core.candle.Candle.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(candle: Dict[str, Any]) -&gt; Candle\n</code></pre> <p>Create a <code>Candle</code> object from a dictionary representation.</p> <p>The dictionary is expected to have the following keys: - Required: 'open', 'high', 'low', 'close', 'volume' - Optional: 'timestamp' | 'time' | 'date' - Optional: 'timeframe', 'indicators', 'sub_indicators'</p> <p>The method extracts the values for these keys. If the optional keys for time ('timestamp', 'time', etc.) are present, the first match is used as the timestamp.</p> <p>Parameters:</p> Name Type Description Default <code>candle</code> <code>Dict[str, Any]</code> <p>A dictionary containing the candle data.</p> required <p>Returns:</p> Name Type Description <code>Candle</code> <code>Candle</code> <p>A <code>Candle</code> object initialized with the provided dictionary data.</p> Source code in <code>hexital/core/candle.py</code> <pre><code>@classmethod\ndef from_dict(cls, candle: Dict[str, Any]) -&gt; Candle:\n    \"\"\"\n    Create a `Candle` object from a dictionary representation.\n\n    The dictionary is expected to have the following keys:\n    - Required: 'open', 'high', 'low', 'close', 'volume'\n    - Optional: 'timestamp' | 'time' | 'date'\n    - Optional: 'timeframe', 'indicators', 'sub_indicators'\n\n    The method extracts the values for these keys. If the optional keys for time ('timestamp',\n    'time', etc.) are present, the first match is used as the timestamp.\n\n    Args:\n        candle (Dict[str, Any]): A dictionary containing the candle data.\n\n    Returns:\n        Candle: A `Candle` object initialized with the provided dictionary data.\n    \"\"\"\n    timestamp = [\n        v\n        for k, v in candle.items()\n        if k in [\"timestamp\", \"Timestamp\", \"time\", \"Time\", \"date\", \"Date\"]\n    ]\n\n    if timestamp and not isinstance(timestamp[0], (datetime, str)):\n        raise TypeError(\"Timestamp must be native python Datetime object\")\n\n    return cls(\n        candle.get(\"open\", candle.get(\"Open\", 0.0)),\n        candle.get(\"high\", candle.get(\"High\", 0.0)),\n        candle.get(\"low\", candle.get(\"Low\", 0.0)),\n        candle.get(\"close\", candle.get(\"Close\", 0.0)),\n        candle.get(\"volume\", candle.get(\"Volume\", 0)),\n        indicators=candle.get(\"indicators\", {}),\n        sub_indicators=candle.get(\"sub_indicators\", {}),\n        timestamp=timestamp[0] if timestamp else None,\n        timeframe=candle.get(\"timeframe\", candle.get(\"Timeframe\")),\n    )\n</code></pre>"},{"location":"reference/hexital/core/candle/#hexital.core.candle.Candle.from_dicts","title":"from_dicts  <code>classmethod</code>","text":"<pre><code>from_dicts(candles: Sequence[Dict[str, Any]]) -&gt; List[Candle]\n</code></pre> <p>Create's a list of <code>Candle</code> object's from a list of dictionary representation.</p> <p>Each dictionary is expected to have the following keys: - Required: 'open', 'high', 'low', 'close', 'volume' - Optional: 'timestamp' | 'time' | 'date' - Optional: 'timeframe', 'indicators', 'sub_indicators'</p> <p>The method extracts the values for these keys. If the optional keys for time ('timestamp', 'time', etc.) are present, the first match is used as the timestamp. Returning a list of <code>Candle</code> objects initialized with the provided dictionary data.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>List[Dict[str, Any]]</code> <p>A dictionary containing the candle data.</p> required <p>Returns:</p> Type Description <code>List[Candle]</code> <p>List[Candle]: A list of <code>Candle</code> object's.</p> Source code in <code>hexital/core/candle.py</code> <pre><code>@classmethod\ndef from_dicts(cls, candles: Sequence[Dict[str, Any]]) -&gt; List[Candle]:\n    \"\"\"\n    Create's a list of `Candle` object's from a list of dictionary representation.\n\n    Each dictionary is expected to have the following keys:\n    - Required: 'open', 'high', 'low', 'close', 'volume'\n    - Optional: 'timestamp' | 'time' | 'date'\n    - Optional: 'timeframe', 'indicators', 'sub_indicators'\n\n    The method extracts the values for these keys. If the optional keys for time ('timestamp',\n    'time', etc.) are present, the first match is used as the timestamp.\n    Returning a list of `Candle` objects initialized with the provided dictionary data.\n\n    Args:\n        candles (List[Dict[str, Any]]): A dictionary containing the candle data.\n\n    Returns:\n        List[Candle]: A list of `Candle` object's.\n    \"\"\"\n    return [cls.from_dict(candle) for candle in candles]\n</code></pre>"},{"location":"reference/hexital/core/candle/#hexital.core.candle.Candle.from_list","title":"from_list  <code>classmethod</code>","text":"<pre><code>from_list(candle: list) -&gt; Candle\n</code></pre> <p>Create a <code>Candle</code> object from a list representation.</p> <p>The list is expected to contain the following elements: - Required: <code>[open, high, low, close, volume]</code> in that order. - Optional: A <code>timestamp</code> at the beginning of the list. - Optional: A <code>timeframe</code> at the end of the list. - Optional: Dict's <code>indicators</code>, <code>sub_indicators</code> after Volume.</p> <p>If the first element is a <code>str</code> or <code>datetime</code>, it is treated as the <code>timestamp</code>. If the last element is a <code>str</code>, <code>int</code>, <code>TimeFrame</code>, or <code>timedelta</code>, it is treated as the <code>timeframe</code>.</p> <p>Parameters:</p> Name Type Description Default <code>candle</code> <code>list</code> <p>A list containing the candle data.</p> required <p>Returns:</p> Name Type Description <code>Candle</code> <code>Candle</code> <p>A <code>Candle</code> object initialized with the data from the list.</p> Source code in <code>hexital/core/candle.py</code> <pre><code>@classmethod\ndef from_list(cls, candle: list) -&gt; Candle:\n    \"\"\"\n    Create a `Candle` object from a list representation.\n\n    The list is expected to contain the following elements:\n    - Required: `[open, high, low, close, volume]` in that order.\n    - Optional: A `timestamp` at the beginning of the list.\n    - Optional: A `timeframe` at the end of the list.\n    - Optional: Dict's `indicators`, `sub_indicators` after Volume.\n\n    If the first element is a `str` or `datetime`, it is treated as the `timestamp`.\n    If the last element is a `str`, `int`, `TimeFrame`, or `timedelta`, it is treated as the `timeframe`.\n\n    Args:\n        candle (list): A list containing the candle data.\n\n    Returns:\n        Candle: A `Candle` object initialized with the data from the list.\n    \"\"\"\n    timestamp = None\n    timeframe = None\n    indicators = {}\n    sub_indicators = {}\n\n    if len(candle) &gt; 5 and (isinstance(candle[0], (str, datetime)) or candle[0] is None):\n        timestamp = candle.pop(0)\n    if len(candle) &gt; 5 and isinstance(candle[-1], (str, int, TimeFrame, timedelta)):\n        timeframe = candle.pop(-1)\n    if len(candle) &gt; 5 and isinstance(candle[-1], dict):\n        sub_indicators = candle.pop(-1)\n        indicators = candle.pop(-1)\n\n    return cls(\n        open=candle[0],\n        high=candle[1],\n        low=candle[2],\n        close=candle[3],\n        volume=candle[4],\n        indicators=indicators,\n        sub_indicators=sub_indicators,\n        timestamp=timestamp,\n        timeframe=timeframe,\n    )\n</code></pre>"},{"location":"reference/hexital/core/candle/#hexital.core.candle.Candle.from_lists","title":"from_lists  <code>classmethod</code>","text":"<pre><code>from_lists(candles: List[list]) -&gt; List[Candle]\n</code></pre> <p>Create a list of <code>Candle</code> object's from a list of list representation.</p> <p>Each list is expected to contain the following elements: - Required: <code>[open, high, low, close, volume]</code> in that order. - Optional: A <code>timestamp</code> at the beginning of the list. - Optional: A <code>timeframe</code> at the end of the list. - Optional: Dict's <code>indicators</code>, <code>sub_indicators</code> after Volume.</p> <p>If the first element is a <code>str</code> or <code>datetime</code>, it is treated as the <code>timestamp</code>. If the last element is a <code>str</code>, <code>int</code>, <code>TimeFrame</code>, or <code>timedelta</code>, it is treated as the <code>timeframe</code>.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>List[list]</code> <p>A list of list's containing the candle data.</p> required <p>Returns:</p> Type Description <code>List[Candle]</code> <p>List[Candle]: A list of <code>Candle</code> object's.</p> Source code in <code>hexital/core/candle.py</code> <pre><code>@classmethod\ndef from_lists(cls, candles: List[list]) -&gt; List[Candle]:\n    \"\"\"\n    Create a list of `Candle` object's from a list of list representation.\n\n    Each list is expected to contain the following elements:\n    - Required: `[open, high, low, close, volume]` in that order.\n    - Optional: A `timestamp` at the beginning of the list.\n    - Optional: A `timeframe` at the end of the list.\n    - Optional: Dict's `indicators`, `sub_indicators` after Volume.\n\n    If the first element is a `str` or `datetime`, it is treated as the `timestamp`.\n    If the last element is a `str`, `int`, `TimeFrame`, or `timedelta`, it is treated as the `timeframe`.\n\n    Args:\n        candles (List[list]): A list of list's containing the candle data.\n\n    Returns:\n        List[Candle]: A list of `Candle` object's.\n    \"\"\"\n    return [cls.from_list(candle) for candle in candles]\n</code></pre>"},{"location":"reference/hexital/core/candle/#hexital.core.candle.Candle.merge","title":"merge","text":"<pre><code>merge(candle: Candle)\n</code></pre> <p>Merge another <code>Candle</code> object into the current candle.</p> <p>This method updates the current candle by integrating data from the provided <code>candle</code>. It ensures that the merged values respect the timeframe boundaries and adjusts attributes such as open, high, low, close, volume, and timestamps accordingly.</p> <p>Note: - Any calculated indicators will be wiped, as merging modifies the core candle values. - Any conversion or derived values associated with the candle will also be removed.</p> <p>Parameters:</p> Name Type Description Default <code>candle</code> <code>Candle</code> <p>The <code>Candle</code> object to merge into the current candle.</p> required Behaviour <ul> <li>Adjusts the <code>open</code> if the merged candle's timestamp is earlier than the start timestamp.</li> <li>Updates the <code>close</code> if the merged candle's timestamp is more recent.</li> <li>Updates <code>high</code> and <code>low</code> based on the maximum and minimum values of the two candles.</li> <li>Increases the <code>volume</code> by the volume of the merged candle.</li> <li>Increments the <code>aggregation_factor</code> to account for the merged data.</li> <li>Resets calculated indicators and cleans any derived values.</li> </ul> Source code in <code>hexital/core/candle.py</code> <pre><code>def merge(self, candle: Candle):\n    \"\"\"\n    Merge another `Candle` object into the current candle.\n\n    This method updates the current candle by integrating data from the provided `candle`.\n    It ensures that the merged values respect the timeframe boundaries and adjusts\n    attributes such as open, high, low, close, volume, and timestamps accordingly.\n\n    **Note:**\n    - Any calculated indicators will be wiped, as merging modifies the core candle values.\n    - Any conversion or derived values associated with the candle will also be removed.\n\n    Args:\n        candle (Candle): The `Candle` object to merge into the current candle.\n\n    Behaviour:\n        - Adjusts the `open` if the merged candle's timestamp is earlier than the start timestamp.\n        - Updates the `close` if the merged candle's timestamp is more recent.\n        - Updates `high` and `low` based on the maximum and minimum values of the two candles.\n        - Increases the `volume` by the volume of the merged candle.\n        - Increments the `aggregation_factor` to account for the merged data.\n        - Resets calculated indicators and cleans any derived values.\n    \"\"\"\n    if self.timestamp is None or candle.timestamp is None:\n        self.high = max(self.high, candle.high)\n        self.low = min(self.low, candle.low)\n        self.close = candle.close\n        return\n\n    if self.timeframe:\n        if (candle.timestamp + self.timeframe &gt; self.timestamp + self.timeframe) or (\n            candle.timestamp &lt; self.timestamp - self.timeframe\n        ):\n            return\n\n    if self._start_timestamp and candle.timestamp &lt; self._start_timestamp:\n        self.open = candle.open\n        if not self._end_timestamp:\n            self._end_timestamp = self._start_timestamp\n        self._start_timestamp = candle.timestamp\n    elif (\n        self._start_timestamp\n        and not self._end_timestamp\n        and candle.timestamp &gt; self._start_timestamp\n    ):\n        self.close = candle.close\n        self._end_timestamp = candle.timestamp\n    elif (\n        self._start_timestamp\n        and self._end_timestamp\n        and candle.timestamp &gt; self._end_timestamp\n    ):\n        self.close = candle.close\n        self._end_timestamp = candle.timestamp\n    elif (\n        self._start_timestamp\n        and self._end_timestamp\n        and self._start_timestamp &gt; candle.timestamp &gt; self._end_timestamp\n    ):\n        pass\n    else:\n        self.close = candle.close\n\n    self.high = max(self.high, candle.high)\n    self.low = min(self.low, candle.low)\n    self.volume += candle.volume\n    self.aggregation_factor += candle.aggregation_factor\n\n    self.reset_candle()\n</code></pre>"},{"location":"reference/hexital/core/candle_manager/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> candle_manager","text":""},{"location":"reference/hexital/core/candle_manager/#hexital.core.candle_manager","title":"candle_manager","text":"<p>Classes:</p> Name Description <code>CandleManager</code>"},{"location":"reference/hexital/core/candle_manager/#hexital.core.candle_manager.CandleManager","title":"CandleManager","text":"<pre><code>CandleManager(\n    candles: Optional[List[Candle]] = None,\n    candle_life: Optional[timedelta] = None,\n    timeframe: Optional[timedelta] = None,\n    timeframe_fill: bool = False,\n    candlestick: Optional[CandlestickType] = None,\n)\n</code></pre> <p>Methods:</p> Name Description <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>resample_candles</code> <p>resamples the given list of candles into specific timeframe candles.</p> <code>sort_candles</code> <p>Sorts Candles in order of timestamp, accounts for collapsing</p> Source code in <code>hexital/core/candle_manager.py</code> <pre><code>def __init__(\n    self,\n    candles: Optional[List[Candle]] = None,\n    candle_life: Optional[timedelta] = None,\n    timeframe: Optional[timedelta] = None,\n    timeframe_fill: bool = False,\n    candlestick: Optional[CandlestickType] = None,\n):\n    self.candle_life = candle_life\n    self.timeframe = timeframe\n    self.timeframe_fill = timeframe_fill\n    self._candles = candles if candles else []\n\n    if candlestick:\n        self.candlestick = candlestick\n        self.candlestick.set_candle_refs(self._candles)\n\n    if self._candles:\n        self._candle_tasks()\n</code></pre>"},{"location":"reference/hexital/core/candle_manager/#hexital.core.candle_manager.CandleManager.purge","title":"purge","text":"<pre><code>purge(indicator: str | Set[str])\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/candle_manager.py</code> <pre><code>def purge(self, indicator: str | Set[str]):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    if isinstance(indicator, str):\n        indicator = {indicator}\n\n    for candle in self.candles:\n        for name in indicator:\n            candle.indicators.pop(name, None)\n            candle.sub_indicators.pop(name, None)\n</code></pre>"},{"location":"reference/hexital/core/candle_manager/#hexital.core.candle_manager.CandleManager.resample_candles","title":"resample_candles","text":"<pre><code>resample_candles(mode: CalcMode, index: Optional[int] = None)\n</code></pre> <p>resamples the given list of candles into specific timeframe candles. This can re-ran with same list to resample latest candles. This method is destructive, generating a new list for the resampled candles</p> Source code in <code>hexital/core/candle_manager.py</code> <pre><code>def resample_candles(\n    self,\n    mode: CalcMode,\n    index: Optional[int] = None,\n):\n    \"\"\"resamples the given list of candles into specific timeframe candles.\n    This can re-ran with same list to resample latest candles.\n    This method is destructive, generating a new list for the resampled candles\"\"\"\n    if mode == CalcMode.INSERT:\n        start_index = 0\n    elif index is not None:\n        start_index = index\n    else:\n        start_index = self._find_resample_index()\n\n    if len(self._candles) &lt;= start_index + 1 or not self.timeframe:\n        return\n\n    end_index = len(self._candles)\n\n    candles_ = [self._candles.pop(start_index)]\n\n    init_candle = candles_[0]\n    init_candle.timeframe = self.timeframe\n    if not init_candle.timestamp:\n        return\n\n    start_time = round_down_timestamp(init_candle.timestamp, self.timeframe)\n    end_time = start_time + self.timeframe\n\n    if not on_timeframe(init_candle.timestamp, self.timeframe):\n        init_candle.set_resampled_timestamp(end_time)\n\n    for _ in range(abs(end_index - start_index)):\n        if len(self._candles) &lt;= start_index:\n            break\n\n        candle = self._candles.pop(start_index)\n        prev_candle = candles_[-1]\n\n        if not candle.timestamp:\n            return\n\n        if (\n            mode != CalcMode.INSERT\n            and candle.timeframe == self.timeframe\n            and prev_candle.timeframe == self.timeframe\n        ):\n            candles_.append(candle)\n            break\n\n        next_end_time = end_time + self.timeframe\n        candle.timestamp = trim_timestamp(candle.timestamp)\n        candle.timeframe = self.timeframe\n\n        if start_time &lt; candle.timestamp &lt;= end_time and prev_candle.timestamp == end_time:\n            prev_candle.merge(candle)\n        elif (\n            start_time - self.timeframe &lt; candle.timestamp &lt;= start_time\n            and prev_candle.timestamp == start_time\n        ):\n            prev_candle.merge(candle)\n        elif start_time &lt; candle.timestamp &lt;= end_time:\n            candle.set_resampled_timestamp(end_time)\n            candles_.append(candle)\n        elif end_time &lt; candle.timestamp &lt;= next_end_time:\n            candle.set_resampled_timestamp(next_end_time)\n            candles_.append(candle)\n            start_time = end_time\n            end_time = next_end_time\n        elif start_time &lt; candle.timestamp and on_timeframe(candle.timestamp, self.timeframe):\n            start_time = round_down_timestamp(candle.timestamp, self.timeframe)\n            end_time = start_time + self.timeframe\n            candle.set_resampled_timestamp(start_time)\n            candles_.append(candle)\n        elif next_end_time &lt; candle.timestamp:\n            start_time = round_down_timestamp(candle.timestamp, self.timeframe)\n            end_time = start_time + self.timeframe\n            candle.set_resampled_timestamp(end_time)\n            candles_.append(candle)\n        else:\n            # Shit's fucked yo\n            raise InvalidCandleOrder(\n                f\"Failed to resample_candles due to invalid candle order prev: [{prev_candle}] - current: [{candle}]\",\n            )\n\n    if self.timeframe_fill:\n        candles_ = self._fill_timeframe_candles(\n            candles_, self.timeframe, start_index, end_index\n        )\n\n    self._candles[start_index:start_index] = candles_\n</code></pre>"},{"location":"reference/hexital/core/candle_manager/#hexital.core.candle_manager.CandleManager.sort_candles","title":"sort_candles","text":"<pre><code>sort_candles(candles: Optional[List[Candle]] = None)\n</code></pre> <p>Sorts Candles in order of timestamp, accounts for collapsing</p> Source code in <code>hexital/core/candle_manager.py</code> <pre><code>def sort_candles(self, candles: Optional[List[Candle]] = None):\n    \"\"\"Sorts Candles in order of timestamp, accounts for collapsing\"\"\"\n    if candles:\n        candles.sort(key=cmp_to_key(self._sort_comparison))\n    else:\n        self._candles.sort(key=cmp_to_key(self._sort_comparison))\n</code></pre>"},{"location":"reference/hexital/core/candlestick_type/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> candlestick_type","text":""},{"location":"reference/hexital/core/candlestick_type/#hexital.core.candlestick_type","title":"candlestick_type","text":"<p>Classes:</p> Name Description <code>CandlestickType</code>"},{"location":"reference/hexital/core/candlestick_type/#hexital.core.candlestick_type.CandlestickType","title":"CandlestickType","text":"<pre><code>CandlestickType(candles: Optional[List[Candle]] = None)\n</code></pre> <p>               Bases: <code>ABC</code></p> <p>Methods:</p> Name Description <code>prev_derived</code> <p>Returns the previous derived Candle</p> <code>set_candle_refs</code> <p>Replace CandlestickType Candles to own by reference</p> <code>transform</code> <p>Transforms the Candle's into their candlestick type, using the given CalcMode.</p> <p>Attributes:</p> Name Type Description <code>index</code> <code>int</code> <p>Current derived_candles index off calculation</p> Source code in <code>hexital/core/candlestick_type.py</code> <pre><code>def __init__(self, candles: Optional[List[Candle]] = None):\n    self.candles = candles if candles else []\n    self.derived_candles = WeakList()\n</code></pre>"},{"location":"reference/hexital/core/candlestick_type/#hexital.core.candlestick_type.CandlestickType.index","title":"index  <code>property</code>","text":"<pre><code>index: int\n</code></pre> <p>Current derived_candles index off calculation</p>"},{"location":"reference/hexital/core/candlestick_type/#hexital.core.candlestick_type.CandlestickType.prev_derived","title":"prev_derived","text":"<pre><code>prev_derived(index: Optional[int] = None) -&gt; Candle | None\n</code></pre> <p>Returns the previous derived Candle</p> Source code in <code>hexital/core/candlestick_type.py</code> <pre><code>def prev_derived(self, index: Optional[int] = None) -&gt; Candle | None:\n    \"\"\"Returns the previous derived Candle\"\"\"\n    if not self.derived_candles:\n        return None\n\n    if index is not None:\n        return self.derived_candles[index]\n\n    if self._derived_idx == 0:\n        return None\n\n    return self.derived_candles[self._derived_idx - 1]\n</code></pre>"},{"location":"reference/hexital/core/candlestick_type/#hexital.core.candlestick_type.CandlestickType.set_candle_refs","title":"set_candle_refs","text":"<pre><code>set_candle_refs(candles: List[Candle])\n</code></pre> <p>Replace CandlestickType Candles to own by reference</p> Source code in <code>hexital/core/candlestick_type.py</code> <pre><code>def set_candle_refs(self, candles: List[Candle]):\n    \"\"\"Replace CandlestickType Candles to own by reference\"\"\"\n    self.candles = candles\n</code></pre>"},{"location":"reference/hexital/core/candlestick_type/#hexital.core.candlestick_type.CandlestickType.transform","title":"transform","text":"<pre><code>transform(mode: CalcMode = INSERT, index: Optional[int] = None)\n</code></pre> <p>Transforms the Candle's into their candlestick type, using the given CalcMode. INSERT: Fresh transformation, will re-transform all Candles. Slow APPEND: Will transform all Candles at the end that have no derived Candles PREPEND: Will transform all Candles from the start until hitting already Transformed candles</p> Source code in <code>hexital/core/candlestick_type.py</code> <pre><code>def transform(self, mode: CalcMode = CalcMode.INSERT, index: Optional[int] = None):\n    \"\"\"Transforms the Candle's into their candlestick type, using the given CalcMode.\n    INSERT: Fresh transformation, will re-transform all Candles. Slow\n    APPEND: Will transform all Candles at the end that have no derived Candles\n    PREPEND: Will transform all Candles from the start until hitting already Transformed candles\n    \"\"\"\n    if mode == CalcMode.INSERT:\n        start_index = 0\n    elif index is not None:\n        start_index = index\n    else:\n        start_index = self._find_transform_index()\n\n    self._derived_idx = len(self.derived_candles) if mode == CalcMode.APPEND else 0\n\n    if mode == CalcMode.INSERT:\n        self.derived_candles.reset()\n\n    for index in range(start_index, len(self.candles)):\n        candle = self.candles[index]\n\n        candles = self.transform_candle(candle)\n\n        # None Candles never added to derived\n        if not candles:\n            candle.refs[self.acronym] = None\n            continue\n\n        if candles := self._insert_derived_candles(candles):\n            candle.refs[self.acronym] = candles\n        else:\n            break\n</code></pre>"},{"location":"reference/hexital/core/hexital/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> hexital","text":""},{"location":"reference/hexital/core/hexital/#hexital.core.hexital","title":"hexital","text":"<p>Classes:</p> Name Description <code>Hexital</code>"},{"location":"reference/hexital/core/hexital/#hexital.core.hexital.Hexital","title":"Hexital","text":"<pre><code>Hexital(\n    name: str,\n    candles: Sequence[Candle],\n    indicators: Optional[\n        Sequence[Dict[str, Any] | Indicator] | IndicatorCollection\n    ] = None,\n    description: Optional[str] = None,\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n)\n</code></pre> <p>Methods:</p> Name Description <code>add_indicator</code> <p>Add's a new indicator to <code>Hexital</code> strategy.</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Hexital Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculates all the missing indicator readings.</p> <code>calculate_index</code> <p>Calculate specific index for all or specific indicator readings.</p> <code>candles</code> <p>Get a set of candles by using either a Timeframe or Indicator name</p> <code>exists</code> <p>Checks if the given Indicator has a valid reading in latest Candle</p> <code>indicator</code> <p>Searches hexital's indicator's and Returns the Indicator object itself.</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Hexital Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Hexital Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Takes Indicator name and removes all readings for said indicator.</p> <code>reading</code> <p>Attempts to retrieve a reading with a given Indicator name.</p> <code>reading_as_list</code> <p>Find given indicator and returns the readings as a list</p> <code>readings</code> <p>Returns a Dictionary of all the Indicators and there results in a list format.</p> <code>recalculate</code> <p>Purge's all indicator reading's and re-calculates them all,</p> <code>remove_indicator</code> <p>Removes an indicator from running within hexital</p> <p>Attributes:</p> Name Type Description <code>indicator_settings</code> <code>List[dict]</code> <p>Simply get's a list of all the Indicators within Hexital strategy</p> Source code in <code>hexital/core/hexital.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    candles: Sequence[Candle],\n    indicators: Optional[Sequence[Dict[str, Any] | Indicator] | IndicatorCollection] = None,\n    description: Optional[str] = None,\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n):\n    self.name = name\n    self.description = description\n\n    self._timeframe = convert_timeframe_to_timedelta(timeframe)\n    self.timeframe_fill = timeframe_fill\n    self.candle_life = candle_life\n\n    self.candlestick = validate_candlesticktype(candlestick) if candlestick else None\n\n    manager = CandleManager(\n        candles if isinstance(candles, list) else [],\n        candle_life=self.candle_life,\n        timeframe=self._timeframe,\n        timeframe_fill=self.timeframe_fill,\n        candlestick=self.candlestick,\n    )\n\n    self._default_name = manager.name\n    self._candle_map = {manager.name: manager}\n\n    if not indicators:\n        self._indicators = {}\n    elif isinstance(indicators, IndicatorCollection):\n        self._indicators = self._validate_indicators(indicators.collection_list())\n    else:\n        self._indicators = self._validate_indicators(indicators)\n</code></pre>"},{"location":"reference/hexital/core/hexital/#hexital.core.hexital.Hexital.indicator_settings","title":"indicator_settings  <code>property</code>","text":"<pre><code>indicator_settings: List[dict]\n</code></pre> <p>Simply get's a list of all the Indicators within Hexital strategy</p>"},{"location":"reference/hexital/core/hexital/#hexital.core.hexital.Hexital.add_indicator","title":"add_indicator","text":"<pre><code>add_indicator(\n    indicator: Indicator | List[Indicator | Dict[str, Any]] | Dict[str, Any]\n)\n</code></pre> <p>Add's a new indicator to <code>Hexital</code> strategy. This accept either <code>Indicator</code> datatypes or dict string versions to be packed. <code>add_indicator(SMA(period=10))</code> or <code>add_indicator({\"indicator\": \"SMA\", \"period\": 10})</code> Does not automatically calculates readings.</p> Source code in <code>hexital/core/hexital.py</code> <pre><code>def add_indicator(\n    self, indicator: Indicator | List[Indicator | Dict[str, Any]] | Dict[str, Any]\n):\n    \"\"\"Add's a new indicator to `Hexital` strategy.\n    This accept either `Indicator` datatypes or dict string versions to be packed.\n    `add_indicator(SMA(period=10))` or `add_indicator({\"indicator\": \"SMA\", \"period\": 10})`\n    Does not automatically calculates readings.\"\"\"\n    indicators = indicator if isinstance(indicator, list) else [indicator]\n\n    for name, valid_indicator in self._validate_indicators(indicators).items():\n        self._indicators[name] = valid_indicator\n</code></pre>"},{"location":"reference/hexital/core/hexital/#hexital.core.hexital.Hexital.append","title":"append","text":"<pre><code>append(candles: Candles, timeframe: Optional[TimeFramesSource] = None)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Hexital Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required <code>timeframe</code> <code>Optional[TimeFramesSource]</code> <p>A specific timeframe to insert Candle's into</p> <code>None</code> Source code in <code>hexital/core/hexital.py</code> <pre><code>def append(\n    self,\n    candles: Candles,\n    timeframe: Optional[TimeFramesSource] = None,\n):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Hexital Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n        timeframe: A specific timeframe to insert Candle's into\n    \"\"\"\n    timeframe_name = self._parse_timeframe(timeframe)\n\n    if timeframe_name and self._candle_map.get(timeframe_name):\n        self._candle_map[timeframe_name].append(candles)\n    else:\n        for candle_manager in self._candle_map.values():\n            candle_manager.append(candles)\n\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/core/hexital/#hexital.core.hexital.Hexital.calculate","title":"calculate","text":"<pre><code>calculate(name: Optional[str] = None)\n</code></pre> <p>Calculates all the missing indicator readings.</p> Source code in <code>hexital/core/hexital.py</code> <pre><code>def calculate(self, name: Optional[str] = None):\n    \"\"\"Calculates all the missing indicator readings.\"\"\"\n    for indicator_name, indicator in self._indicators.items():\n        if name is None or indicator_name == name:\n            indicator.calculate()\n</code></pre>"},{"location":"reference/hexital/core/hexital/#hexital.core.hexital.Hexital.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(\n    name: Optional[str] = None, index: int = -1, end_index: Optional[int] = None\n)\n</code></pre> <p>Calculate specific index for all or specific indicator readings.</p> Source code in <code>hexital/core/hexital.py</code> <pre><code>def calculate_index(\n    self, name: Optional[str] = None, index: int = -1, end_index: Optional[int] = None\n):\n    \"\"\"Calculate specific index for all or specific indicator readings.\"\"\"\n    for indicator_name, indicator in self._indicators.items():\n        if name is None or indicator_name == name:\n            indicator.calculate_index(index, end_index)\n</code></pre>"},{"location":"reference/hexital/core/hexital/#hexital.core.hexital.Hexital.candles","title":"candles","text":"<pre><code>candles(name: Optional[TimeFramesSource] = None) -&gt; List[Candle]\n</code></pre> <p>Get a set of candles by using either a Timeframe or Indicator name</p> Source code in <code>hexital/core/hexital.py</code> <pre><code>def candles(self, name: Optional[TimeFramesSource] = None) -&gt; List[Candle]:\n    \"\"\"Get a set of candles by using either a Timeframe or Indicator name\"\"\"\n    name_ = name if name else self._default_name\n    timeframe_name = self._parse_timeframe(name)\n\n    name_ = timeframe_name if timeframe_name else name_\n\n    if isinstance(name_, str) and self._candle_map.get(name_, False):\n        return self._candle_map[name_].candles\n    elif isinstance(name_, str):\n        for manager in self._candle_map.values():\n            if manager.find_indicator(name_):\n                return manager.candles\n\n    return []\n</code></pre>"},{"location":"reference/hexital/core/hexital/#hexital.core.hexital.Hexital.exists","title":"exists","text":"<pre><code>exists(name: str) -&gt; bool\n</code></pre> <p>Checks if the given Indicator has a valid reading in latest Candle</p> Source code in <code>hexital/core/hexital.py</code> <pre><code>def exists(self, name: str) -&gt; bool:\n    \"\"\"Checks if the given Indicator has a valid reading in latest Candle\"\"\"\n    value = self.reading(name)\n    if isinstance(value, dict):\n        return any(v is not None for v in value.values())\n    return value is not None\n</code></pre>"},{"location":"reference/hexital/core/hexital/#hexital.core.hexital.Hexital.indicator","title":"indicator","text":"<pre><code>indicator(name: str) -&gt; Indicator | None\n</code></pre> <p>Searches hexital's indicator's and Returns the Indicator object itself.</p> Source code in <code>hexital/core/hexital.py</code> <pre><code>def indicator(self, name: str) -&gt; Indicator | None:\n    \"\"\"Searches hexital's indicator's and Returns the Indicator object itself.\"\"\"\n    return self._indicators.get(name)\n</code></pre>"},{"location":"reference/hexital/core/hexital/#hexital.core.hexital.Hexital.insert","title":"insert","text":"<pre><code>insert(candles: Candles, timeframe: Optional[TimeFramesSource] = None)\n</code></pre> <p>insert a Candle or a list of Candle's to the Hexital Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required <code>timeframe</code> <code>Optional[TimeFramesSource]</code> <p>A specific timeframe to insert Candle's into</p> <code>None</code> Source code in <code>hexital/core/hexital.py</code> <pre><code>def insert(\n    self,\n    candles: Candles,\n    timeframe: Optional[TimeFramesSource] = None,\n):\n    \"\"\"insert a Candle or a list of Candle's to the Hexital Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n        timeframe: A specific timeframe to insert Candle's into\n    \"\"\"\n    timeframe_name = self._parse_timeframe(timeframe)\n\n    if timeframe_name and self._candle_map.get(timeframe_name):\n        self._candle_map[timeframe_name].insert(candles)\n    else:\n        for candle_manager in self._candle_map.values():\n            candle_manager.insert(candles)\n\n    self.calculate_index(index=0, end_index=-1)\n</code></pre>"},{"location":"reference/hexital/core/hexital/#hexital.core.hexital.Hexital.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles, timeframe: Optional[TimeFramesSource] = None)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Hexital Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required <code>timeframe</code> <code>Optional[TimeFramesSource]</code> <p>A specific timeframe to insert Candle's into</p> <code>None</code> Source code in <code>hexital/core/hexital.py</code> <pre><code>def prepend(\n    self,\n    candles: Candles,\n    timeframe: Optional[TimeFramesSource] = None,\n):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Hexital Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n        timeframe: A specific timeframe to insert Candle's into\n    \"\"\"\n    timeframe_name = self._parse_timeframe(timeframe)\n\n    if timeframe_name and self._candle_map.get(timeframe_name):\n        self._candle_map[timeframe_name].prepend(candles)\n    else:\n        for candle_manager in self._candle_map.values():\n            candle_manager.prepend(candles)\n\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/core/hexital/#hexital.core.hexital.Hexital.purge","title":"purge","text":"<pre><code>purge(source: Optional[Source] = None)\n</code></pre> <p>Takes Indicator name and removes all readings for said indicator. Indicator name must be exact</p> Source code in <code>hexital/core/hexital.py</code> <pre><code>def purge(self, source: Optional[Source] = None):\n    \"\"\"Takes Indicator name and removes all readings for said indicator.\n    Indicator name must be exact\"\"\"\n    if not source:\n        for indicator in self._indicators.values():\n            indicator.purge()\n    elif indicator := self._find_indicator(source):\n        indicator.purge()\n</code></pre>"},{"location":"reference/hexital/core/hexital/#hexital.core.hexital.Hexital.reading","title":"reading","text":"<pre><code>reading(source: Source, index: int = -1) -&gt; Reading\n</code></pre> <p>Attempts to retrieve a reading with a given Indicator name. <code>name</code> can use '.' to find nested reading, E.G <code>MACD_12_26_9.MACD</code></p> Source code in <code>hexital/core/hexital.py</code> <pre><code>def reading(self, source: Source, index: int = -1) -&gt; Reading:\n    \"\"\"Attempts to retrieve a reading with a given Indicator name.\n    `name` can use '.' to find nested reading, E.G `MACD_12_26_9.MACD`\n    \"\"\"\n    return self._find_reading(source, index)\n</code></pre>"},{"location":"reference/hexital/core/hexital/#hexital.core.hexital.Hexital.reading_as_list","title":"reading_as_list","text":"<pre><code>reading_as_list(source: Source) -&gt; List[Reading]\n</code></pre> <p>Find given indicator and returns the readings as a list Full Name of the indicator E.G <code>EMA_12</code> OR <code>MACD_12_26_9.MACD</code></p> Source code in <code>hexital/core/hexital.py</code> <pre><code>def reading_as_list(self, source: Source) -&gt; List[Reading]:\n    \"\"\"Find given indicator and returns the readings as a list\n    Full Name of the indicator E.G `EMA_12` OR `MACD_12_26_9.MACD`\"\"\"\n    return self._find_readings(source)\n</code></pre>"},{"location":"reference/hexital/core/hexital/#hexital.core.hexital.Hexital.readings","title":"readings","text":"<pre><code>readings() -&gt; Dict[str, List[Reading]]\n</code></pre> <p>Returns a Dictionary of all the Indicators and there results in a list format.</p> Source code in <code>hexital/core/hexital.py</code> <pre><code>def readings(self) -&gt; Dict[str, List[Reading]]:\n    \"\"\"Returns a Dictionary of all the Indicators and there results in a list format.\"\"\"\n    return {name: indicator.readings() for name, indicator in self._indicators.items()}\n</code></pre>"},{"location":"reference/hexital/core/hexital/#hexital.core.hexital.Hexital.recalculate","title":"recalculate","text":"<pre><code>recalculate(source: Optional[Source] = None)\n</code></pre> <p>Purge's all indicator reading's and re-calculates them all, ideal for changing an indicator parameters midway.</p> Source code in <code>hexital/core/hexital.py</code> <pre><code>def recalculate(self, source: Optional[Source] = None):\n    \"\"\"Purge's all indicator reading's and re-calculates them all,\n    ideal for changing an indicator parameters midway.\"\"\"\n    if not source:\n        for indicator in self._indicators.values():\n            indicator.purge()\n            indicator.calculate()\n    elif indicator := self._find_indicator(source):\n        indicator.purge()\n        indicator.calculate()\n</code></pre>"},{"location":"reference/hexital/core/hexital/#hexital.core.hexital.Hexital.remove_indicator","title":"remove_indicator","text":"<pre><code>remove_indicator(source: Source)\n</code></pre> <p>Removes an indicator from running within hexital</p> Source code in <code>hexital/core/hexital.py</code> <pre><code>def remove_indicator(self, source: Source):\n    \"\"\"Removes an indicator from running within hexital\"\"\"\n    indicator = self._find_indicator(source)\n    if not indicator:\n        return\n\n    indicator.purge()\n    self._indicators.pop(indicator.name)\n</code></pre>"},{"location":"reference/hexital/core/indicator/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> indicator","text":""},{"location":"reference/hexital/core/indicator/#hexital.core.indicator","title":"indicator","text":"<p>Classes:</p> Name Description <code>Indicator</code> <code>Managed</code> <p>Managed</p>"},{"location":"reference/hexital/core/indicator/#hexital.core.indicator.Indicator","title":"Indicator  <code>dataclass</code>","text":"<pre><code>Indicator(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4\n)\n</code></pre> <p>               Bases: <code>Generic[V]</code>, <code>ABC</code></p> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/core/indicator/#hexital.core.indicator.Indicator.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/core/indicator/#hexital.core.indicator.Indicator.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/core/indicator/#hexital.core.indicator.Indicator.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/core/indicator/#hexital.core.indicator.Indicator.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/core/indicator/#hexital.core.indicator.Indicator.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/core/indicator/#hexital.core.indicator.Indicator.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/core/indicator/#hexital.core.indicator.Indicator.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/core/indicator/#hexital.core.indicator.Indicator.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/core/indicator/#hexital.core.indicator.Indicator.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/core/indicator/#hexital.core.indicator.Indicator.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/core/indicator/#hexital.core.indicator.Indicator.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/core/indicator/#hexital.core.indicator.Indicator.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/core/indicator/#hexital.core.indicator.Indicator.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/core/indicator/#hexital.core.indicator.Indicator.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/core/indicator/#hexital.core.indicator.Indicator.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/core/indicator/#hexital.core.indicator.Managed","title":"Managed  <code>dataclass</code>","text":"<pre><code>Managed(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    _active_index: int = 0\n)\n</code></pre> <p>               Bases: <code>Indicator</code></p> <p>Managed</p> <p>Empty Indicator thats manually controlled and the reading manually set.</p> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/core/indicator/#hexital.core.indicator.Managed.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/core/indicator/#hexital.core.indicator.Managed.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/core/indicator/#hexital.core.indicator.Managed.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/core/indicator/#hexital.core.indicator.Managed.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/core/indicator/#hexital.core.indicator.Managed.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/core/indicator/#hexital.core.indicator.Managed.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/core/indicator/#hexital.core.indicator.Managed.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/core/indicator/#hexital.core.indicator.Managed.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/core/indicator/#hexital.core.indicator.Managed.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/core/indicator/#hexital.core.indicator.Managed.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/core/indicator/#hexital.core.indicator.Managed.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/core/indicator/#hexital.core.indicator.Managed.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/core/indicator/#hexital.core.indicator.Managed.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/core/indicator/#hexital.core.indicator.Managed.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/core/indicator/#hexital.core.indicator.Managed.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/core/indicator_collection/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> indicator_collection","text":""},{"location":"reference/hexital/core/indicator_collection/#hexital.core.indicator_collection","title":"indicator_collection","text":""},{"location":"reference/hexital/indicators/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> indicators","text":""},{"location":"reference/hexital/indicators/#hexital.indicators","title":"indicators","text":"<p>Modules:</p> Name Description <code>adx</code> <code>amorph</code> <code>aroon</code> <code>atr</code> <code>bbands</code> <code>cmo</code> <code>counter</code> <code>donchian</code> <code>ema</code> <code>highest_lowest</code> <code>hla</code> <code>hlca</code> <code>hma</code> <code>jma</code> <code>kc</code> <code>macd</code> <code>mfi</code> <code>midpoint</code> <code>obv</code> <code>pivot_points</code> <code>rma</code> <code>roc</code> <code>rsi</code> <code>rvi</code> <code>sma</code> <code>stdev</code> <code>stdevthres</code> <code>stoch</code> <code>supertrend</code> <code>tr</code> <code>tsi</code> <code>vwap</code> <code>vwma</code> <code>wma</code>"},{"location":"reference/hexital/indicators/adx/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> adx","text":""},{"location":"reference/hexital/indicators/adx/#hexital.indicators.adx","title":"adx","text":"<p>Classes:</p> Name Description <code>ADX</code> <p>Average Directional Index - ADX</p>"},{"location":"reference/hexital/indicators/adx/#hexital.indicators.adx.ADX","title":"ADX  <code>dataclass</code>","text":"<pre><code>ADX(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    period: int = 14,\n    period_signal: Optional[int] = None,\n    multiplier: float = 100.0\n)\n</code></pre> <p>               Bases: <code>Indicator[dict]</code></p> <p>Average Directional Index - ADX</p> <p>ADX is a trend strength in a series of prices of a financial instrument.</p> Sources <p>https://en.wikipedia.org/wiki/Average_directional_movement_index</p> <p>Output type: <code>Dict[\"ADX\": float, \"DM_Plus\": float, \"DM_Neg\": float]</code></p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>How many Periods to use. Defaults to 14</p> <code>14</code> <code>period_signal</code> <code>Optional[int]</code> <p>Average Directional Index period. Defaults same as period</p> <code>None</code> <code>multiplier</code> <code>Optional[float]</code> <p>ADX smoothing multiplier. Defaults to 100.0</p> <code>100.0</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/indicators/adx/#hexital.indicators.adx.ADX.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/indicators/adx/#hexital.indicators.adx.ADX.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/indicators/adx/#hexital.indicators.adx.ADX.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/indicators/adx/#hexital.indicators.adx.ADX.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/indicators/adx/#hexital.indicators.adx.ADX.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/adx/#hexital.indicators.adx.ADX.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/adx/#hexital.indicators.adx.ADX.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/adx/#hexital.indicators.adx.ADX.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/indicators/adx/#hexital.indicators.adx.ADX.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/adx/#hexital.indicators.adx.ADX.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/adx/#hexital.indicators.adx.ADX.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/indicators/adx/#hexital.indicators.adx.ADX.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/adx/#hexital.indicators.adx.ADX.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/adx/#hexital.indicators.adx.ADX.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/indicators/adx/#hexital.indicators.adx.ADX.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/amorph/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> amorph","text":""},{"location":"reference/hexital/indicators/amorph/#hexital.indicators.amorph","title":"amorph","text":"<p>Classes:</p> Name Description <code>Amorph</code> <p>Amorph</p>"},{"location":"reference/hexital/indicators/amorph/#hexital.indicators.amorph.Amorph","title":"Amorph","text":"<pre><code>Amorph(analysis: Callable, args: Optional[dict] = None, **kwargs)\n</code></pre> <p>               Bases: <code>Indicator</code></p> <p>Amorph</p> <p>Flexible Skeleton Indicator that will use a method to generate readings on every Candle like indicators.</p> <p>The given Method is expected to have 'candles' and 'index' as named arguments, EG:</p> <p>Input type Example: Doji</p> <p>Output type: Based on analysis method</p> <p>Parameters:</p> Name Type Description Default <code>analysis</code> <code>Callable</code> <p>Period to index back in</p> required <code>args</code> <code>Optional[dict]</code> <p>All of the Arguments as keyword arguments as a dict of keyword arguments for called analysis</p> <code>None</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Returns a dict format of how this indicator can be generated</p> Source code in <code>hexital/indicators/amorph.py</code> <pre><code>def __init__(self, analysis: Callable, args: Optional[dict] = None, **kwargs):\n    self._analysis_method = analysis\n    self.analysis_name = analysis.__name__\n    self._analysis_kwargs, kwargs = self._separate_indicator_attributes(kwargs)\n\n    if isinstance(args, dict):\n        self._analysis_kwargs.update(args)\n\n    super().__init__(**kwargs)\n</code></pre>"},{"location":"reference/hexital/indicators/amorph/#hexital.indicators.amorph.Amorph.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/indicators/amorph/#hexital.indicators.amorph.Amorph.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Returns a dict format of how this indicator can be generated</p>"},{"location":"reference/hexital/indicators/amorph/#hexital.indicators.amorph.Amorph.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/indicators/amorph/#hexital.indicators.amorph.Amorph.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/indicators/amorph/#hexital.indicators.amorph.Amorph.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/amorph/#hexital.indicators.amorph.Amorph.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/amorph/#hexital.indicators.amorph.Amorph.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/amorph/#hexital.indicators.amorph.Amorph.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/indicators/amorph/#hexital.indicators.amorph.Amorph.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/amorph/#hexital.indicators.amorph.Amorph.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/amorph/#hexital.indicators.amorph.Amorph.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/indicators/amorph/#hexital.indicators.amorph.Amorph.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/amorph/#hexital.indicators.amorph.Amorph.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/amorph/#hexital.indicators.amorph.Amorph.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/indicators/amorph/#hexital.indicators.amorph.Amorph.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/aroon/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> aroon","text":""},{"location":"reference/hexital/indicators/aroon/#hexital.indicators.aroon","title":"aroon","text":"<p>Classes:</p> Name Description <code>AROON</code> <p>Aroon - AROON</p>"},{"location":"reference/hexital/indicators/aroon/#hexital.indicators.aroon.AROON","title":"AROON  <code>dataclass</code>","text":"<pre><code>AROON(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    period: int = 14\n)\n</code></pre> <p>               Bases: <code>Indicator[dict]</code></p> <p>Aroon - AROON</p> <p>The Aroon indicator, indicates if a price is trending or is in a trading range. It can also reveal the beginning of a new trend, its strength and can help anticipate changes from trading ranges to trends.</p> Sources <p>https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/aroon-indicator</p> <p>Output type: <code>Dict[\"AROONU\": float, \"AROOND\": float, \"AROONOSC\": float]</code></p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>How many Periods to use. Defaults to 14</p> <code>14</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/indicators/aroon/#hexital.indicators.aroon.AROON.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/indicators/aroon/#hexital.indicators.aroon.AROON.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/indicators/aroon/#hexital.indicators.aroon.AROON.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/indicators/aroon/#hexital.indicators.aroon.AROON.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/indicators/aroon/#hexital.indicators.aroon.AROON.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/aroon/#hexital.indicators.aroon.AROON.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/aroon/#hexital.indicators.aroon.AROON.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/aroon/#hexital.indicators.aroon.AROON.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/indicators/aroon/#hexital.indicators.aroon.AROON.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/aroon/#hexital.indicators.aroon.AROON.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/aroon/#hexital.indicators.aroon.AROON.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/indicators/aroon/#hexital.indicators.aroon.AROON.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/aroon/#hexital.indicators.aroon.AROON.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/aroon/#hexital.indicators.aroon.AROON.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/indicators/aroon/#hexital.indicators.aroon.AROON.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/atr/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> atr","text":""},{"location":"reference/hexital/indicators/atr/#hexital.indicators.atr","title":"atr","text":"<p>Classes:</p> Name Description <code>ATR</code> <p>Average True Range - ATR</p>"},{"location":"reference/hexital/indicators/atr/#hexital.indicators.atr.ATR","title":"ATR  <code>dataclass</code>","text":"<pre><code>ATR(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    period: int = 14\n)\n</code></pre> <p>               Bases: <code>Indicator[float | None]</code></p> <p>Average True Range - ATR</p> <p>Average True Range is used to measure volatility, especially volatility caused by gaps or limit moves.</p> Sources <p>https://www.tradingview.com/wiki/Average_True_Range_(ATR)</p> <p>Output type: <code>float</code></p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>How many Periods to use. Defaults to 14</p> <code>14</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/indicators/atr/#hexital.indicators.atr.ATR.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/indicators/atr/#hexital.indicators.atr.ATR.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/indicators/atr/#hexital.indicators.atr.ATR.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/indicators/atr/#hexital.indicators.atr.ATR.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/indicators/atr/#hexital.indicators.atr.ATR.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/atr/#hexital.indicators.atr.ATR.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/atr/#hexital.indicators.atr.ATR.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/atr/#hexital.indicators.atr.ATR.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/indicators/atr/#hexital.indicators.atr.ATR.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/atr/#hexital.indicators.atr.ATR.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/atr/#hexital.indicators.atr.ATR.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/indicators/atr/#hexital.indicators.atr.ATR.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/atr/#hexital.indicators.atr.ATR.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/atr/#hexital.indicators.atr.ATR.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/indicators/atr/#hexital.indicators.atr.ATR.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/bbands/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> bbands","text":""},{"location":"reference/hexital/indicators/bbands/#hexital.indicators.bbands","title":"bbands","text":"<p>Classes:</p> Name Description <code>BBANDS</code> <p>Bollinger Bands - BBANDS</p>"},{"location":"reference/hexital/indicators/bbands/#hexital.indicators.bbands.BBANDS","title":"BBANDS  <code>dataclass</code>","text":"<pre><code>BBANDS(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    period: int = 5,\n    source: Source = \"close\"\n)\n</code></pre> <p>               Bases: <code>Indicator[dict]</code></p> <p>Bollinger Bands - BBANDS</p> <p>Bollinger Bands are a type of statistical chart characterizing the prices and volatility over time of a financial instrument or commodity, using a formulaic method.</p> Sources <p>https://www.britannica.com/money/bollinger-bands-indicator</p> <p>Output type: <code>Dict[\"BBL\": float, \"BBM\": float, \"BBU\": float]</code></p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>How many Periods to use. Defaults to 5</p> <code>5</code> <code>source</code> <code>str</code> <p>Which input field to calculate the Indicator. Defaults to \"close\"</p> <code>'close'</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/indicators/bbands/#hexital.indicators.bbands.BBANDS.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/indicators/bbands/#hexital.indicators.bbands.BBANDS.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/indicators/bbands/#hexital.indicators.bbands.BBANDS.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/indicators/bbands/#hexital.indicators.bbands.BBANDS.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/indicators/bbands/#hexital.indicators.bbands.BBANDS.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/bbands/#hexital.indicators.bbands.BBANDS.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/bbands/#hexital.indicators.bbands.BBANDS.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/bbands/#hexital.indicators.bbands.BBANDS.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/indicators/bbands/#hexital.indicators.bbands.BBANDS.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/bbands/#hexital.indicators.bbands.BBANDS.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/bbands/#hexital.indicators.bbands.BBANDS.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/indicators/bbands/#hexital.indicators.bbands.BBANDS.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/bbands/#hexital.indicators.bbands.BBANDS.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/bbands/#hexital.indicators.bbands.BBANDS.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/indicators/bbands/#hexital.indicators.bbands.BBANDS.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/cmo/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> cmo","text":""},{"location":"reference/hexital/indicators/cmo/#hexital.indicators.cmo","title":"cmo","text":"<p>Classes:</p> Name Description <code>CMO</code> <p>Chande Momentum Oscillator - CMO</p>"},{"location":"reference/hexital/indicators/cmo/#hexital.indicators.cmo.CMO","title":"CMO  <code>dataclass</code>","text":"<pre><code>CMO(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    period: int = 14,\n    source: Source = \"close\"\n)\n</code></pre> <p>               Bases: <code>Indicator[float | None]</code></p> <p>Chande Momentum Oscillator - CMO</p> <p>The CMO indicator is created by calculating the difference between the sum of all recent higher closes and the sum of all recent lower closes and then dividing the result by the sum of all price movement over a given time period. The result is multiplied by 100 to give the -100 to +100 range.</p> Sources <p>https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/cmo</p> <p>Output type: <code>float</code></p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>How many Periods to use. Defaults to 14</p> <code>14</code> <code>source</code> <code>str</code> <p>Which input field to calculate the Indicator. Defaults to \"close\"</p> <code>'close'</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/indicators/cmo/#hexital.indicators.cmo.CMO.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/indicators/cmo/#hexital.indicators.cmo.CMO.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/indicators/cmo/#hexital.indicators.cmo.CMO.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/indicators/cmo/#hexital.indicators.cmo.CMO.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/indicators/cmo/#hexital.indicators.cmo.CMO.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/cmo/#hexital.indicators.cmo.CMO.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/cmo/#hexital.indicators.cmo.CMO.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/cmo/#hexital.indicators.cmo.CMO.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/indicators/cmo/#hexital.indicators.cmo.CMO.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/cmo/#hexital.indicators.cmo.CMO.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/cmo/#hexital.indicators.cmo.CMO.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/indicators/cmo/#hexital.indicators.cmo.CMO.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/cmo/#hexital.indicators.cmo.CMO.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/cmo/#hexital.indicators.cmo.CMO.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/indicators/cmo/#hexital.indicators.cmo.CMO.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/counter/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> counter","text":""},{"location":"reference/hexital/indicators/counter/#hexital.indicators.counter","title":"counter","text":"<p>Classes:</p> Name Description <code>Counter</code> <p>Counter</p>"},{"location":"reference/hexital/indicators/counter/#hexital.indicators.counter.Counter","title":"Counter  <code>dataclass</code>","text":"<pre><code>Counter(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    source: Source,\n    count_value: Any = True\n)\n</code></pre> <p>               Bases: <code>Indicator[int]</code></p> <p>Counter</p> <p>Simple Indictor which will count the current streak of a given value, specifically designed for bool values, but useable on any other re-occurring values. E.G Count the streak for current input value == count_value</p> <p>Output type: <code>float</code></p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Which input field to calculate the Indicator.</p> required <code>count_value</code> <code>bool | int</code> <p>Which value to be counting, E.G <code>bool</code>, <code>1</code>, etc</p> <code>True</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/indicators/counter/#hexital.indicators.counter.Counter.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/indicators/counter/#hexital.indicators.counter.Counter.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/indicators/counter/#hexital.indicators.counter.Counter.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/indicators/counter/#hexital.indicators.counter.Counter.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/indicators/counter/#hexital.indicators.counter.Counter.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/counter/#hexital.indicators.counter.Counter.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/counter/#hexital.indicators.counter.Counter.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/counter/#hexital.indicators.counter.Counter.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/indicators/counter/#hexital.indicators.counter.Counter.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/counter/#hexital.indicators.counter.Counter.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/counter/#hexital.indicators.counter.Counter.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/indicators/counter/#hexital.indicators.counter.Counter.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/counter/#hexital.indicators.counter.Counter.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/counter/#hexital.indicators.counter.Counter.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/indicators/counter/#hexital.indicators.counter.Counter.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/donchian/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> donchian","text":""},{"location":"reference/hexital/indicators/donchian/#hexital.indicators.donchian","title":"donchian","text":"<p>Classes:</p> Name Description <code>Donchian</code> <p>Donchian Channels - Donchian</p>"},{"location":"reference/hexital/indicators/donchian/#hexital.indicators.donchian.Donchian","title":"Donchian  <code>dataclass</code>","text":"<pre><code>Donchian(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    period: int = 20\n)\n</code></pre> <p>               Bases: <code>Indicator[dict]</code></p> <p>Donchian Channels - Donchian</p> <p>Donchian Channels are a technical indicator that seeks to identify bullish and bearish extremes that favor reversals, higher and lower breakouts, breakdowns, and other emerging trends.</p> Sources <p>https://upstox.com/learning-center/share-market/a-comprehensive-guide-to-donchian-channels-formula-calculation-and-strategic-uses/ https://en.wikipedia.org/wiki/Donchian_channel</p> <p>Output type: <code>Dict[\"DCL\": float, \"DCM\": float, \"DCU\": float]</code></p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>How many Periods to use. Defaults to 20</p> <code>20</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/indicators/donchian/#hexital.indicators.donchian.Donchian.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/indicators/donchian/#hexital.indicators.donchian.Donchian.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/indicators/donchian/#hexital.indicators.donchian.Donchian.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/indicators/donchian/#hexital.indicators.donchian.Donchian.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/indicators/donchian/#hexital.indicators.donchian.Donchian.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/donchian/#hexital.indicators.donchian.Donchian.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/donchian/#hexital.indicators.donchian.Donchian.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/donchian/#hexital.indicators.donchian.Donchian.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/indicators/donchian/#hexital.indicators.donchian.Donchian.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/donchian/#hexital.indicators.donchian.Donchian.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/donchian/#hexital.indicators.donchian.Donchian.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/indicators/donchian/#hexital.indicators.donchian.Donchian.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/donchian/#hexital.indicators.donchian.Donchian.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/donchian/#hexital.indicators.donchian.Donchian.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/indicators/donchian/#hexital.indicators.donchian.Donchian.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/ema/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> ema","text":""},{"location":"reference/hexital/indicators/ema/#hexital.indicators.ema","title":"ema","text":"<p>Classes:</p> Name Description <code>EMA</code> <p>Exponential Moving Average - EMA</p>"},{"location":"reference/hexital/indicators/ema/#hexital.indicators.ema.EMA","title":"EMA  <code>dataclass</code>","text":"<pre><code>EMA(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    period: int = 10,\n    source: Source = \"close\",\n    smoothing: float = 2.0\n)\n</code></pre> <p>               Bases: <code>Indicator[float | None]</code></p> <p>Exponential Moving Average - EMA</p> <p>The Exponential Moving Average is more responsive moving average compared to the Simple Moving Average (SMA).  The weights are determined by alpha which is proportional to it's length.</p> Sources <p>https://www.investopedia.com/ask/answers/122314/what-exponential-moving-average-ema-formula-and-how-ema-calculated.asp</p> <p>Output type: <code>float</code></p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>How many Periods to use. Defaults to 10</p> <code>10</code> <code>source</code> <code>str</code> <p>Which input field to calculate the Indicator. Defaults to \"close\"</p> <code>'close'</code> <code>smoothing</code> <code>float</code> <p>Smoothing multiplier for EMA. Defaults to 2.0</p> <code>2.0</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/indicators/ema/#hexital.indicators.ema.EMA.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/indicators/ema/#hexital.indicators.ema.EMA.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/indicators/ema/#hexital.indicators.ema.EMA.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/indicators/ema/#hexital.indicators.ema.EMA.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/indicators/ema/#hexital.indicators.ema.EMA.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/ema/#hexital.indicators.ema.EMA.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/ema/#hexital.indicators.ema.EMA.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/ema/#hexital.indicators.ema.EMA.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/indicators/ema/#hexital.indicators.ema.EMA.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/ema/#hexital.indicators.ema.EMA.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/ema/#hexital.indicators.ema.EMA.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/indicators/ema/#hexital.indicators.ema.EMA.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/ema/#hexital.indicators.ema.EMA.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/ema/#hexital.indicators.ema.EMA.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/indicators/ema/#hexital.indicators.ema.EMA.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/highest_lowest/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> highest_lowest","text":""},{"location":"reference/hexital/indicators/highest_lowest/#hexital.indicators.highest_lowest","title":"highest_lowest","text":"<p>Classes:</p> Name Description <code>HL</code> <p>Highest Lowest - HL</p>"},{"location":"reference/hexital/indicators/highest_lowest/#hexital.indicators.highest_lowest.HL","title":"HL  <code>dataclass</code>","text":"<pre><code>HL(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    period: int = 100\n)\n</code></pre> <p>               Bases: <code>Indicator[dict]</code></p> <p>Highest Lowest - HL</p> <p>Simple utility indicator to record and display the highest and lowest values N periods back.</p> <p>Output type: <code>Dict[\"low\": float, \"high\": float]</code></p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>How many Periods to use. Defaults to 100</p> <code>100</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/indicators/highest_lowest/#hexital.indicators.highest_lowest.HL.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/indicators/highest_lowest/#hexital.indicators.highest_lowest.HL.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/indicators/highest_lowest/#hexital.indicators.highest_lowest.HL.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/indicators/highest_lowest/#hexital.indicators.highest_lowest.HL.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/indicators/highest_lowest/#hexital.indicators.highest_lowest.HL.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/highest_lowest/#hexital.indicators.highest_lowest.HL.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/highest_lowest/#hexital.indicators.highest_lowest.HL.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/highest_lowest/#hexital.indicators.highest_lowest.HL.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/indicators/highest_lowest/#hexital.indicators.highest_lowest.HL.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/highest_lowest/#hexital.indicators.highest_lowest.HL.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/highest_lowest/#hexital.indicators.highest_lowest.HL.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/indicators/highest_lowest/#hexital.indicators.highest_lowest.HL.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/highest_lowest/#hexital.indicators.highest_lowest.HL.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/highest_lowest/#hexital.indicators.highest_lowest.HL.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/indicators/highest_lowest/#hexital.indicators.highest_lowest.HL.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/hla/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> hla","text":""},{"location":"reference/hexital/indicators/hla/#hexital.indicators.hla","title":"hla","text":"<p>Classes:</p> Name Description <code>HLA</code> <p>High Low Average - HLA</p>"},{"location":"reference/hexital/indicators/hla/#hexital.indicators.hla.HLA","title":"HLA  <code>dataclass</code>","text":"<pre><code>HLA(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4\n)\n</code></pre> <p>               Bases: <code>Indicator[float]</code></p> <p>High Low Average - HLA</p> <p>Output type: <code>float</code></p> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/indicators/hla/#hexital.indicators.hla.HLA.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/indicators/hla/#hexital.indicators.hla.HLA.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/indicators/hla/#hexital.indicators.hla.HLA.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/indicators/hla/#hexital.indicators.hla.HLA.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/indicators/hla/#hexital.indicators.hla.HLA.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/hla/#hexital.indicators.hla.HLA.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/hla/#hexital.indicators.hla.HLA.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/hla/#hexital.indicators.hla.HLA.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/indicators/hla/#hexital.indicators.hla.HLA.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/hla/#hexital.indicators.hla.HLA.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/hla/#hexital.indicators.hla.HLA.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/indicators/hla/#hexital.indicators.hla.HLA.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/hla/#hexital.indicators.hla.HLA.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/hla/#hexital.indicators.hla.HLA.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/indicators/hla/#hexital.indicators.hla.HLA.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/hlca/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> hlca","text":""},{"location":"reference/hexital/indicators/hlca/#hexital.indicators.hlca","title":"hlca","text":"<p>Classes:</p> Name Description <code>HLCA</code> <p>High Low Close Average - HLCA</p>"},{"location":"reference/hexital/indicators/hlca/#hexital.indicators.hlca.HLCA","title":"HLCA  <code>dataclass</code>","text":"<pre><code>HLCA(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4\n)\n</code></pre> <p>               Bases: <code>Indicator[float]</code></p> <p>High Low Close Average - HLCA</p> <p>Output type: <code>float</code></p> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/indicators/hlca/#hexital.indicators.hlca.HLCA.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/indicators/hlca/#hexital.indicators.hlca.HLCA.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/indicators/hlca/#hexital.indicators.hlca.HLCA.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/indicators/hlca/#hexital.indicators.hlca.HLCA.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/indicators/hlca/#hexital.indicators.hlca.HLCA.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/hlca/#hexital.indicators.hlca.HLCA.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/hlca/#hexital.indicators.hlca.HLCA.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/hlca/#hexital.indicators.hlca.HLCA.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/indicators/hlca/#hexital.indicators.hlca.HLCA.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/hlca/#hexital.indicators.hlca.HLCA.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/hlca/#hexital.indicators.hlca.HLCA.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/indicators/hlca/#hexital.indicators.hlca.HLCA.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/hlca/#hexital.indicators.hlca.HLCA.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/hlca/#hexital.indicators.hlca.HLCA.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/indicators/hlca/#hexital.indicators.hlca.HLCA.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/hma/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> hma","text":""},{"location":"reference/hexital/indicators/hma/#hexital.indicators.hma","title":"hma","text":"<p>Classes:</p> Name Description <code>HMA</code> <p>Hull Moving Average - HMA</p>"},{"location":"reference/hexital/indicators/hma/#hexital.indicators.hma.HMA","title":"HMA  <code>dataclass</code>","text":"<pre><code>HMA(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    period: int = 10,\n    source: Source = \"close\"\n)\n</code></pre> <p>               Bases: <code>Indicator[float | None]</code></p> <p>Hull Moving Average - HMA</p> <p>It is a combination of weighted moving averages designed to be more responsive to current price fluctuations while still smoothing prices.</p> Sources <p>https://school.stockcharts.com/doku.php?id=technical_indicators:hull_moving_average</p> <p>Output type: <code>float</code></p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>How many Periods to use. Defaults to 10</p> <code>10</code> <code>source</code> <code>str</code> <p>Which input field to calculate the Indicator. Defaults to \"close\"</p> <code>'close'</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/indicators/hma/#hexital.indicators.hma.HMA.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/indicators/hma/#hexital.indicators.hma.HMA.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/indicators/hma/#hexital.indicators.hma.HMA.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/indicators/hma/#hexital.indicators.hma.HMA.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/indicators/hma/#hexital.indicators.hma.HMA.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/hma/#hexital.indicators.hma.HMA.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/hma/#hexital.indicators.hma.HMA.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/hma/#hexital.indicators.hma.HMA.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/indicators/hma/#hexital.indicators.hma.HMA.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/hma/#hexital.indicators.hma.HMA.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/hma/#hexital.indicators.hma.HMA.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/indicators/hma/#hexital.indicators.hma.HMA.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/hma/#hexital.indicators.hma.HMA.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/hma/#hexital.indicators.hma.HMA.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/indicators/hma/#hexital.indicators.hma.HMA.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/jma/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> jma","text":""},{"location":"reference/hexital/indicators/jma/#hexital.indicators.jma","title":"jma","text":"<p>Classes:</p> Name Description <code>JMA</code> <p>Jurik Moving Average Average - JMA</p>"},{"location":"reference/hexital/indicators/jma/#hexital.indicators.jma.JMA","title":"JMA  <code>dataclass</code>","text":"<pre><code>JMA(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    period: int = 7,\n    source: Source = \"close\",\n    phase: float = 0.0\n)\n</code></pre> <p>               Bases: <code>Indicator[float | None]</code></p> <p>Jurik Moving Average Average - JMA</p> <p>The JMA is an adaptive moving average that aims to reduce lag and improve responsiveness to price changes compared to traditional moving averages. By incorporating volatility and phase shift components, the JMA seeks to provide traders with a more accurate and timely representation of market trends.</p> Sources <p>https://c.mql5.com/forextsd/forum/164/jurik_1.pdf</p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>How many Periods to use. Defaults to 7</p> <code>7</code> <code>source</code> <code>str</code> <p>Which input field to calculate the Indicator. Defaults to \"close\"</p> <code>'close'</code> <code>phase</code> <code>float</code> <p>How heavy/light the average is [-100, 100]. Defaults to 0.0</p> <code>0.0</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/indicators/jma/#hexital.indicators.jma.JMA.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/indicators/jma/#hexital.indicators.jma.JMA.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/indicators/jma/#hexital.indicators.jma.JMA.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/indicators/jma/#hexital.indicators.jma.JMA.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/indicators/jma/#hexital.indicators.jma.JMA.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/jma/#hexital.indicators.jma.JMA.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/jma/#hexital.indicators.jma.JMA.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/jma/#hexital.indicators.jma.JMA.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/indicators/jma/#hexital.indicators.jma.JMA.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/jma/#hexital.indicators.jma.JMA.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/jma/#hexital.indicators.jma.JMA.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/indicators/jma/#hexital.indicators.jma.JMA.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/jma/#hexital.indicators.jma.JMA.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/jma/#hexital.indicators.jma.JMA.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/indicators/jma/#hexital.indicators.jma.JMA.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/kc/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> kc","text":""},{"location":"reference/hexital/indicators/kc/#hexital.indicators.kc","title":"kc","text":"<p>Classes:</p> Name Description <code>KC</code> <p>Keltner Channel - KC</p>"},{"location":"reference/hexital/indicators/kc/#hexital.indicators.kc.KC","title":"KC  <code>dataclass</code>","text":"<pre><code>KC(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    period: int = 20,\n    source: Source = \"close\",\n    multiplier: float = 2.0\n)\n</code></pre> <p>               Bases: <code>Indicator[dict]</code></p> <p>Keltner Channel - KC</p> <p>Keltner channel is a technical analysis indicator showing a central moving average line plus channel lines at a distance above and below. A popular volatility indicator similar to Bollinger Bands and Donchian Channels.</p> Sources <p>https://www.investopedia.com/terms/k/keltnerchannel.asp</p> <p>Output type: <code>Dict[\"lower\": float, \"band\": float, \"upper\": float]</code></p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>How many Periods to use. Defaults to 20</p> <code>20</code> <code>source</code> <code>str</code> <p>Which input field to calculate the Indicator. Defaults to \"close\"</p> <code>'close'</code> <code>multiplier</code> <code>float</code> <p>A positive float to multiply the bands. Defaults to 2.0</p> <code>2.0</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/indicators/kc/#hexital.indicators.kc.KC.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/indicators/kc/#hexital.indicators.kc.KC.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/indicators/kc/#hexital.indicators.kc.KC.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/indicators/kc/#hexital.indicators.kc.KC.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/indicators/kc/#hexital.indicators.kc.KC.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/kc/#hexital.indicators.kc.KC.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/kc/#hexital.indicators.kc.KC.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/kc/#hexital.indicators.kc.KC.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/indicators/kc/#hexital.indicators.kc.KC.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/kc/#hexital.indicators.kc.KC.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/kc/#hexital.indicators.kc.KC.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/indicators/kc/#hexital.indicators.kc.KC.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/kc/#hexital.indicators.kc.KC.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/kc/#hexital.indicators.kc.KC.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/indicators/kc/#hexital.indicators.kc.KC.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/macd/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> macd","text":""},{"location":"reference/hexital/indicators/macd/#hexital.indicators.macd","title":"macd","text":"<p>Classes:</p> Name Description <code>MACD</code> <p>Moving Average Convergence Divergence - MACD</p>"},{"location":"reference/hexital/indicators/macd/#hexital.indicators.macd.MACD","title":"MACD  <code>dataclass</code>","text":"<pre><code>MACD(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    source: Source = \"close\",\n    fast_period: int = 12,\n    slow_period: int = 26,\n    signal_period: int = 9\n)\n</code></pre> <p>               Bases: <code>Indicator[dict]</code></p> <p>Moving Average Convergence Divergence - MACD</p> <p>The MACD is a popular indicator to that is used to identify a security's trend. While APO and MACD are the same calculation, MACD also returns two more series called Signal and Histogram. The Signal is an EMA of MACD and the Histogram is the difference of MACD and Signal.</p> Sources <p>https://www.investopedia.com/ask/answers/122314/what-exponential-moving-average-ema-formula-and-how-ema-calculated.asp</p> <p>Output type: <code>Dict[\"MACD\": float, \"signal\": float, \"histogram\": float]</code></p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Which input field to calculate the Indicator. Defaults to \"close\"</p> <code>'close'</code> <code>fast_period</code> <code>int</code> <p>How many Periods to use for fast EMA. Defaults to 12</p> <code>12</code> <code>slow_period</code> <code>int</code> <p>How many Periods to use for slow EMA. Defaults to 26</p> <code>26</code> <code>signal_period</code> <code>int</code> <p>How many Periods to use for MACD signal. Defaults to 9</p> <code>9</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/indicators/macd/#hexital.indicators.macd.MACD.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/indicators/macd/#hexital.indicators.macd.MACD.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/indicators/macd/#hexital.indicators.macd.MACD.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/indicators/macd/#hexital.indicators.macd.MACD.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/indicators/macd/#hexital.indicators.macd.MACD.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/macd/#hexital.indicators.macd.MACD.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/macd/#hexital.indicators.macd.MACD.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/macd/#hexital.indicators.macd.MACD.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/indicators/macd/#hexital.indicators.macd.MACD.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/macd/#hexital.indicators.macd.MACD.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/macd/#hexital.indicators.macd.MACD.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/indicators/macd/#hexital.indicators.macd.MACD.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/macd/#hexital.indicators.macd.MACD.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/macd/#hexital.indicators.macd.MACD.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/indicators/macd/#hexital.indicators.macd.MACD.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/mfi/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> mfi","text":""},{"location":"reference/hexital/indicators/mfi/#hexital.indicators.mfi","title":"mfi","text":"<p>Classes:</p> Name Description <code>MFI</code> <p>Money Flow Index - MFI</p>"},{"location":"reference/hexital/indicators/mfi/#hexital.indicators.mfi.MFI","title":"MFI  <code>dataclass</code>","text":"<pre><code>MFI(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    period: int = 14,\n    source: Source = \"close\"\n)\n</code></pre> <p>               Bases: <code>Indicator[float | None]</code></p> <p>Money Flow Index - MFI</p> <p>The money flow index (MFI) is an oscillator that ranges from 0 to 100. It is used to show the money flow over several days.</p> Sources <p>https://www.tradingview.com/wiki/Money_Flow_(MFI)</p> <p>Output type: <code>float</code></p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>How many Periods to use. Defaults to 14</p> <code>14</code> <code>source</code> <code>str</code> <p>Which input field to calculate the Indicator. Defaults to \"close\"</p> <code>'close'</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/indicators/mfi/#hexital.indicators.mfi.MFI.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/indicators/mfi/#hexital.indicators.mfi.MFI.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/indicators/mfi/#hexital.indicators.mfi.MFI.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/indicators/mfi/#hexital.indicators.mfi.MFI.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/indicators/mfi/#hexital.indicators.mfi.MFI.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/mfi/#hexital.indicators.mfi.MFI.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/mfi/#hexital.indicators.mfi.MFI.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/mfi/#hexital.indicators.mfi.MFI.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/indicators/mfi/#hexital.indicators.mfi.MFI.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/mfi/#hexital.indicators.mfi.MFI.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/mfi/#hexital.indicators.mfi.MFI.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/indicators/mfi/#hexital.indicators.mfi.MFI.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/mfi/#hexital.indicators.mfi.MFI.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/mfi/#hexital.indicators.mfi.MFI.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/indicators/mfi/#hexital.indicators.mfi.MFI.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/midpoint/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> midpoint","text":""},{"location":"reference/hexital/indicators/midpoint/#hexital.indicators.midpoint","title":"midpoint","text":"<p>Classes:</p> Name Description <code>MOP</code> <p>Midpoint Over Period - MOP</p>"},{"location":"reference/hexital/indicators/midpoint/#hexital.indicators.midpoint.MOP","title":"MOP  <code>dataclass</code>","text":"<pre><code>MOP(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    period: int = 2,\n    source: Source = \"close\"\n)\n</code></pre> <p>               Bases: <code>Indicator[float | None]</code></p> <p>Midpoint Over Period - MOP</p> <p>A technical analysis tool that evaluates the average price movement by calculating the midpoint between the highest and lowest points over a specified period. This indicator aims to provide a smoother representation of price action, avoiding the choppiness of extreme highs and lows.</p> Sources <p>https://trendspider.com/learning-center/understanding-and-applying-the-midpoint-over-period-indicator-in-trading/</p> <p>Output type: <code>float</code></p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>How many Periods to use. Defaults to 2</p> <code>2</code> <code>source</code> <code>str</code> <p>Which input field to calculate the Indicator. Defaults to \"close\"</p> <code>'close'</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/indicators/midpoint/#hexital.indicators.midpoint.MOP.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/indicators/midpoint/#hexital.indicators.midpoint.MOP.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/indicators/midpoint/#hexital.indicators.midpoint.MOP.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/indicators/midpoint/#hexital.indicators.midpoint.MOP.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/indicators/midpoint/#hexital.indicators.midpoint.MOP.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/midpoint/#hexital.indicators.midpoint.MOP.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/midpoint/#hexital.indicators.midpoint.MOP.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/midpoint/#hexital.indicators.midpoint.MOP.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/indicators/midpoint/#hexital.indicators.midpoint.MOP.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/midpoint/#hexital.indicators.midpoint.MOP.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/midpoint/#hexital.indicators.midpoint.MOP.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/indicators/midpoint/#hexital.indicators.midpoint.MOP.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/midpoint/#hexital.indicators.midpoint.MOP.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/midpoint/#hexital.indicators.midpoint.MOP.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/indicators/midpoint/#hexital.indicators.midpoint.MOP.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/obv/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> obv","text":""},{"location":"reference/hexital/indicators/obv/#hexital.indicators.obv","title":"obv","text":"<p>Classes:</p> Name Description <code>OBV</code> <p>On-Balance Volume - OBC</p>"},{"location":"reference/hexital/indicators/obv/#hexital.indicators.obv.OBV","title":"OBV  <code>dataclass</code>","text":"<pre><code>OBV(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4\n)\n</code></pre> <p>               Bases: <code>Indicator[float]</code></p> <p>On-Balance Volume - OBC</p> <p>On-balance volume (OBV) is a technical analysis indicator intended to relate price and volume in the stock market. OBV is based on a cumulative total volume.</p> Sources <p>https://en.wikipedia.org/wiki/On-balance_volume</p> <p>Output type: <code>float</code></p> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/indicators/obv/#hexital.indicators.obv.OBV.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/indicators/obv/#hexital.indicators.obv.OBV.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/indicators/obv/#hexital.indicators.obv.OBV.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/indicators/obv/#hexital.indicators.obv.OBV.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/indicators/obv/#hexital.indicators.obv.OBV.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/obv/#hexital.indicators.obv.OBV.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/obv/#hexital.indicators.obv.OBV.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/obv/#hexital.indicators.obv.OBV.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/indicators/obv/#hexital.indicators.obv.OBV.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/obv/#hexital.indicators.obv.OBV.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/obv/#hexital.indicators.obv.OBV.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/indicators/obv/#hexital.indicators.obv.OBV.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/obv/#hexital.indicators.obv.OBV.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/obv/#hexital.indicators.obv.OBV.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/indicators/obv/#hexital.indicators.obv.OBV.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/pivot_points/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> pivot_points","text":""},{"location":"reference/hexital/indicators/pivot_points/#hexital.indicators.pivot_points","title":"pivot_points","text":"<p>Classes:</p> Name Description <code>PivotPoints</code> <p>Pivot Points - PP</p>"},{"location":"reference/hexital/indicators/pivot_points/#hexital.indicators.pivot_points.PivotPoints","title":"PivotPoints  <code>dataclass</code>","text":"<pre><code>PivotPoints(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4\n)\n</code></pre> <p>               Bases: <code>Indicator[dict]</code></p> <p>Pivot Points - PP</p> <p>Pivot point is a price level that is used by traders as a possible indicator of market movement. A pivot point is calculated as an average of significant prices (high, low, close) from the performance of a market in the prior trading period. If the market in the following period trades above the pivot point it is 1usually evaluated as a bullish sentiment, whereas trading below the pivot point is seen as bearish.</p> Sources <p>https://en.wikipedia.org/wiki/Pivot_point_(technical_analysis)</p> <p>Output type: <code>Dict[\"S1\": float, \"R1\": float, \"S2\": float, \"R2\": float]</code></p> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/indicators/pivot_points/#hexital.indicators.pivot_points.PivotPoints.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/indicators/pivot_points/#hexital.indicators.pivot_points.PivotPoints.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/indicators/pivot_points/#hexital.indicators.pivot_points.PivotPoints.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/indicators/pivot_points/#hexital.indicators.pivot_points.PivotPoints.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/indicators/pivot_points/#hexital.indicators.pivot_points.PivotPoints.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/pivot_points/#hexital.indicators.pivot_points.PivotPoints.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/pivot_points/#hexital.indicators.pivot_points.PivotPoints.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/pivot_points/#hexital.indicators.pivot_points.PivotPoints.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/indicators/pivot_points/#hexital.indicators.pivot_points.PivotPoints.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/pivot_points/#hexital.indicators.pivot_points.PivotPoints.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/pivot_points/#hexital.indicators.pivot_points.PivotPoints.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/indicators/pivot_points/#hexital.indicators.pivot_points.PivotPoints.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/pivot_points/#hexital.indicators.pivot_points.PivotPoints.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/pivot_points/#hexital.indicators.pivot_points.PivotPoints.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/indicators/pivot_points/#hexital.indicators.pivot_points.PivotPoints.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/rma/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> rma","text":""},{"location":"reference/hexital/indicators/rma/#hexital.indicators.rma","title":"rma","text":"<p>Classes:</p> Name Description <code>RMA</code> <p>wildeR's Moving Average - RMA</p>"},{"location":"reference/hexital/indicators/rma/#hexital.indicators.rma.RMA","title":"RMA  <code>dataclass</code>","text":"<pre><code>RMA(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    period: int = 10,\n    source: Source = \"close\"\n)\n</code></pre> <p>               Bases: <code>Indicator[float | None]</code></p> <p>wildeR's Moving Average - RMA</p> <p>Wilder's Moving Average places more emphasis on recent price movements than other moving averages. This makes it a more responsive tool for short-term traders who need to adapt quickly to changing market conditions.</p> Sources <p>https://tlc.thinkorswim.com/center/reference/Tech-Indicators/studies-library/V-Z/WildersSmoothing https://www.incrediblecharts.com/indicators/wilder_moving_average.php</p> <p>Output type: <code>float</code></p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>How many Periods to use. Defaults to 10</p> <code>10</code> <code>source</code> <code>str</code> <p>Which input field to calculate the Indicator. Defaults to \"close\"</p> <code>'close'</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/indicators/rma/#hexital.indicators.rma.RMA.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/indicators/rma/#hexital.indicators.rma.RMA.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/indicators/rma/#hexital.indicators.rma.RMA.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/indicators/rma/#hexital.indicators.rma.RMA.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/indicators/rma/#hexital.indicators.rma.RMA.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/rma/#hexital.indicators.rma.RMA.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/rma/#hexital.indicators.rma.RMA.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/rma/#hexital.indicators.rma.RMA.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/indicators/rma/#hexital.indicators.rma.RMA.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/rma/#hexital.indicators.rma.RMA.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/rma/#hexital.indicators.rma.RMA.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/indicators/rma/#hexital.indicators.rma.RMA.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/rma/#hexital.indicators.rma.RMA.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/rma/#hexital.indicators.rma.RMA.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/indicators/rma/#hexital.indicators.rma.RMA.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/roc/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> roc","text":""},{"location":"reference/hexital/indicators/roc/#hexital.indicators.roc","title":"roc","text":"<p>Classes:</p> Name Description <code>ROC</code> <p>Rate Of Change - ROC</p>"},{"location":"reference/hexital/indicators/roc/#hexital.indicators.roc.ROC","title":"ROC  <code>dataclass</code>","text":"<pre><code>ROC(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    period: int = 10,\n    source: Source = \"close\"\n)\n</code></pre> <p>               Bases: <code>Indicator[float | None]</code></p> <p>Rate Of Change - ROC</p> <p>The Price Rate of Change (ROC) indicator in trading refers to the percentage change between the current price and the price of a set number of periods ago. It is used to identify the momentum of price movement and help traders make informed decisions regarding buying or selling assets. This indicator is calculated by dividing the difference between the current price and the price of a set number of periods ago by the previous price and multiplying by 100.</p> Sources <p>https://en.wikipedia.org/wiki/Momentum_(technical_analysis)</p> <p>Output type: <code>float</code></p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>How many Periods to use. Defaults to 10</p> <code>10</code> <code>source</code> <code>str</code> <p>Which input field to calculate the Indicator. Defaults to \"close\"</p> <code>'close'</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/indicators/roc/#hexital.indicators.roc.ROC.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/indicators/roc/#hexital.indicators.roc.ROC.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/indicators/roc/#hexital.indicators.roc.ROC.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/indicators/roc/#hexital.indicators.roc.ROC.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/indicators/roc/#hexital.indicators.roc.ROC.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/roc/#hexital.indicators.roc.ROC.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/roc/#hexital.indicators.roc.ROC.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/roc/#hexital.indicators.roc.ROC.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/indicators/roc/#hexital.indicators.roc.ROC.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/roc/#hexital.indicators.roc.ROC.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/roc/#hexital.indicators.roc.ROC.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/indicators/roc/#hexital.indicators.roc.ROC.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/roc/#hexital.indicators.roc.ROC.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/roc/#hexital.indicators.roc.ROC.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/indicators/roc/#hexital.indicators.roc.ROC.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/rsi/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> rsi","text":""},{"location":"reference/hexital/indicators/rsi/#hexital.indicators.rsi","title":"rsi","text":"<p>Classes:</p> Name Description <code>RSI</code> <p>Relative Strength Index - RSI</p>"},{"location":"reference/hexital/indicators/rsi/#hexital.indicators.rsi.RSI","title":"RSI  <code>dataclass</code>","text":"<pre><code>RSI(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    period: int = 14,\n    source: Source = \"close\"\n)\n</code></pre> <p>               Bases: <code>Indicator[float | None]</code></p> <p>Relative Strength Index - RSI</p> <p>The Relative Strength Index is popular momentum oscillator used to measure the velocity as well as the magnitude of directional price movements.</p> Sources <p>https://www.tradingview.com/support/solutions/43000502338-relative-strength-index-rsi/</p> <p>Output type: <code>float</code></p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>How many Periods to use. Defaults to 14</p> <code>14</code> <code>source</code> <code>str</code> <p>Which input field to calculate the Indicator. Defaults to \"close\"</p> <code>'close'</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/indicators/rsi/#hexital.indicators.rsi.RSI.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/indicators/rsi/#hexital.indicators.rsi.RSI.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/indicators/rsi/#hexital.indicators.rsi.RSI.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/indicators/rsi/#hexital.indicators.rsi.RSI.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/indicators/rsi/#hexital.indicators.rsi.RSI.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/rsi/#hexital.indicators.rsi.RSI.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/rsi/#hexital.indicators.rsi.RSI.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/rsi/#hexital.indicators.rsi.RSI.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/indicators/rsi/#hexital.indicators.rsi.RSI.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/rsi/#hexital.indicators.rsi.RSI.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/rsi/#hexital.indicators.rsi.RSI.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/indicators/rsi/#hexital.indicators.rsi.RSI.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/rsi/#hexital.indicators.rsi.RSI.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/rsi/#hexital.indicators.rsi.RSI.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/indicators/rsi/#hexital.indicators.rsi.RSI.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/rvi/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> rvi","text":""},{"location":"reference/hexital/indicators/rvi/#hexital.indicators.rvi","title":"rvi","text":"<p>Classes:</p> Name Description <code>RVI</code> <p>Relative Vigor Index - RVI</p>"},{"location":"reference/hexital/indicators/rvi/#hexital.indicators.rvi.RVI","title":"RVI  <code>dataclass</code>","text":"<pre><code>RVI(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    period: int = 14,\n    source: Source = \"close\"\n)\n</code></pre> <p>               Bases: <code>Indicator[float | None]</code></p> <p>Relative Vigor Index - RVI</p> <p>The Relative Vigor Index, or RVI, is a popular member of the \u201cOscillator\u201d family of technical indicators. although the creator of the Relative Vigor Index is unknown, its design is very similar to Stochastics except that the closing price is compared with the Open rather than the Low price for the period.</p> Sources <p>https://www.thinkmarkets.com/en/learn-to-trade/indicators-and-patterns/indicators/relative-vigor-index-rvi-indicator/</p> <p>Output type: <code>float</code></p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>How many Periods to use. Defaults to 14</p> <code>14</code> <code>source</code> <code>str</code> <p>Which input field to calculate the Indicator. Defaults to \"close\"</p> <code>'close'</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/indicators/rvi/#hexital.indicators.rvi.RVI.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/indicators/rvi/#hexital.indicators.rvi.RVI.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/indicators/rvi/#hexital.indicators.rvi.RVI.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/indicators/rvi/#hexital.indicators.rvi.RVI.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/indicators/rvi/#hexital.indicators.rvi.RVI.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/rvi/#hexital.indicators.rvi.RVI.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/rvi/#hexital.indicators.rvi.RVI.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/rvi/#hexital.indicators.rvi.RVI.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/indicators/rvi/#hexital.indicators.rvi.RVI.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/rvi/#hexital.indicators.rvi.RVI.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/rvi/#hexital.indicators.rvi.RVI.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/indicators/rvi/#hexital.indicators.rvi.RVI.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/rvi/#hexital.indicators.rvi.RVI.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/rvi/#hexital.indicators.rvi.RVI.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/indicators/rvi/#hexital.indicators.rvi.RVI.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/sma/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> sma","text":""},{"location":"reference/hexital/indicators/sma/#hexital.indicators.sma","title":"sma","text":"<p>Classes:</p> Name Description <code>SMA</code> <p>Simple Moving Average - SMA</p>"},{"location":"reference/hexital/indicators/sma/#hexital.indicators.sma.SMA","title":"SMA  <code>dataclass</code>","text":"<pre><code>SMA(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    period: int = 10,\n    source: Source = \"close\"\n)\n</code></pre> <p>               Bases: <code>Indicator[float | None]</code></p> <p>Simple Moving Average - SMA</p> <p>The Simple Moving Average is the classic moving average that is the equally weighted average over n periods.</p> Sources <p>https://www.investopedia.com/terms/s/sma.asp</p> <p>Output type: <code>float</code></p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>How many Periods to use. Defaults to 10</p> <code>10</code> <code>source</code> <code>str</code> <p>Which input field to calculate the Indicator. Defaults to \"close\"</p> <code>'close'</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/indicators/sma/#hexital.indicators.sma.SMA.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/indicators/sma/#hexital.indicators.sma.SMA.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/indicators/sma/#hexital.indicators.sma.SMA.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/indicators/sma/#hexital.indicators.sma.SMA.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/indicators/sma/#hexital.indicators.sma.SMA.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/sma/#hexital.indicators.sma.SMA.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/sma/#hexital.indicators.sma.SMA.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/sma/#hexital.indicators.sma.SMA.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/indicators/sma/#hexital.indicators.sma.SMA.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/sma/#hexital.indicators.sma.SMA.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/sma/#hexital.indicators.sma.SMA.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/indicators/sma/#hexital.indicators.sma.SMA.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/sma/#hexital.indicators.sma.SMA.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/sma/#hexital.indicators.sma.SMA.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/indicators/sma/#hexital.indicators.sma.SMA.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/stdev/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> stdev","text":""},{"location":"reference/hexital/indicators/stdev/#hexital.indicators.stdev","title":"stdev","text":"<p>Classes:</p> Name Description <code>STDEV</code> <p>Rolling Standard Deviation - STDEV</p>"},{"location":"reference/hexital/indicators/stdev/#hexital.indicators.stdev.STDEV","title":"STDEV  <code>dataclass</code>","text":"<pre><code>STDEV(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    period: int = 30,\n    source: Source = \"close\"\n)\n</code></pre> <p>               Bases: <code>Indicator[float | None]</code></p> <p>Rolling Standard Deviation - STDEV</p> <p>You use a rolling stdev when you expect the standard deviation to change over time. As long as the standard deviation is changing slowly enough, we should be able to see the change in the standard deviation over time if we use the right size window.</p> Sources <p>https://jonisalonen.com/2014/efficient-and-accurate-rolling-standard-deviation/</p> <p>Output type: <code>float</code></p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>How many Periods to use. Defaults to 30</p> <code>30</code> <code>source</code> <code>str</code> <p>Which input field to calculate the Indicator. Defaults to \"close\"</p> <code>'close'</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/indicators/stdev/#hexital.indicators.stdev.STDEV.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/indicators/stdev/#hexital.indicators.stdev.STDEV.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/indicators/stdev/#hexital.indicators.stdev.STDEV.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/indicators/stdev/#hexital.indicators.stdev.STDEV.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/indicators/stdev/#hexital.indicators.stdev.STDEV.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/stdev/#hexital.indicators.stdev.STDEV.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/stdev/#hexital.indicators.stdev.STDEV.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/stdev/#hexital.indicators.stdev.STDEV.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/indicators/stdev/#hexital.indicators.stdev.STDEV.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/stdev/#hexital.indicators.stdev.STDEV.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/stdev/#hexital.indicators.stdev.STDEV.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/indicators/stdev/#hexital.indicators.stdev.STDEV.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/stdev/#hexital.indicators.stdev.STDEV.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/stdev/#hexital.indicators.stdev.STDEV.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/indicators/stdev/#hexital.indicators.stdev.STDEV.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/stdevthres/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> stdevthres","text":""},{"location":"reference/hexital/indicators/stdevthres/#hexital.indicators.stdevthres","title":"stdevthres","text":"<p>Classes:</p> Name Description <code>STDEVT</code> <p>Standard Deviation Threshold - STDEVT</p>"},{"location":"reference/hexital/indicators/stdevthres/#hexital.indicators.stdevthres.STDEVT","title":"STDEVT  <code>dataclass</code>","text":"<pre><code>STDEVT(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    period: int = 10,\n    source: Source = \"close\",\n    multiplier: float = 2.0\n)\n</code></pre> <p>               Bases: <code>Indicator[float | None]</code></p> <p>Standard Deviation Threshold - STDEVT</p> <p>Standard Deviation while calculating threshold returning boolean signal if change to input is higher than threshold</p> Sources <p>ChatGPT</p> <p>Output type: <code>float</code></p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>How many Periods to use. Defaults to 10</p> <code>10</code> <code>source</code> <code>str</code> <p>Which input field to calculate the Indicator. Defaults to \"close\"</p> <code>'close'</code> <code>multiplier</code> <code>float</code> <p>A positive float to multiply the Deviation. Defaults to 2.0</p> <code>2.0</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/indicators/stdevthres/#hexital.indicators.stdevthres.STDEVT.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/indicators/stdevthres/#hexital.indicators.stdevthres.STDEVT.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/indicators/stdevthres/#hexital.indicators.stdevthres.STDEVT.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/indicators/stdevthres/#hexital.indicators.stdevthres.STDEVT.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/indicators/stdevthres/#hexital.indicators.stdevthres.STDEVT.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/stdevthres/#hexital.indicators.stdevthres.STDEVT.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/stdevthres/#hexital.indicators.stdevthres.STDEVT.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/stdevthres/#hexital.indicators.stdevthres.STDEVT.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/indicators/stdevthres/#hexital.indicators.stdevthres.STDEVT.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/stdevthres/#hexital.indicators.stdevthres.STDEVT.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/stdevthres/#hexital.indicators.stdevthres.STDEVT.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/indicators/stdevthres/#hexital.indicators.stdevthres.STDEVT.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/stdevthres/#hexital.indicators.stdevthres.STDEVT.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/stdevthres/#hexital.indicators.stdevthres.STDEVT.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/indicators/stdevthres/#hexital.indicators.stdevthres.STDEVT.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/stoch/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> stoch","text":""},{"location":"reference/hexital/indicators/stoch/#hexital.indicators.stoch","title":"stoch","text":"<p>Classes:</p> Name Description <code>STOCH</code> <p>Stochastic - STOCH</p>"},{"location":"reference/hexital/indicators/stoch/#hexital.indicators.stoch.STOCH","title":"STOCH  <code>dataclass</code>","text":"<pre><code>STOCH(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    period: int = 14,\n    slow_period: int = 3,\n    smoothing_k: int = 3,\n    source: Source = \"close\"\n)\n</code></pre> <p>               Bases: <code>Indicator[dict]</code></p> <p>Stochastic - STOCH</p> <p>The Stochastic Oscillator (STOCH) was developed by George Lane in the 1950's. He believed this indicator was a good way to measure momentum because changes in momentum precede changes in price.</p> <p>It is a range-bound oscillator with two lines moving between 0 and 100. The first line (%K) displays the current close in relation to the period's high/low range. The second line (%D) is a Simple Moving Average of the %K line. The most common choices are a 14 period %K and a 3 period SMA for %D.</p> <p>%K = SMA(100 * (Current Close - Lowest Low) / (Highest High - Lowest Low), smoothK) %D = SMA(%K, periodD)</p> Sources <p>https://www.tradingview.com/wiki/Stochastic_(STOCH)</p> <p>Output type: <code>Dict[\"stoch\": float, \"k\": float, \"d\": float]</code></p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>How many Periods to use. Defaults to 14</p> <code>14</code> <code>slow_period</code> <code>int</code> <p>How many Periods to use on smoothing d. Defaults to 3</p> <code>3</code> <code>smoothing_k</code> <code>int</code> <p>How many Periods to use on smoothing K. Defaults to 3</p> <code>3</code> <code>source</code> <code>str</code> <p>Which input field to calculate the Indicator. Defaults to \"close\"</p> <code>'close'</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/indicators/stoch/#hexital.indicators.stoch.STOCH.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/indicators/stoch/#hexital.indicators.stoch.STOCH.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/indicators/stoch/#hexital.indicators.stoch.STOCH.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/indicators/stoch/#hexital.indicators.stoch.STOCH.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/indicators/stoch/#hexital.indicators.stoch.STOCH.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/stoch/#hexital.indicators.stoch.STOCH.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/stoch/#hexital.indicators.stoch.STOCH.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/stoch/#hexital.indicators.stoch.STOCH.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/indicators/stoch/#hexital.indicators.stoch.STOCH.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/stoch/#hexital.indicators.stoch.STOCH.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/stoch/#hexital.indicators.stoch.STOCH.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/indicators/stoch/#hexital.indicators.stoch.STOCH.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/stoch/#hexital.indicators.stoch.STOCH.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/stoch/#hexital.indicators.stoch.STOCH.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/indicators/stoch/#hexital.indicators.stoch.STOCH.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/supertrend/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> supertrend","text":""},{"location":"reference/hexital/indicators/supertrend/#hexital.indicators.supertrend","title":"supertrend","text":"<p>Classes:</p> Name Description <code>Supertrend</code> <p>Supertrend</p>"},{"location":"reference/hexital/indicators/supertrend/#hexital.indicators.supertrend.Supertrend","title":"Supertrend  <code>dataclass</code>","text":"<pre><code>Supertrend(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    period: int = 7,\n    source: Source = \"close\",\n    multiplier: float = 3.0\n)\n</code></pre> <p>               Bases: <code>Indicator[dict]</code></p> <p>Supertrend</p> <p>It is used to identify market trends and potential entry and exit points in trading. The indicator is based on two dynamic values, period and multiplier, and incorporates the concept of Average True Range (ATR) to measure market volatility. The SuperTrend Indicator generates buy and sell signals by plotting a line on the price chart.</p> <p>Output type: <code>Dict[\"trend\": float, \"direction\": int, \"short\": float]</code></p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>How many Periods to use. Defaults to 7</p> <code>7</code> <code>source</code> <code>str</code> <p>Which input field to calculate the Indicator. Defaults to \"close\"</p> <code>'close'</code> <code>multiplier</code> <code>float</code> <p>A positive float to multiply the ATR. Defaults to 3.0</p> <code>3.0</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/indicators/supertrend/#hexital.indicators.supertrend.Supertrend.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/indicators/supertrend/#hexital.indicators.supertrend.Supertrend.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/indicators/supertrend/#hexital.indicators.supertrend.Supertrend.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/indicators/supertrend/#hexital.indicators.supertrend.Supertrend.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/indicators/supertrend/#hexital.indicators.supertrend.Supertrend.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/supertrend/#hexital.indicators.supertrend.Supertrend.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/supertrend/#hexital.indicators.supertrend.Supertrend.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/supertrend/#hexital.indicators.supertrend.Supertrend.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/indicators/supertrend/#hexital.indicators.supertrend.Supertrend.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/supertrend/#hexital.indicators.supertrend.Supertrend.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/supertrend/#hexital.indicators.supertrend.Supertrend.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/indicators/supertrend/#hexital.indicators.supertrend.Supertrend.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/supertrend/#hexital.indicators.supertrend.Supertrend.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/supertrend/#hexital.indicators.supertrend.Supertrend.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/indicators/supertrend/#hexital.indicators.supertrend.Supertrend.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/tr/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> tr","text":""},{"location":"reference/hexital/indicators/tr/#hexital.indicators.tr","title":"tr","text":"<p>Classes:</p> Name Description <code>TR</code> <p>True Range - TR</p>"},{"location":"reference/hexital/indicators/tr/#hexital.indicators.tr.TR","title":"TR  <code>dataclass</code>","text":"<pre><code>TR(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4\n)\n</code></pre> <p>               Bases: <code>Indicator[float | None]</code></p> <p>True Range - TR</p> <p>An method to expand a classical range (high minus low) to include possible gap scenarios.</p> Sources <p>https://www.macroption.com/true-range/</p> <p>Output type: <code>float</code></p> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/indicators/tr/#hexital.indicators.tr.TR.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/indicators/tr/#hexital.indicators.tr.TR.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/indicators/tr/#hexital.indicators.tr.TR.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/indicators/tr/#hexital.indicators.tr.TR.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/indicators/tr/#hexital.indicators.tr.TR.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/tr/#hexital.indicators.tr.TR.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/tr/#hexital.indicators.tr.TR.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/tr/#hexital.indicators.tr.TR.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/indicators/tr/#hexital.indicators.tr.TR.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/tr/#hexital.indicators.tr.TR.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/tr/#hexital.indicators.tr.TR.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/indicators/tr/#hexital.indicators.tr.TR.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/tr/#hexital.indicators.tr.TR.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/tr/#hexital.indicators.tr.TR.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/indicators/tr/#hexital.indicators.tr.TR.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/tsi/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> tsi","text":""},{"location":"reference/hexital/indicators/tsi/#hexital.indicators.tsi","title":"tsi","text":"<p>Classes:</p> Name Description <code>TSI</code> <p>True Strength Index - TSI</p>"},{"location":"reference/hexital/indicators/tsi/#hexital.indicators.tsi.TSI","title":"TSI  <code>dataclass</code>","text":"<pre><code>TSI(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    period: int = 25,\n    smooth_period: Optional[int] = None,\n    source: Source = \"close\"\n)\n</code></pre> <p>               Bases: <code>Indicator[float | None]</code></p> <p>True Strength Index - TSI TSI attempts to show both trend direction and overbought/oversold conditions, using moving averages of the underlying momentum of a financial instrument.</p> Sources <p>https://school.stockcharts.com/doku.php?id=technical_indicators:true_strength_index</p> <p>Output type: <code>float</code></p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>How many Periods to use. Defaults to 25</p> <code>25</code> <code>smooth_period</code> <code>int</code> <p>How much to smooth with EMA defaults: (period / 2) + (period % 2 &gt; 0). Defaults to halve of period</p> <code>None</code> <code>source</code> <code>str</code> <p>Which input field to calculate the Indicator. Defaults to \"close\"</p> <code>'close'</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/indicators/tsi/#hexital.indicators.tsi.TSI.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/indicators/tsi/#hexital.indicators.tsi.TSI.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/indicators/tsi/#hexital.indicators.tsi.TSI.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/indicators/tsi/#hexital.indicators.tsi.TSI.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/indicators/tsi/#hexital.indicators.tsi.TSI.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/tsi/#hexital.indicators.tsi.TSI.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/tsi/#hexital.indicators.tsi.TSI.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/tsi/#hexital.indicators.tsi.TSI.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/indicators/tsi/#hexital.indicators.tsi.TSI.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/tsi/#hexital.indicators.tsi.TSI.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/tsi/#hexital.indicators.tsi.TSI.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/indicators/tsi/#hexital.indicators.tsi.TSI.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/tsi/#hexital.indicators.tsi.TSI.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/tsi/#hexital.indicators.tsi.TSI.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/indicators/tsi/#hexital.indicators.tsi.TSI.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/vwap/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> vwap","text":""},{"location":"reference/hexital/indicators/vwap/#hexital.indicators.vwap","title":"vwap","text":"<p>Classes:</p> Name Description <code>VWAP</code> <p>Volume-Weighted Average Price - VWAP</p>"},{"location":"reference/hexital/indicators/vwap/#hexital.indicators.vwap.VWAP","title":"VWAP  <code>dataclass</code>","text":"<pre><code>VWAP(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    anchor: Optional[str | TimeFrame | timedelta | int] = \"D\"\n)\n</code></pre> <p>               Bases: <code>Indicator[float]</code></p> <p>Volume-Weighted Average Price - VWAP</p> <p>The volume-weighted average price is a technical analysis indicator used on intraday charts that resets at the start of every new trading session.</p> Sources <p>https://www.investopedia.com/terms/v/vwap.asp</p> <p>Output type: <code>float</code></p> <p>Parameters:</p> Name Type Description Default <code>anchor</code> <code>Optional[str | TimeFrame | timedelta | int]</code> <p>How to anchor VWAP, Depends on the index values, uses TimeFrame</p> <code>'D'</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/indicators/vwap/#hexital.indicators.vwap.VWAP.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/indicators/vwap/#hexital.indicators.vwap.VWAP.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/indicators/vwap/#hexital.indicators.vwap.VWAP.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/indicators/vwap/#hexital.indicators.vwap.VWAP.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/indicators/vwap/#hexital.indicators.vwap.VWAP.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/vwap/#hexital.indicators.vwap.VWAP.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/vwap/#hexital.indicators.vwap.VWAP.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/vwap/#hexital.indicators.vwap.VWAP.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/indicators/vwap/#hexital.indicators.vwap.VWAP.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/vwap/#hexital.indicators.vwap.VWAP.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/vwap/#hexital.indicators.vwap.VWAP.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/indicators/vwap/#hexital.indicators.vwap.VWAP.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/vwap/#hexital.indicators.vwap.VWAP.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/vwap/#hexital.indicators.vwap.VWAP.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/indicators/vwap/#hexital.indicators.vwap.VWAP.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/vwma/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> vwma","text":""},{"location":"reference/hexital/indicators/vwma/#hexital.indicators.vwma","title":"vwma","text":"<p>Classes:</p> Name Description <code>VWMA</code> <p>Volume Weighted Moving Average - VWMA</p>"},{"location":"reference/hexital/indicators/vwma/#hexital.indicators.vwma.VWMA","title":"VWMA  <code>dataclass</code>","text":"<pre><code>VWMA(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    period: int = 10\n)\n</code></pre> <p>               Bases: <code>Indicator[float | None]</code></p> <p>Volume Weighted Moving Average - VWMA</p> <p>VWMA is the ratio of the value of a security or financial asset traded to the total volume of transactions during a trading session. It is a measure of the average trading price for the period.</p> Sources <p>https://www.investopedia.com/ask/answers/071414/whats-difference-between-moving-average-and-weighted-moving-average.asp</p> <p>Output type: <code>float</code></p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>How many Periods to use. Defaults to 10</p> <code>10</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/indicators/vwma/#hexital.indicators.vwma.VWMA.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/indicators/vwma/#hexital.indicators.vwma.VWMA.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/indicators/vwma/#hexital.indicators.vwma.VWMA.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/indicators/vwma/#hexital.indicators.vwma.VWMA.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/indicators/vwma/#hexital.indicators.vwma.VWMA.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/vwma/#hexital.indicators.vwma.VWMA.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/vwma/#hexital.indicators.vwma.VWMA.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/vwma/#hexital.indicators.vwma.VWMA.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/indicators/vwma/#hexital.indicators.vwma.VWMA.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/vwma/#hexital.indicators.vwma.VWMA.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/vwma/#hexital.indicators.vwma.VWMA.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/indicators/vwma/#hexital.indicators.vwma.VWMA.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/vwma/#hexital.indicators.vwma.VWMA.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/vwma/#hexital.indicators.vwma.VWMA.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/indicators/vwma/#hexital.indicators.vwma.VWMA.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/wma/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> wma","text":""},{"location":"reference/hexital/indicators/wma/#hexital.indicators.wma","title":"wma","text":"<p>Classes:</p> Name Description <code>WMA</code> <p>Weighted Moving Average - WMA</p>"},{"location":"reference/hexital/indicators/wma/#hexital.indicators.wma.WMA","title":"WMA  <code>dataclass</code>","text":"<pre><code>WMA(\n    *,\n    candles: List[Candle] = list(),\n    name: str = \"\",\n    timeframe: Optional[TimeFramesSource] = None,\n    timeframe_fill: bool = False,\n    candle_life: Optional[timedelta] = None,\n    candlestick: Optional[CandlestickType | str] = None,\n    rounding: Optional[int] = 4,\n    period: int = 10,\n    source: Source = \"close\"\n)\n</code></pre> <p>               Bases: <code>Indicator[float | None]</code></p> <p>Weighted Moving Average - WMA</p> <p>A Weighted Moving Average puts more weight on recent data and less on past data. This is done by multiplying each bar's price by a weighting factor. Because of its unique calculation, WMA will follow prices more closely than a corresponding Simple Moving Average.</p> Sources <p>https://www.investopedia.com/ask/answers/071414/whats-difference-between-moving-average-and-weighted-moving-average.asp</p> <p>Output type: <code>float</code></p> <p>Parameters:</p> Name Type Description Default <code>period</code> <code>int</code> <p>How many Periods to use. Defaults to 10</p> <code>10</code> <code>source</code> <code>str</code> <p>Which input field to calculate the Indicator. Defaults to \"close\"</p> <code>'close'</code> <p>Methods:</p> Name Description <code>add_managed_indicator</code> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> <code>add_sub_indicator</code> <p>Adds sub indicator, this will auto calculate with indicator</p> <code>append</code> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>calculate</code> <p>Calculate the TA values, will calculate for all the Candles,</p> <code>calculate_index</code> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> <code>insert</code> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <code>prepend</code> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <code>purge</code> <p>Remove this indicator value from all Candles</p> <code>reading</code> <p>Simple method to get an indicator reading from the index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p> <code>readings</code> <p>Retrieve the indicator readings for within the candles as a list.</p> <code>recalculate</code> <p>Re-calculate this indicator value for all Candles</p> <p>Attributes:</p> Name Type Description <code>candle_manager</code> <code>CandleManager</code> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p> <code>settings</code> <code>dict</code> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p>"},{"location":"reference/hexital/indicators/wma/#hexital.indicators.wma.WMA.candle_manager","title":"candle_manager  <code>property</code> <code>writable</code>","text":"<pre><code>candle_manager: CandleManager\n</code></pre> <p>The Candle Manager which controls TimeFrame, Trimming and collapsing</p>"},{"location":"reference/hexital/indicators/wma/#hexital.indicators.wma.WMA.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: dict\n</code></pre> <p>Retrieve the settings required to regenerate this indicator in a dictionary format.</p> <p>This property compiles the configuration details of the indicator, excluding attributes that are irrelevant for generation (e.g., candles and sub-indicators). It ensures the output dictionary is clean and contains only the necessary settings for recreating the indicator.</p> <p>Special handling is included for attributes like <code>candlestick</code> and <code>timeframe</code>, ensuring their values are properly formatted.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the indicator's settings, ready for regeneration. - <code>indicator</code> (str): The name of the indicator. - Additional keys correspond to other configuration attributes of the indicator.</p>"},{"location":"reference/hexital/indicators/wma/#hexital.indicators.wma.WMA.add_managed_indicator","title":"add_managed_indicator","text":"<pre><code>add_managed_indicator(indicator: N) -&gt; N\n</code></pre> <p>Adds managed sub indicator, this will not auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_managed_indicator(self, indicator: N) -&gt; N:\n    \"\"\"Adds managed sub indicator, this will not auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.MANAGED\n\n    if indicator.name == MANAGED_NAME:\n        indicator.name = f\"{self.name}_data\"\n    elif indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.managed_indicators[indicator.name] = indicator\n    return indicator\n</code></pre>"},{"location":"reference/hexital/indicators/wma/#hexital.indicators.wma.WMA.add_sub_indicator","title":"add_sub_indicator","text":"<pre><code>add_sub_indicator(indicator: Indicator, prior_calc: bool = True) -&gt; Indicator\n</code></pre> <p>Adds sub indicator, this will auto calculate with indicator</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def add_sub_indicator(self, indicator: Indicator, prior_calc: bool = True) -&gt; Indicator:\n    \"\"\"Adds sub indicator, this will auto calculate with indicator\"\"\"\n    indicator._mode = IndicatorMode.SUB\n    indicator._calc_prior = prior_calc\n\n    if indicator._generated_name:\n        indicator.name = f\"{self.name}-{indicator.name}\"\n\n    indicator.candle_manager = self._candle_mngr\n    indicator.rounding = None\n    self.sub_indicators[indicator.name] = indicator\n    return self.sub_indicators[indicator.name]\n</code></pre>"},{"location":"reference/hexital/indicators/wma/#hexital.indicators.wma.WMA.append","title":"append","text":"<pre><code>append(candles: Candles)\n</code></pre> <p>append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def append(self, candles: Candles):\n    \"\"\"append a Candle or a chronological ordered list of Candle's to the end of the Indicator Candle's. This wil only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.append(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/wma/#hexital.indicators.wma.WMA.calculate","title":"calculate","text":"<pre><code>calculate()\n</code></pre> <p>Calculate the TA values, will calculate for all the Candles, where this indicator is missing</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate(self):\n    \"\"\"Calculate the TA values, will calculate for all the Candles,\n    where this indicator is missing\"\"\"\n    self.check_initialised()\n\n    for index in range(self._find_calc_index(), len(self.candles)):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), round_by=self.rounding)\n\n        if index &lt; len(self.candles) - 1 and self._reading_dup(reading, self.candles[index]):\n            break\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/wma/#hexital.indicators.wma.WMA.calculate_index","title":"calculate_index","text":"<pre><code>calculate_index(start_index: int, end_index: Optional[int] = None)\n</code></pre> <p>Calculate the TA values, will calculate a index range the Candles, will re-calculate</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def calculate_index(self, start_index: int, end_index: Optional[int] = None):\n    \"\"\"Calculate the TA values, will calculate a index range the Candles, will re-calculate\"\"\"\n    self.check_initialised()\n\n    start_index = absindex(start_index, len(self.candles))\n\n    if end_index is not None:\n        end_index = absindex(end_index, len(self.candles))\n    else:\n        end_index = start_index\n\n    for index in range(start_index, end_index + 1):\n        self._set_active_index(index)\n        self._calculate_sub_indicators(True, index)\n\n        reading = round_values(self._calculate_reading(index=index), self.rounding)\n\n        self._set_reading(reading, index)\n        self._calculate_sub_indicators(False, index)\n</code></pre>"},{"location":"reference/hexital/indicators/wma/#hexital.indicators.wma.WMA.insert","title":"insert","text":"<pre><code>insert(candles: Candles)\n</code></pre> <p>insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def insert(self, candles: Candles):\n    \"\"\"insert a Candle or a list of Candle's to the Indicator Candles. This accepts any order or placement. This will sort, re-sample and re-calculate all Candles.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n    self._candle_mngr.insert(candles)\n    self.calculate_index(0, -1)\n</code></pre>"},{"location":"reference/hexital/indicators/wma/#hexital.indicators.wma.WMA.prepend","title":"prepend","text":"<pre><code>prepend(candles: Candles)\n</code></pre> <p>Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.</p> <p>Parameters:</p> Name Type Description Default <code>candles</code> <code>Candles</code> <p>The Candle or List of Candle's to prepend.</p> required Source code in <code>hexital/core/indicator.py</code> <pre><code>def prepend(self, candles: Candles):\n    \"\"\"Prepends a Candle or a chronological ordered list of Candle's to the front of the Indicator Candle's. This will only re-sample and re-calculate the new Candles, with minor overlap.\n\n    Args:\n        candles: The Candle or List of Candle's to prepend.\n    \"\"\"\n\n    self._candle_mngr.prepend(candles)\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/indicators/wma/#hexital.indicators.wma.WMA.purge","title":"purge","text":"<pre><code>purge()\n</code></pre> <p>Remove this indicator value from all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def purge(self):\n    \"\"\"Remove this indicator value from all Candles\"\"\"\n    self._candle_mngr.purge(\n        {self.name}\n        | {indicator.name for indicator in self.sub_indicators.values()}\n        | {indicator.name for indicator in self.managed_indicators.values()}\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/wma/#hexital.indicators.wma.WMA.reading","title":"reading","text":"<pre><code>reading(\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T\n</code></pre> <p>Simple method to get an indicator reading from the index</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading(\n    self,\n    source: Optional[Source] = None,\n    index: Optional[int] = None,\n    default: Optional[T] = None,\n) -&gt; Reading | V | T:\n    \"\"\"Simple method to get an indicator reading from the index\"\"\"\n    value = self._find_reading(source, index)\n    return value if value is not None else default\n</code></pre>"},{"location":"reference/hexital/indicators/wma/#hexital.indicators.wma.WMA.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_count(self, source: Optional[Source] = None, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    return reading_count(\n        *self._find_candles(source),\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/wma/#hexital.indicators.wma.WMA.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Period will be period -1</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def reading_period(\n    self, period: int, source: Optional[Source] = None, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Period will be period -1\"\"\"\n    return reading_period(\n        *self._find_candles(source),\n        period,\n        index if index is not None else self._active_index,\n    )\n</code></pre>"},{"location":"reference/hexital/indicators/wma/#hexital.indicators.wma.WMA.readings","title":"readings","text":"<pre><code>readings(name: Optional[Source] = None) -&gt; List[Reading | V]\n</code></pre> <p>Retrieve the indicator readings for within the candles as a list.</p> <p>This method collects the readings of a specified indicator for all candles and returns them as a list. If no name is provided, the generated name of the indicator is used.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>The name of the indicator to retrieve.                   Defaults to <code>self.name</code> if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Reading | V]</code> <p>List[float | dict | None]: A list containing the indicator values for                        each candle. The values may be floats,                        dictionaries (for complex indicators),                        or <code>None</code> if no reading is available.</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def readings(self, name: Optional[Source] = None) -&gt; List[Reading | V]:\n    \"\"\"\n    Retrieve the indicator readings for within the candles as a list.\n\n    This method collects the readings of a specified indicator for all candles\n    and returns them as a list. If no name is provided, the generated name of\n    the indicator is used.\n\n    Args:\n        name (Optional[str]): The name of the indicator to retrieve.\n                              Defaults to `self.name` if not provided.\n\n    Returns:\n        List[float | dict | None]: A list containing the indicator values for\n                                   each candle. The values may be floats,\n                                   dictionaries (for complex indicators),\n                                   or `None` if no reading is available.\n    \"\"\"\n    return self._find_readings(name)\n</code></pre>"},{"location":"reference/hexital/indicators/wma/#hexital.indicators.wma.WMA.recalculate","title":"recalculate","text":"<pre><code>recalculate()\n</code></pre> <p>Re-calculate this indicator value for all Candles</p> Source code in <code>hexital/core/indicator.py</code> <pre><code>def recalculate(self):\n    \"\"\"Re-calculate this indicator value for all Candles\"\"\"\n    self.purge()\n    self.calculate()\n</code></pre>"},{"location":"reference/hexital/utils/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> utils","text":""},{"location":"reference/hexital/utils/#hexital.utils","title":"utils","text":"<p>Modules:</p> Name Description <code>candles</code> <code>indexing</code> <code>timeframe</code>"},{"location":"reference/hexital/utils/candles/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> candles","text":""},{"location":"reference/hexital/utils/candles/#hexital.utils.candles","title":"candles","text":"<p>Functions:</p> Name Description <code>candles_average</code> <p>Averages period of <code>name</code> for <code>length</code> bars back.</p> <code>candles_sum</code> <p>Sum of <code>name</code> for <code>length</code> bars back. If not enough Candles, sum's what's available</p> <code>get_readings_period</code> <p>Goes through from index-length to index and returns a list of values, removes dict's and None values, validates index, if out of range set to max (-1)</p> <code>reading_by_candle</code> <p>Simple method to get a reading from the given indicator from a candle</p> <code>reading_by_index</code> <p>Simple method to get a reading from the given indicator from it's index</p> <code>reading_count</code> <p>Returns how many instance of the given indicator exist</p> <code>reading_period</code> <p>Will return True if the given indicator goes back as far as amount,</p>"},{"location":"reference/hexital/utils/candles/#hexital.utils.candles.candles_average","title":"candles_average","text":"<pre><code>candles_average(\n    candles: List[Candle],\n    name: str,\n    length: int,\n    index: int = -1,\n    include_latest: bool = True,\n) -&gt; float\n</code></pre> <p>Averages period of <code>name</code> for <code>length</code> bars back. If not enough Candles, sum's what's available</p> Source code in <code>hexital/utils/candles.py</code> <pre><code>def candles_average(\n    candles: List[Candle],\n    name: str,\n    length: int,\n    index: int = -1,\n    include_latest: bool = True,\n) -&gt; float:\n    \"\"\"Averages period of `name` for `length` bars back.\n    If not enough Candles, sum's what's available\"\"\"\n    values = get_readings_period(candles, name, length, index, include_latest)\n    return sum(values) / len(values) if values else 0\n</code></pre>"},{"location":"reference/hexital/utils/candles/#hexital.utils.candles.candles_sum","title":"candles_sum","text":"<pre><code>candles_sum(\n    candles: List[Candle],\n    name: str,\n    length: int,\n    index: int = -1,\n    include_latest: bool = True,\n) -&gt; float\n</code></pre> <p>Sum of <code>name</code> for <code>length</code> bars back. If not enough Candles, sum's what's available</p> Source code in <code>hexital/utils/candles.py</code> <pre><code>def candles_sum(\n    candles: List[Candle],\n    name: str,\n    length: int,\n    index: int = -1,\n    include_latest: bool = True,\n) -&gt; float:\n    \"\"\"Sum of `name` for `length` bars back. If not enough Candles, sum's what's available\"\"\"\n    return sum(get_readings_period(candles, name, length, index, include_latest))\n</code></pre>"},{"location":"reference/hexital/utils/candles/#hexital.utils.candles.get_readings_period","title":"get_readings_period","text":"<pre><code>get_readings_period(\n    candles: List[Candle],\n    name: str,\n    length: int,\n    index: int,\n    include_latest: bool = False,\n) -&gt; List[float | int]\n</code></pre> <p>Goes through from index-length to index and returns a list of values, removes dict's and None values, validates index, if out of range set to max (-1) Returns from newest at the back (same order)</p> Source code in <code>hexital/utils/candles.py</code> <pre><code>def get_readings_period(\n    candles: List[Candle], name: str, length: int, index: int, include_latest: bool = False\n) -&gt; List[float | int]:\n    \"\"\"Goes through from index-length to index and returns a list of values, removes dict's and None values, validates index, if out of range set to max (-1)\n    Returns from newest at the back (same order)\"\"\"\n    index_ = absindex(index, len(candles))\n\n    to_index = index_ + 1 if include_latest else index_\n\n    start = to_index - length\n    start = 0 if start &lt; 0 else start\n\n    readings = []\n\n    for candle in candles[start:to_index]:\n        reading = reading_by_candle(candle, name)\n        if isinstance(reading, (float, int)):\n            readings.append(reading)\n\n    return readings\n</code></pre>"},{"location":"reference/hexital/utils/candles/#hexital.utils.candles.reading_by_candle","title":"reading_by_candle","text":"<pre><code>reading_by_candle(candle: Candle, name: str) -&gt; float | dict | None\n</code></pre> <p>Simple method to get a reading from the given indicator from a candle Uses '.' to find nested reading, E.G 'MACD_12_26_9.MACD</p> Source code in <code>hexital/utils/candles.py</code> <pre><code>def reading_by_candle(candle: Candle, name: str) -&gt; float | dict | None:\n    \"\"\"Simple method to get a reading from the given indicator from a candle\n    Uses '.' to find nested reading, E.G 'MACD_12_26_9.MACD\"\"\"\n\n    if \".\" in name:\n        main_name, nested_name = name.split(\".\")\n        reading = _nested_indicator(candle, main_name, nested_name)\n        return reading\n\n    attr = getattr(candle, name, None)\n\n    if attr is not None:\n        return attr\n\n    if name in candle.indicators:\n        return candle.indicators[name]\n\n    if name in candle.sub_indicators:\n        return candle.sub_indicators[name]\n\n    return None\n</code></pre>"},{"location":"reference/hexital/utils/candles/#hexital.utils.candles.reading_by_index","title":"reading_by_index","text":"<pre><code>reading_by_index(\n    candles: List[Candle], name: str, index: int = -1\n) -&gt; float | dict | None\n</code></pre> <p>Simple method to get a reading from the given indicator from it's index</p> Source code in <code>hexital/utils/candles.py</code> <pre><code>def reading_by_index(candles: List[Candle], name: str, index: int = -1) -&gt; float | dict | None:\n    \"\"\"Simple method to get a reading from the given indicator from it's index\"\"\"\n    if not valid_index(index, len(candles)):\n        return None\n\n    return reading_by_candle(candles[index], name)\n</code></pre>"},{"location":"reference/hexital/utils/candles/#hexital.utils.candles.reading_count","title":"reading_count","text":"<pre><code>reading_count(\n    candles: List[Candle], name: str, index: Optional[int] = None\n) -&gt; int\n</code></pre> <p>Returns how many instance of the given indicator exist</p> Source code in <code>hexital/utils/candles.py</code> <pre><code>def reading_count(candles: List[Candle], name: str, index: Optional[int] = None) -&gt; int:\n    \"\"\"Returns how many instance of the given indicator exist\"\"\"\n    index_ = absindex(index, len(candles))\n\n    for count, idx in enumerate(range(index_, -1, -1)):\n        if reading_by_candle(candles[idx], name) is None:\n            return count\n\n    return index_ + 1\n</code></pre>"},{"location":"reference/hexital/utils/candles/#hexital.utils.candles.reading_period","title":"reading_period","text":"<pre><code>reading_period(\n    candles: List[Candle], name: str, period: int, index: Optional[int] = None\n) -&gt; bool\n</code></pre> <p>Will return True if the given indicator goes back as far as amount, It's true if exactly or more than. Includes index</p> Source code in <code>hexital/utils/candles.py</code> <pre><code>def reading_period(\n    candles: List[Candle], name: str, period: int, index: Optional[int] = None\n) -&gt; bool:\n    \"\"\"Will return True if the given indicator goes back as far as amount,\n    It's true if exactly or more than. Includes index\"\"\"\n    if not candles:\n        return False\n\n    period_ = period - 1\n    index_ = absindex(index, len(candles))\n\n    if index_ - period_ &lt; 0:\n        return False\n\n    for point in [period_, period_ / 2, 0]:\n        if reading_by_index(candles, name, index_ - int(point)) is None:\n            return False\n    return True\n</code></pre>"},{"location":"reference/hexital/utils/candlesticks/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> candlesticks","text":""},{"location":"reference/hexital/utils/candlesticks/#hexital.utils.candlesticks","title":"candlesticks","text":""},{"location":"reference/hexital/utils/common/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> common","text":""},{"location":"reference/hexital/utils/common/#hexital.utils.common","title":"common","text":""},{"location":"reference/hexital/utils/indexing/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> indexing","text":""},{"location":"reference/hexital/utils/indexing/#hexital.utils.indexing","title":"indexing","text":"<p>Functions:</p> Name Description <code>absindex</code> <p>Ensure's Index is a positive index, -1 == length-1</p>"},{"location":"reference/hexital/utils/indexing/#hexital.utils.indexing.absindex","title":"absindex","text":"<pre><code>absindex(index: int | None, length: int) -&gt; int\n</code></pre> <p>Ensure's Index is a positive index, -1 == length-1</p> Source code in <code>hexital/utils/indexing.py</code> <pre><code>def absindex(index: int | None, length: int) -&gt; int:\n    \"\"\"Ensure's Index is a positive index, -1 == length-1\"\"\"\n    if index is None:\n        return length - 1\n    if not valid_index(index, length):\n        return length - 1\n    if index &lt; 0:\n        return length + index\n    return index\n</code></pre>"},{"location":"reference/hexital/utils/timeframe/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> timeframe","text":""},{"location":"reference/hexital/utils/timeframe/#hexital.utils.timeframe","title":"timeframe","text":"<p>Classes:</p> Name Description <code>TimeFrame</code> <p>Pre-defined TimeFrame values</p> <p>Functions:</p> Name Description <code>on_timeframe</code> <p>Checks if timestamp is on a timeframe value</p> <code>round_down_timestamp</code> <p>Find and round down timestamp to the nearest matching timeframe. E.G timeframe of 5 minute</p> <code>trim_timestamp</code> <p>Removes Microseconds from the timestamp and returns it</p> <code>within_timeframe</code> <p>Checks if timestamp is within other timestamp and timeframe period</p>"},{"location":"reference/hexital/utils/timeframe/#hexital.utils.timeframe.TimeFrame","title":"TimeFrame","text":"<p>               Bases: <code>Enum</code></p> <p>Pre-defined TimeFrame values</p>"},{"location":"reference/hexital/utils/timeframe/#hexital.utils.timeframe.on_timeframe","title":"on_timeframe","text":"<pre><code>on_timeframe(timestamp: datetime, timeframe: timedelta) -&gt; bool\n</code></pre> <p>Checks if timestamp is on a timeframe value</p> Source code in <code>hexital/utils/timeframe.py</code> <pre><code>def on_timeframe(timestamp: datetime, timeframe: timedelta) -&gt; bool:\n    \"\"\"Checks if timestamp is on a timeframe value\"\"\"\n    return timestamp.timestamp() % timeframe.total_seconds() == 0\n</code></pre>"},{"location":"reference/hexital/utils/timeframe/#hexital.utils.timeframe.round_down_timestamp","title":"round_down_timestamp","text":"<pre><code>round_down_timestamp(timestamp: datetime, timeframe: timedelta) -&gt; datetime\n</code></pre> <p>Find and round down timestamp to the nearest matching timeframe. E.G timeframe of 5 minute E.G T5: 09:00:01 -&gt; 9:00:00 E.G T5: 09:01:20 -&gt; 9:00:00 E.G T5: 09:05:00 -&gt; 9:05:00 Note: This method also calls trim_timestamp, removing microseconds</p> Source code in <code>hexital/utils/timeframe.py</code> <pre><code>def round_down_timestamp(timestamp: datetime, timeframe: timedelta) -&gt; datetime:\n    \"\"\"Find and round down timestamp to the nearest matching timeframe. E.G timeframe of 5 minute\n    E.G T5: 09:00:01 -&gt; 9:00:00\n    E.G T5: 09:01:20 -&gt; 9:00:00\n    E.G T5: 09:05:00 -&gt; 9:05:00\n    Note: This method also calls trim_timestamp, removing microseconds\n    \"\"\"\n    timestamp = trim_timestamp(timestamp)\n    if timeframe &lt; timedelta(days=1):\n        return datetime.fromtimestamp(\n            timestamp.timestamp() // timeframe.total_seconds() * timeframe.total_seconds(),\n            tz=timestamp.tzinfo,\n        )\n    elif timeframe &lt; timedelta(days=7):\n        return timestamp.replace(hour=0, minute=0, second=0)\n    else:\n        return timestamp.replace(day=0, hour=0, minute=0, second=0)\n</code></pre>"},{"location":"reference/hexital/utils/timeframe/#hexital.utils.timeframe.trim_timestamp","title":"trim_timestamp","text":"<pre><code>trim_timestamp(timestamp: datetime) -&gt; datetime\n</code></pre> <p>Removes Microseconds from the timestamp and returns it</p> Source code in <code>hexital/utils/timeframe.py</code> <pre><code>def trim_timestamp(timestamp: datetime) -&gt; datetime:\n    \"\"\"Removes Microseconds from the timestamp and returns it\"\"\"\n    return timestamp.replace(microsecond=0)\n</code></pre>"},{"location":"reference/hexital/utils/timeframe/#hexital.utils.timeframe.within_timeframe","title":"within_timeframe","text":"<pre><code>within_timeframe(\n    timestamp: datetime, within: datetime, timeframe: timedelta | None\n) -&gt; bool\n</code></pre> <p>Checks if timestamp is within other timestamp and timeframe period</p> Source code in <code>hexital/utils/timeframe.py</code> <pre><code>def within_timeframe(timestamp: datetime, within: datetime, timeframe: timedelta | None) -&gt; bool:\n    \"\"\"Checks if timestamp is within other timestamp and timeframe period\"\"\"\n    if not timeframe:\n        return False\n    return within - timeframe &lt; timestamp &lt;= within\n</code></pre>"},{"location":"reference/hexital/utils/weakreflist/","title":"<code class=\"doc-symbol doc-symbol-nav doc-symbol-module\"></code> weakreflist","text":""},{"location":"reference/hexital/utils/weakreflist/#hexital.utils.weakreflist","title":"weakreflist","text":""}]}